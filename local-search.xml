<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-并发</title>
    <link href="/2022/11/20/Java-%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/11/20/Java-%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-走入并行世界"><a href="#第-1-章-走入并行世界" class="headerlink" title="第 1 章 - 走入并行世界"></a>第 1 章 - 走入并行世界</h1><h2 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h2><ul><li>同步：一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li><li>异步：一旦开始，调用就会立即返回，调用者可以继续后续的操作</li></ul><ul><li>并发：多个任务交替执行</li><li>并行：多个任务同时执行</li></ul><ul><li>临界区：表示一种公共资源或共享数据，可以被多个线程使用，但同一时间只能有一个线程使用。一旦临界区资源被占用，其它线程想要使用就必须等待</li></ul><ul><li>阻塞：一个线程占用了临界区资源，其它线程必须等待，导致线程挂起，就是阻塞</li><li>非阻塞：没有一个线程可以防碍其他线程执行，所有线程都会尝试不断前进</li></ul><p>多线程的活跃性问题：</p><ul><li>死锁：多个线程都占有其它线程需要的资源，且都不释放，从而没有一个线程可以同时拿到所有资源，造成所有线程都进入等待</li><li>饥饿：某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行</li><li>活锁：多个线程在竞争资源时，都主动释放给其它线程使用，导致资源不断在两个线程间跳动，从而没有一个线程可以同时拿到所有资源</li></ul><h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><ul><li>阻塞：其它线程释放资源之前，当前线程无法继续执行（悲观）</li><li>无饥饿：对于公平锁，所有线程遵守先进先出的原则，就不会产生饥饿</li><li>无障碍：任何线程都可以进入临界区，但是一旦检测到冲突就需要回滚（乐观）</li><li>无锁：无锁并行都是无障碍的，任何线程都可以进入临界区，且必然有一个线程可以在有限步内完成操作并离开。通常包含一个无限循环尝试竞争</li><li>无等待：要求所有线程在有限步内完成操作，分为有界无等待和与线程数无关的无等待。典型的如RCU（Read Copy Update），对读不加控制，修改只针对副本，并在合适的时机写回</li></ul><h2 id="并行加速定律"><a href="#并行加速定律" class="headerlink" title="并行加速定律"></a>并行加速定律</h2><pre><code class="hljs">加速比 = 优化前耗时 / 优化后耗时</code></pre><ol><li>Amdahl 定律<br>并行优化的效果取决于CPU数量，以及系统中的串行化代码的比例。CPU数量越多，串行化比例越低，优化效果越好。仅增加CPU数量而不降低串行化比例，无法提高系统性能。</li><li>Gustafson 定律<br>只要增加处理器，就能获得更快的速度。如果可被并行化的代码所占比例足够大，那么加速比就能随着处理器数量线性增长。</li></ol><h2 id="JMM-并发原则"><a href="#JMM-并发原则" class="headerlink" title="JMM 并发原则"></a>JMM 并发原则</h2><ul><li>原子性：<ul><li>一个操作不可中断</li><li>对于32位JVM，long和double两个64位数据的读写是不保证原子性的</li></ul></li><li>可见性：<ul><li>一个线程修改了某个共享变量，其它线程是否能够立即得知这个修改。</li><li>原因在于缓存优化、硬件优化、指令重排、编辑器的优化等</li><li>在一个线程中观察另一个线程的变量，它们的值是否能观察到、何时能观察到是没有保证的</li></ul></li><li>有序性：<ul><li>程序在执行时可能会进行指令重排，于原指令的顺序未必一致</li><li>原因在于一条指令的执行，对于CPU来说需要分为多个步骤依次执行，为了提高CPU效率，使用了流水线技术。这样就可能某个步骤需要等另一指令的某个步骤先完成，从而产生中断。为了尽可能减少流水线的中断，因此需要做指令重排</li><li>不能重排的指令：Happen-Before规则 保证指令重排不会破坏原有的语义<ul><li>程序顺序原则：在一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写先于读发生，保证了volatile变量的可见性</li><li>锁规则：unlock必然发生在随后的lock前</li><li>传递性：A先于B，B先于C，则A必先于C</li><li>线程<code>start()</code>方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结<code>Thread.join()</code></li><li>线程的中断<code>interrupt()</code>先于被中断线程的代码</li><li>对象构造函数的执行、结束先于<code>finalize()</code></li></ul></li></ul></li></ul><hr><h1 id="第-2-章-并行程序基础"><a href="#第-2-章-并行程序基础" class="headerlink" title="第 2 章 - 并行程序基础"></a>第 2 章 - 并行程序基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>进程是程序的基本执行实体，是线程的容器</li><li>线程是轻量级进程，是程序执行的最小单位</li><li>线程的切换和调度的成本远远小于进程</li><li>线程的状态：<ul><li>NEW：刚刚创建，线程还没开始执行</li><li>RUNNABLE：线程正在执行，拥有所需的一切资源</li><li>BLOCKED：遇到sychronized同步块暂停执行，进入同步队列(尝试获取锁但失败的线程)，直到获得请求的锁</li><li>WAITING：无限等待，等待一些特殊事件，如notify(), join()</li><li>TIMED_WAITING：有限等待</li><li>TERMINATED：线程执行完毕</li></ul></li></ul><pre><code class=" mermaid">stateDiagram  NEW --&gt; RUNNABLE: 启动  RUNNABLE --&gt; BLOCKED: synchronized  BLOCKED --&gt; RUNNABLE: synchronized  RUNNABLE --&gt; WAITING: wait()  WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TIMED_WAITING: wait()  TIMED_WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TERMINATED: 结束</code></pre><h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><ul><li><p>新建线程：</p><ul><li>extends Thread()::run()</li><li>implements Runnable::run()</li><li>new Thread(Runnable)::start()</li></ul></li><li><p>终止线程：</p><ul><li>Thread::stop(), 不推荐使用。因为会立即终止线程，并释放持有的锁，可能破坏对象一致性</li></ul></li><li><p>线程中断：</p><ul><li>Thread::interrupt() 中断线程</li><li>Thread::isInterrupted() 判断是否中断</li><li>static boolean Thread.interrupted() 判断是否中断，并清除当前中断状态</li><li>Thread::sleep()方法由于中断抛出异常时，会清除中断标志位</li></ul></li><li><p>线程等待</p><ul><li>Object::wait() 对象所在线程停止运行，释放CPU和锁资源，进入等待队列</li><li>Object::notify() 随机唤醒一个等待队列中的线程进入同步队列</li><li>Object::notifyAll() 唤醒等待队列中的的所有线程进入同步队列</li><li>工作原理：<ul><li>每个Object拥有一个等待该对象锁的<code>等待队列</code>，和一个尝试获取锁但失败的线程<code>同步队列</code></li><li>wait()和notify()执行前会先获取Object对象的监视器，执行后释放监视器。因此调用必须包含在对应的synchronized块中</li><li>wait()会主动释放目标对象锁，而sleep()不会释放锁资源，仅让出CPU，且不能被唤醒</li><li>notify()不会立即释放CPU和锁资源，而是等同步代码执行完毕才释放</li></ul></li></ul></li><li><p>线程挂起和恢复 – deprecated</p><ul><li>Thread::suspend() 挂起线程且不释放任何锁资源。挂起的线程竟然属于Runnable状态</li><li>Thread::resume()</li></ul></li><li><p>等待线程结束和谦让</p><ul><li>Thread::join( [millis] ) 无限&#x2F;有限等待，直到目标线程，也就是调用的对象线程执行完毕</li><li>Thread::yield() 让出当前CPU</li><li>join()方法底层是通过wait()实现的，调用的线程执行完毕后会执行notifyAll()唤醒所有等待队列的线程进入同步队列</li></ul></li></ul><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul><li>volatile关键字告诉JVM,该变量极有可能会被某些程序或者线程修改</li><li>volatile有助于操作的原子性,可见性,有序性</li><li>但volatile不能代替锁，不保证一些复合操作的原子性</li></ul><h2 id="线程组-ThreadGroup"><a href="#线程组-ThreadGroup" class="headerlink" title="线程组 - ThreadGroup"></a>线程组 - ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">tg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>( <span class="hljs-string">&quot;PrintGroup&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T2&quot;</span>);<br>t1.start();<br>t2.start();<br>System.out.println(tg.activeCount()); <span class="hljs-comment">// 获得活动线程总数</span><br>tg.list();  <span class="hljs-comment">//打印线程组中所有线程</span><br></code></pre></td></tr></table></figure><h2 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程 - Daemon"></a>守护线程 - Daemon</h2><ul><li>完成一些系统性服务，例如GC线程、JIT线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonT</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 必须在守护线程开始之前设置，否则当作普通的用户线程执行</span><br>t.start();  <span class="hljs-comment">// 只要主线程结束，整个程序就会结束，不管守护线程是否结束</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>Java的线程优先级从低到高为1-10</li><li>Thread::setPriority(int)</li><li>优先级的后果不可预测，无法精确控制。因此如果要求严格，仍需要自己在应用层解决线程调度问题</li></ul><h2 id="线程安全-Synchronized"><a href="#线程安全-Synchronized" class="headerlink" title="线程安全 - Synchronized"></a>线程安全 - Synchronized</h2><ul><li>对同步的代码加锁，使得每次只有一个线程进入同步块，从而保证现成的安全性</li><li>如果指定加锁对象，则进入同步代码前要先获得指定对象的锁</li><li>如果作用于实例方法，相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>如果作用于静态方法，相当于对当前类加锁，进入同步代码前要获得当前类的锁</li><li>synchronized还可以保证线程间的可见性和有序性（使多线程串行执行）</li></ul><h2 id="并发下的隐蔽错误"><a href="#并发下的隐蔽错误" class="headerlink" title="并发下的隐蔽错误"></a>并发下的隐蔽错误</h2><ul><li>如非线程安全的ArrayList, HashMap, Integer等等</li><li>jps查看系统运行的Java程序，jstack pid 打印指定java进程的内部线程及其堆栈</li></ul><hr><h1 id="第3章-JDK并发包"><a href="#第3章-JDK并发包" class="headerlink" title="第3章 - JDK并发包"></a>第3章 - JDK并发包</h1><h2 id="同步控制工具"><a href="#同步控制工具" class="headerlink" title="同步控制工具"></a>同步控制工具</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote><p>可重入锁，性能和synchronized相当，但使用更灵活，提供额外的高级功能</p></blockquote><ul><li>ReentrantLock::lock() 获得锁，如果锁已经被占用，则等待</li><li>ReentrantLock::lock(boolean fair) 公平锁，维护一个等待队列，先来后到</li><li>ReentrantLock::lockInterruptibly() 获得锁，但优先响应中断</li><li>ReentrantLock::tryLock() 尝试获得锁，不等待直接返回。如果成功返回true，失败返回false。</li><li>ReentrantLock::tryLock(time, TimeUnit) 在给定时间内尝试获取锁</li><li>ReentrantLock::unlock 释放锁</li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><blockquote><p>与重入锁关联的wait &#x2F; notify机制</p></blockquote><ul><li>Lock::newCondition()</li><li>Condition::await() 使当前线程进入等待队列，同时释放当前锁。要求先获得相关锁</li><li>Condition::awaitUninterruptibly() 使当前线程进入等待队列，但等待时不响应中断。要求先获得相关锁</li><li>Condition::signal() &#x2F; signalAll() 唤醒一个&#x2F;所有等待队列中的线程。要求先获得相关锁</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote><ol><li>基于许可的多线程控制<br>  为每个访问共享区间的线程派发一个许可，拿到许可的线程才能进入共享区间活动。完成任务离开共享区间时，必须归还许可，以确保后续的线程可以正常取得许可。如果许可用完，则线程必须先等待。</li><li>排他锁和共享锁<br>  排他模式下，只有一个线程可以访问共享变量。而共享模式下，则允许多个线程同时访问共享变量。例如，重入锁是排他的，信号量是共享的。</li></ol></blockquote><p>信号量是对锁的扩展，允许多个线程同时访问共享资源</p><ul><li>Semaphore(int permits, [boolean fair]) 构造信号量，指定准入数，可选是否公平</li><li>Semaphore::acquire(), Semaphore::acquireUninterruptibly()</li><li>Semaphore::tryAcquire(), Semaphore::tryAcquire(timeout, TimeUnit)</li><li>Semaphore::release()</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><blockquote><p>JDK5提供的读写分离锁，可以有效地减少锁竞争，提升系统性能。</p></blockquote><ul><li>读写锁的访问约束：<ul><li>读与读不互斥</li><li>读与写互斥</li><li>写与写互斥</li></ul></li><li>API:<ul><li>实现类：ReentrantReadWriteLock()</li><li>ReadWriteLock::readLock(), ReadWriteLock::writeLock()</li><li>锁操作和ReentrantLock基本一致</li></ul></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote><p>倒计数器，Latch：门闩。通常用来控制线程等待，让某一个线程等倒计数结束再开始执行</p></blockquote><ul><li>CountDownLatch(int count) 指定数量的线程完成任务后，等待在Latch上的线程才能继续执行</li><li>CountDownLatch::countDown() 通知Latch一个线程已经完成了任务，计数器减一</li><li>CountDownLatch::await() 设置Latch阻止线程继续执行，直到指定数量的线程执行至此</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote><p>循环栅栏，每若干个线程任务执行完，调用一次指定的动作</p></blockquote><ul><li>CyclicBarrier(int parties, Runnable barrierAction) 每若干个任务完成，执行一次barrierAction</li><li>CyclicBarrier::await() 设置Barrier阻止线程继续执行，直到指定数量的线程执行至此</li><li>BrokenBarrierException 表示当前Barrier已经破损，可能无法等待所有线程到齐。例如一个线程被中断，其它线程就会收到该异常</li></ul><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote><p>线程阻塞工具，可以在线程内任意位置让线程阻塞，不需要先获得对象锁，也不抛出InterruptedException，弥补了suspend&#x2F;resume导致线程无法继续执行的情况</p></blockquote><ul><li>static LockSupport::park(), parkNanos(), parkUntil() (有限)阻塞当前线程。支持中断响应，通过Thread.interrupted()获得中断标记</li><li>static LockSupport::unpark(thread) 类似信号量机制给予线程继续执行的许可，但许可数量仅为1</li></ul><h3 id="深度理解-AbstractQueuedSynchronizer"><a href="#深度理解-AbstractQueuedSynchronizer" class="headerlink" title="深度理解 AbstractQueuedSynchronizer"></a>深度理解 AbstractQueuedSynchronizer</h3><blockquote><p>重入锁、信号量内部各有一个AbstractQueuedSynchronizer的子类Sync。<br>Sync内部维护了一个同步等待队列，保存等待在这个锁上的线程，如lock()引起的等待。<br>还维护了一个条件变量等待队列，保存等待在条件变量上的等待变量，如Condition.await()引起阻塞的线程。<br>一个重入锁可以生成多个条件变量，因此可能有多个条件变量等待队列<br>AbstractQueuedSynchronizer是重入锁、信号量、读写锁等并发工具的核心</p></blockquote><h3 id="Guava-和-RateLimiter"><a href="#Guava-和-RateLimiter" class="headerlink" title="Guava 和 RateLimiter"></a>Guava 和 RateLimiter</h3><blockquote><p>Guava是Google的一个核心库，常用作项目的基础工具库。RateLimiter是其中的一个限流工具库<br>为了维持服务器的负载平稳，需要进行限流措施。普通的平均限流过于简单粗暴。经典的两种限流算法：</p><ul><li>漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先保存在缓存区内，然后再以固定的流速流出缓存区并加以处理。特点是无论外部请求压力如何，总是以固定的流速处理数据。漏桶容积和流出速率是该算法的两个重要参数。</li><li>令牌桶算法：桶中存放令牌，程序只有拿到令牌才能对请求进行处理。没有令牌则要么丢弃请求，要么等待可用令牌。该算法在单位时间产生一定量的令牌存入桶中，桶的容量有限，且令牌数不会超过桶的容量。</li></ul><p>Guava中的RateLimiter采用了令牌桶算法</p></blockquote><h2 id="线程复用-ThreadPool"><a href="#线程复用-ThreadPool" class="headerlink" title="线程复用 - ThreadPool"></a>线程复用 - ThreadPool</h2><blockquote><p>虽然与进程相比，线程是一种轻量级的工具，但其创建和销毁依然需要花费时间，线程过多容易导致创建和销毁的开销大于真实工作的时间，同时大量线程会抢占宝贵的内存资源，导致OOM，给GC带来压力。因此，对线程的使用需要掌握一个度。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为了避免系统频繁的创建和销毁线程，利用线程池技术对线程进行复用<br>线程池负责对线程进行控制和管理。其中有活跃线程，需要时直接拿来用，完成工作后不关闭，返回线程池，方便其它任务执行。</p><h3 id="JDK-Executor框架"><a href="#JDK-Executor框架" class="headerlink" title="JDK - Executor框架"></a>JDK - Executor框架</h3><ul><li>Executors 线程池工厂，返回ExecutorService (ThreadPoolExecutor) 对象，表示一个线程池<ul><li><code>newFixedThreadPool</code>: 返回一个固定线程数量的线程池。新任务提交时，若有空闲线程立即执行，否则暂存在任务队列中</li><li><code>newSingleThreadExecutor</code>: 返回只有一个线程的线程池</li><li><code>newCachedThreadPool</code>: 返回一个可调整线程数量的线程池。新任务提交时，优先使用可复用线程，否则创建新线程处理任务。所有线程完成后返回线程池，空闲线程有存活时间</li><li><code>newSingleThreadScheduledExecutor</code>: 返回一个ScheduledExecutorService对象，线程数量为1。用于实现延时、周期任务。如果中途任务出现异常，后续执行都会被中断。<ul><li>schedule(Runnable, delay, TimeUnit) 延迟执行任务</li><li>scheduleAtFixedRate(Runnable, initialDelay, period, TimeUnit) 固定速率循环执行任务。但必须等上一个任务执行完才会开始下一个</li><li>scheduleWithFixedDelay(Runnable, initialDelay, delay, TimeUnit) 上一个任务执行完间隔delay后开始下一个</li></ul></li><li><code>newScheduledThreadPool</code>: 返回一个ScheduledExecutorService对象，线程数量可指定</li></ul></li></ul><pre><code class=" mermaid">classDiagram  Executor &lt;|-- ExecutorService  &lt;&lt;interface&gt;&gt; Executor  Executor: + execute(Runnable)  &lt;&lt;interface&gt;&gt; ExecutorService  ExecutorService: + shutdown()  ExecutorService: + isTerminated()  ExecutorService: + submit()  ExecutorService: + ......()  AbstractExecutorService ..|&gt; ExecutorService  AbstractExecutorService &lt;|-- ThreadPoolExecutor  ThreadPoolExecutor: +ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</code></pre><h3 id="线程池内部实现-ThreadPoolExecutor"><a href="#线程池内部实现-ThreadPoolExecutor" class="headerlink" title="线程池内部实现 - ThreadPoolExecutor"></a>线程池内部实现 - ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,      <span class="hljs-comment">// 指定常驻线程数量</span><br>                   <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">// 指定允许的最大线程数量</span><br>                   <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">// 当线程数量超过corePoolSize后，多余的空闲线程的存活时间</span><br>                   TimeUnit unit,         <span class="hljs-comment">// keepAliveTime单位</span><br>                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">// 任务队列，保存被提交但尚未被执行的任务</span><br>                   ThreadFactory threadFactory,       <span class="hljs-comment">// 线程工厂，用于创建线程</span><br>                   RejectedExecutionHandler handler   <span class="hljs-comment">// 任务过多时的拒绝策略</span><br>                   )<br></code></pre></td></tr></table></figure><h4 id="任务队列-BlockingQueue"><a href="#任务队列-BlockingQueue" class="headerlink" title="任务队列 - BlockingQueue"></a>任务队列 - BlockingQueue</h4><p>指被提交但未执行的任务队列，一个BlockingQueue接口的对象，仅用于存放Runnable对象。常用的队列实现有：</p><ul><li><code>SynchronousQueue</code>: 直接提交的队列，没有容量，来一个任务执行一个，没有多余线程则执行拒绝策略</li><li><code>ArrayBlockingQueue</code>: 有界任务队列，构造时指定容量</li><li><code>LinkedBlockingQueue</code>: 无界任务队列，任务繁忙时会一直创建线程执行，直至资源耗尽</li><li><code>PriorityBlockingQueue</code>: 带有执行优先级的无界队列</li></ul><p>使用自定义线程池时，需要根据应用的具体情况，选择合适的并发队列为任务做缓冲。当线程资源紧张时，不同的并发队列对系统行为和性能的影响均不同。</p><pre><code class=" mermaid">graph LR  任务提交 -- 小于corePoolSize --&gt; end1(分配线程执行)  任务提交 -- 大于corePoolSize --&gt; 提交到等待队列 -- 成功 --&gt;等待执行  提交到等待队列 -- 失败 --&gt; 提交线程池 -- 已达到最大线程数 --&gt; 拒绝执行  提交线程池 -- 未达到最大线程数 --&gt; end2(分配线程执行)</code></pre><h4 id="拒绝策略-RejectedExecutionHandler"><a href="#拒绝策略-RejectedExecutionHandler" class="headerlink" title="拒绝策略 - RejectedExecutionHandler"></a>拒绝策略 - RejectedExecutionHandler</h4><p>指定当任务数量超过系统实际承载能力时的策略，通常是线程池中的线程已经用完，达到了最大线程数，排队队列也已满的情况。ThreadPoolExecutor提供了以下策略：</p><ul><li><code>AbortPolicy</code>: 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>CallersRunsPolicy</code>: 绕过线程池，由主线程直接调用任务的run()方法执行</li><li><code>DiscardOldestPolicy</code>: 抛弃队列中等待最久的任务，然后尝试再次提交当前任务</li><li><code>DiscardPolicy</code>: 丢弃且不抛异常</li></ul><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 - ThreadFactory"></a>线程工厂 - ThreadFactory</h4><p>ThreadFactory接口用来创建线程，其中仅有一个方法<code>Thread newThread(Runnable r);</code><br>通常使用<code>Executors.defaultThreadFactory()</code>即可</p><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>通过重写ThreadPoolExecutor中提供的接口对线程池进行控制</p><ul><li>ThreadPoolExecutor::beforeExecute(Thread t, Runnable r) 线程执行前</li><li>ThreadPoolExecutor::afterExecute(Runnable r, Throwable t) 线程执行后</li><li>ThreadPoolExecutor::terminated() 线程池销毁后</li></ul><h4 id="获取线程池的堆栈信息"><a href="#获取线程池的堆栈信息" class="headerlink" title="获取线程池的堆栈信息"></a>获取线程池的堆栈信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(...);<br><br><span class="hljs-comment">// 1. 用execute()替代submit()</span><br>pools.execute(task)<br><br><span class="hljs-comment">// 2. 使用Future (第五章)</span><br><span class="hljs-type">Future</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pools.submit(task)<br>result.get();<br><br><span class="hljs-comment">// 3. 扩展ThreadPoolExecutor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h3><blockquote><p>Java Concurrency in Practice 一书给出了估算线程池大小的公式：<br>$$<br>N_{threads} &#x3D; N_{cpu} \times U_{cpu} \times (1 + \frac{W}{C}<br>$$<br>其中，<br>$ N_{cpu} &#x3D; CPU的数量 $<br>$ U_{cpu} &#x3D; 目标CPU的使用率0-1之间 $<br>$ \frac{W}{C} &#x3D; 等待时间与计算时间的比率 $</p></blockquote><h3 id="Fork-x2F-Join-框架"><a href="#Fork-x2F-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><blockquote><p>Fork: 创建子线程，使得系统进程可以多一个执行分支<br>Join: 等待分支执行结束，获得最终结果<br>ForkJoinPool 可以优化多分支任务的执行，提高效率。例如多线程的负载均衡。但如果任务的划分层次很多且一直得不到返回值，可能出现性能严重下降，或导致栈溢出，引发异常。</p></blockquote><ul><li>ForkJoinPool::submit(ForkJoinTask&lt;T&gt;)  向ForkJoinPool线程池提交一个ForkJoinTask (支持 fork() &#x2F; join() 的任务)</li><li>ForkJoinTask两个子类：RecursiveAction 和 RecursiveTask, 前者没有返回值，后者可以携带返回值</li></ul><h3 id="Guava-线程池"><a href="#Guava-线程池" class="headerlink" title="Guava 线程池"></a>Guava 线程池</h3><ul><li>MoreExecutors::DirectExecutor 提供了一个简单的线程池实现。该线程池不创建额外线程，总是在当前线程中执行任务。便于使用统一的编码风格处理同步和异步调用，简化设计。</li><li>MoreExecutors::getExitingExecutorService() 将普通线程转为Daemon线程池，从而可以在程序执行外后，即便有线程池存在，也能结束线程</li><li>MoreExecutors还提供了对Future模式的扩展，见第5章</li></ul><h2 id="JDK-并发容器"><a href="#JDK-并发容器" class="headerlink" title="JDK 并发容器"></a>JDK 并发容器</h2><p>大部分容器都在java.util.concurrent包中，Collections工具类可以将任意集合包装成线程安全的集合。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Collections::synchronizedMap(map)方法可以将普通map包装成线程安全的map，但是内部频繁使用mutex互斥锁，性能较低。更好的选择是juc下的ConcurrentHashMap，专门为并发进行了性能优化，更适合多线程的场合。</p><ul><li>内部数据结构<ul><li><code>int SizeCtl</code> 记录参与Map扩展的线程数量，或新table的扩容阈值</li><li><code>CounterCell[]</code> 记录元素的个数</li><li><code>Node&lt;K, V&gt;[] table</code> 实际存放Map内容的地方</li><li><code>Node&lt;K, V&gt;[] nextTable</code> 当Table需要扩容时，会把新数据填充到nextTable中</li></ul></li><li>节点类型<ul><li><code>Node</code>: 若干链表构成的数组，每个元素是链表的表头</li><li><code>TreeBin</code>: 当链表长度大于等于8时，会将链表树状化，变成一棵红黑树</li><li><code>ForwardingNode</code>: 当数组容量达到75%时，数组将进行扩容。扩容过程中已经完成复制的老数组元素用ForwardingNode对象替代，表示当前槽位数据已经处理过了，避免竞争</li></ul></li></ul><pre><code class=" mermaid">classDiagram  Node &lt;|-- TreeNode  Node &lt;|-- ForwardingNode  Node &lt;|-- TreeBin  TreeNode *-- TreeBin  class Node &#123;    + hash: int    + key: K    + val: V    + next: Node  &#125;   class TreeNode &#123;    + parent: TreeNode    + left: TreeNode    + right: TreeNode    + prev: TreeNode    +red: boolean  &#125;    class ForwardingNode&#123;    + nextTable: Node&lt;K, V&gt;  &#125;  class TreeBin &#123;    + root: TreeNode    + first: TreeNode    + waiter: Thread    + prev: TreeNode    + red: boolean  &#125;</code></pre><ul><li>put()方法实现步骤<ul><li>尝试初始化数组</li><li>可能参与帮助扩容 - helpTransfer()</li><li>根据对应槽位是链表还是红黑树，放入给定的key、value</li><li>统计元素总数 - CounterCell()</li><li>根据是否达到负载因子，默认0.75，触发扩容操作。扩容会将一半的元素移到新空间，且相对位置不变</li></ul></li><li>get()方法实现步骤<ul><li>根据hash值得到对应槽位</li><li>若槽位第一个元素key和请求的一样，直接返回</li><li>否则调用对应的find()进行查找<ul><li>链表：顺序查找</li><li>ForwardingNode::find()</li><li>TreeBin::find()</li></ul></li></ul></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>可以通过Collections.synchronizedList(new LinkedList&lt;String&gt;())得到线程安全的LinkedList。对于队列，更推荐使用ConcurrentLinkedQueue。</p><ul><li>ConcurrentLinkedQueue 使用无锁CAS保证并发安全，需要处理可能存在的不一致问题，增加了设计和实现难度，但极大提升了性能</li><li>head, tail分别表示链表的头、尾。但tail的更新并不是及时的，可能产生拖延，每次更新会跳跃两个元素</li></ul><blockquote><p>TODO: 第4章 - 无锁并发</p></blockquote><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>对于CopyOnWriteArrayList，不仅读完全不用加锁，写操作也不会阻塞读操作。只有写操作之间需要进行同步等待。</p><ul><li>所谓CopyOnWrite，就是在写入时，进行一次自我复制，修改时对副本进行操作，写完后再替换原本的数据，这样就保证写操作不影响读操作</li></ul><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>一种实现数据共享通道的接口。主要实现有ArrayBlockingQueue(有界), LinkedBlockingQueue(无界), PriorityBlockingQueue(优先级)…<br>BlockingQueue让服务线程在队列为空时进行等待，有新消息进入队列后，自动将线程唤醒</p><p>以ArrayBlokcingQueue为例：</p><ul><li>压入元素：offer()和put()，队满时offer()立即返回false，而put()会一直等待，直到有空闲位置</li><li>弹出元素：poll()和take()，队空时poll()返回null，而take()会一直等待，直到有可用元素</li><li>物理上是一个数组，逻辑上是一个环形结构，每次入队和出队都会调整队头和队尾两个索引的位置</li></ul><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><ul><li>跳表是一种快速查找数据的数据结构，类似平衡树。但在高并发下，平衡树调整平衡需要一个全局锁，而跳表只需要对局部加锁，因此性能更高。</li><li>跳表分层维护多个链表，每个链表都是有序的，且上层链表都是下层链表元素的子集。不同于哈希map，跳表在插入时随机插入，但会维护有序性</li><li>跳表是一种使用空间换时间的算法，查询的时间复杂度为$O(logn)$</li><li>ConcurrentSkipListMap使用CAS对Node操作，保证并发安全</li></ul><h2 id="JMH-性能测试"><a href="#JMH-性能测试" class="headerlink" title="JMH 性能测试"></a>JMH 性能测试</h2><p>一个专门用于性能测试的框架，基本概念：</p><ol><li>模式 Mode<ul><li>Throughput: 整体吞吐量，1s内可执行调用次数</li><li>AverageTime: 调用的平均时间</li><li>SampleTime: 随机取样，最后输出取样结果的分布</li><li>SingleShotTime: 运行一次时间，通常测试冷启动时的性能</li></ul></li><li>迭代 Iteration<ul><li>JMH一次测量单位，通常为1s</li></ul></li><li>预热 Warmup<ul><li>由于JVM的JIT机制，编译前后的效率不同，通常只考虑JIT编译后的性能</li></ul></li><li>状态 State<ul><li>指定对象作用范围</li><li>Scope.Thread 一个对象仅被一个线程访问</li><li>Scope.Benchmark 多个线程共享一个实例</li></ul></li><li>配置类 Options&#x2F;OptionsBuilder<ul><li>对测试进行配置，指定一些参数，如测试类、进程个数、预热迭代次数</li></ul></li></ol><hr><h1 id="第4章-锁优化"><a href="#第4章-锁优化" class="headerlink" title="第4章 - 锁优化"></a>第4章 - 锁优化</h1><p>锁是最常用的同步方法之一，对于多核CPU实现多线程可以明显提高系统的性能，但也会增加额外的开销，高并发环境下，激烈的锁竞争会导致程序的性能下降。因此，必须合理设计并发。</p><h2 id="提高锁性能"><a href="#提高锁性能" class="headerlink" title="提高锁性能"></a>提高锁性能</h2><ul><li>减少锁持有时间：只在必要时进行同步，有助于降低锁冲突的可能性，进而提高系统吞吐量</li><li>减小锁粒度：通过分割数据结构，缩小锁定对象的范围，降低锁冲突的可能性</li><li>用读写分离锁替换独占锁：在读多写少的场合可以有效提升系统并发能力</li><li>锁分离：读写锁的进一步延申，分割系统功能点，实现不同功能的可并发</li><li>锁粗话：对于一连串的锁请求和锁释放，尽量整合成单次锁请求，尤其是循环内的锁请求</li></ul><h2 id="JVM-的锁优化"><a href="#JVM-的锁优化" class="headerlink" title="JVM 的锁优化"></a>JVM 的锁优化</h2><ul><li>锁偏向：<ul><li>如果一个线程获得了锁，锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作</li><li>适合几乎没有锁竞争的场合，节省了大量有关锁请求的操作，提高程序性能</li><li>但如果锁竞争激烈，每次都是不同线程请求锁，偏向模式就会失效，性能反而会下降</li></ul></li><li>轻量级锁：<ul><li>如果锁偏向失效，JVM并不会立即挂起线程。，而是使用轻量级锁</li><li>即简单地将对象头部作为指针指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁</li><li>线程若成功获得轻量级锁，则顺利进入临界区。反之，当前线程就会膨胀为重量级锁</li></ul></li><li>自旋锁：<ul><li>锁膨胀后，为了避免真的挂起线程，JVM尝试让当前线程做几个空循环</li><li>若干循环后，如果可以得到锁，则进入临界区，节省了线程挂起的巨大开销</li><li>如果还是不能获得锁，就真的将线程在OS层面挂起</li></ul></li><li>锁消除：<ul><li>JVM在JIT编译时，基于逃逸分析，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁</li></ul></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul><li>为每一个线程分配一个独立的线程局部对象，只有当前线程可访问。因此自然是线程安全的</li><li>ThreadLocal::set(), ThreadLocal::get()</li><li>实现上，Thread::ThreadLocal::ThreadLocalMap使用弱引用保存各个线程的局部变量，key是ThreadLocal对象，value是局部变量</li><li>如果共享对象对于竞争的处理容易引起性能损失，就应该考虑使用ThreadLocal为每个线程分配单独的对象</li><li>ThreadLocalRandom继承自Random，使用Unsafe，让每个线程维护自己的种子变量，不存在竞争，优化了高并发环境中随机数的产生效率</li></ul><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板</title>
    <link href="/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题模板"><a href="#算法题模板" class="headerlink" title="算法题模板"></a>算法题模板</h1><br>参考：https://lghost1999.github.io/algorithm_template/<span id="more"></span><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先写check函数，想一下check如何更新区间</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-comment">// 不用(left + right)/2 是为了防止整数溢出</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>; <br><span class="hljs-keyword">while</span>(left &lt; right)<br>&#123;<br><span class="hljs-keyword">if</span>(check(mid)) <br>            right = mid;<br><span class="hljs-keyword">else</span> <br>            left = mid + <span class="hljs-number">1</span>;<br>        mid = left + (right - left) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class=" mermaid">stateDiagram    java.util.Collection&amp;nbsp[I] --&gt; java.util.List&amp;nbsp[I]    java.util.List&amp;nbsp[I] --&gt; java.util.ArrayList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.LinkedList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.Vector&amp;nbsp[C]    java.util.Vector&amp;nbsp[C] --&gt; java.util.Stack&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Set&amp;nbsp[I]    java.util.Set&amp;nbsp[I] --&gt; java.util.HashSet&amp;nbsp[C]       java.util.Set&amp;nbsp[I] --&gt; java.util.SortedSet&amp;nbsp[I]    java.util.SortedSet&amp;nbsp[I] --&gt; java.util.TreeSet&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Queue&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.Deque&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.PriorityQueue&amp;nbsp[C]</code></pre><pre><code class=" mermaid">stateDiagram    java.util.Map&amp;nbsp[I] --&gt; java.util.SortedMap&amp;nbsp[I]    java.util.SortedMap&amp;nbsp[I] --&gt; java.util.TreeMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.Hashtable&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.HashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.LinkedHashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.WeakHashMap&amp;nbspC]</code></pre><p>[I]: 接口<br>[C]: 类<br>其中，Vector、Stack、HashTable线程安全，但已经基本不用了。</p><h3 id="数组-Array或ArrayList"><a href="#数组-Array或ArrayList" class="headerlink" title="数组 - Array或ArrayList"></a>数组 - Array或ArrayList</h3><ul><li>get和set操作时间上都是O(1)</li><li>add和remove都是O(N)</li><li>ArrayList添加元素不必考虑越界，超出容量时自动扩张</li><li>Vector相比于ArrayList，实现了线程安全，但效率较低</li></ul><h3 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 - LinkedList"></a>链表 - LinkedList</h3><ul><li>get和set操作时间上都是O(N)</li><li>add和remove都是O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;addd&quot;</span>);<span class="hljs-comment">//add</span><br>linkedList.set(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;s&quot;</span>); <span class="hljs-comment">//set，必须先保证 linkedList中已经有第0个元素</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span>  linkedList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//get</span><br>linkedList.contains(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//查找</span><br>linkedList.remove(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//删除</span><br><span class="hljs-comment">// 以上方法也适用于ArrayList</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="队列-LinkedList"><a href="#队列-LinkedList" class="headerlink" title="队列 - LinkedList"></a>队列 - LinkedList</h3><ul><li>LinkedList实现了Deque，可以作为双向&#x2F;单向队列</li><li>PriorityQueue实现了带优先级的队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 尾部入队，区别在于如果失败了，add方法会抛出一个IllegalStateException异常，而offer方法返回false</span><br>deque.offer(<span class="hljs-number">122</span>);<br>deque.add(<span class="hljs-number">122</span>);<br><span class="hljs-comment">// 头部出队，区别在于如果失败了，remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span><br><span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> deque.poll();<span class="hljs-comment">//删除第一个元素并返回</span><br>head = deque.remove();  <span class="hljs-comment">//删除第一个元素并返回</span><br><span class="hljs-comment">// 头部出队，区别在于如果失败了，element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span><br>head = deque.peek();    <span class="hljs-comment">//返回第一个元素，不删除</span><br>head = deque.element(); <span class="hljs-comment">//返回第一个元素，不删除</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="栈-ArrayDeque"><a href="#栈-ArrayDeque" class="headerlink" title="栈 - ArrayDeque"></a>栈 - ArrayDeque</h3><ul><li>Stack实现了后进先出，但继承自Vector，线程安全但效率低，因此不推荐使用</li><li>ArrayDeque实现了Deque，可以作为栈（但仍可以违反栈的单端操作规则）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>stack.push(<span class="hljs-number">12</span>);<span class="hljs-comment">//尾部入栈</span><br>stack.push(<span class="hljs-number">16</span>);<span class="hljs-comment">//尾部入栈</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> stack.pop();<span class="hljs-comment">//尾部出栈，并删除该元素</span><br>tail = stack.peek();<span class="hljs-comment">//尾部出栈，不删除该元素</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 - Deque"></a>双端队列 - Deque</h3><ul><li>ArrayDeque基于数组实现了双端队列</li><li>LinkedList基于双向链表实现了双端队列</li><li>另有两个线程安全的实现类：ConcurrentLinkedDeque, LinkedBlockingDeque<pre><code class=" mermaid">classDiagram    Queue &lt;|-- Deque    Deque ..|&gt; ArrayDeque    Deque ..|&gt; LinkedList    &lt;&lt;interface&gt;&gt; Queue    &lt;&lt;interface&gt;&gt; Deque</code></pre></li><li>Deque和Queue提供了两套API，一种抛出异常，另一种返回特殊值</li><li>Deque额外提供了First、Last后缀的方法。<table><thead><tr><th align="center">操作类型</th><th align="center">抛出异常</th><th align="center">返回特殊值</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td></tr><tr><td align="center">拾取</td><td align="center">element()</td><td align="center">peek()</td></tr></tbody></table></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建next数组</span><br><span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];<br>next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; p.length - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || p[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>        next[i] = j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br>i = <span class="hljs-number">0</span>;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-keyword">if</span> (j == p.length)<br>    <span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 访问两个相邻节点：左子节点、右子节点</span><br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格DFS"><a href="#网格DFS" class="headerlink" title="网格DFS"></a>网格DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case</span><br>    <span class="hljs-comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span><br>    <span class="hljs-keyword">if</span> (!inArea(grid, r, c)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 访问的格子不符合要求，直接返回</span><br>    <span class="hljs-keyword">if</span> (grid[r][c] != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    grid[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 将格子标记为「已遍历过」</span><br>    <br>    <span class="hljs-comment">// 访问上、下、左、右四个相邻结点</span><br>    dfs(grid, r - <span class="hljs-number">1</span>, c);<br>    dfs(grid, r + <span class="hljs-number">1</span>, c);<br>    dfs(grid, r, c - <span class="hljs-number">1</span>);<br>    dfs(grid, r, c + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断坐标 (r, c) 是否在网格中</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; grid.length <br>        &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].length;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(node.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-虚拟机</title>
    <link href="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》 学习笔记</p><span id="more"></span><p>参考：</p><ul><li><a href="https://github.com/fenixsoft/jvm_book">https://github.com/fenixsoft/jvm_book</a></li><li><a href="https://github.com/TangBean/understanding-the-jvm">https://github.com/TangBean/understanding-the-jvm</a></li><li><a href="https://github.com/starjuly/UnderstandingTheJVM">https://github.com/starjuly/UnderstandingTheJVM</a></li></ul><h1 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 - Java内存区域与内存溢出异常"></a>第二章 - Java内存区域与内存溢出异常</h1><h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.svg" class="" title="图2-1 Java虚拟机运行时数据区"><h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><ul><li>当前线程所执行的字节码的行号指示器</li><li>字节码解释器通过改变该计数器的值来选取吓一跳需要执行的字节码指令</li><li>线程私有，各线程之间计数器互不影响，独立存储</li><li>不会产生 <code>OutOfMemoryError</code></li></ul><h3 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2 虚拟机栈"></a>2.2.2 虚拟机栈</h3><ul><li>每执行一个方法，虚拟机同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li><li>一个方法的执行到结束，对应着一个栈帧在虚拟机中从入栈到出栈的过程</li><li>局部变量表<ul><li>存放编译期可知的基本数据类型、对象引用、returnAddress</li><li>所需空间在编译期间完成分配</li><li>以局部变量槽Slot来表示</li></ul></li><li>线程私有，生命周期与线程相同</li><li><code>StackOverflowError</code> (栈深度溢出) &#x2F; <code>OutOfMemoryError</code> (内存请求失败)</li></ul><h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h3><ul><li>类似虚拟机栈，不过是为虚拟机使用到的Native方法服务(如C, Cpp)</li><li><code>StackOverflowError</code> &#x2F; <code>OutOfMemoryError</code></li></ul><h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><ul><li>虚拟机管理的最大内存区，负责存放对象实例</li><li>由垃圾收集器GC管理</li><li>线程共享 (可以划分线程私有的分配缓冲区TLAB)</li><li><code>OutOfMemoryError</code></li></ul><h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><ul><li>存储已被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据</li><li>类信息：<ul><li>即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li></ul></li><li>运行时常量池<ul><li>存放编译期生成的各种字面量(<code>static final</code>)与符号引用</li></ul></li><li>线程共享</li><li><code>OutOfMemoryError</code></li></ul><h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><ul><li>不属于JVM运行时数据区</li><li>如使用Native函数库直接分配堆外内存(JDK1.4-NIO)</li><li><code>OutOfMemoryError</code></li></ul><h2 id="2-3-HotSpot虚拟机对象"><a href="#2-3-HotSpot虚拟机对象" class="headerlink" title="2.3 HotSpot虚拟机对象"></a>2.3 HotSpot虚拟机对象</h2><h3 id="2-3-1-对象创建"><a href="#2-3-1-对象创建" class="headerlink" title="2.3.1 对象创建"></a>2.3.1 对象创建</h3><ul><li>步骤：<ul><li>遇到new指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已被加载、加载、解析和初始化，如果没有必须先执行相应类的加载过程</li><li>加载检查通过后，为新生对象分配内存</li><li>内存分配完成后，JVM将该内存空间初始化为0</li><li>JVM对对象进行必要设置，例如元类型信息、HashCode、GC分代年龄等(存储在对象头中)</li><li>JVM对象已产生，接着开始执行对象的构造方法 &lt;init&gt;()</li><li>这样一个真正可用的对象被完全构造出来</li></ul></li><li>分配内存方法：<ul><li>碰撞指针: 使用过的内存放一边，空闲的放另一边，中间用指针分隔。分配内存就是移动指针。内存分配规整</li><li>空闲列表：维护可用内存块的记录表，分配内存时修改记录。内存分配不规整</li></ul></li><li>解决并发：<ul><li><code>CAS</code> 同步：Compare And Swap 保证更新的原子性 </li><li><code>TLAB</code> 本地线程分配缓冲：线程私有的分配缓冲区</li></ul></li></ul><h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h3><ul><li>对象头<ul><li><code>Mark Word</code>: 存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态、偏向信息等</li><li><code>kClass Pointer</code>: 类型指针，对象指向它的类型元数据的指针</li></ul></li><li>实例数据：对象真正存储的有效信息<ul><li>默认分配顺序：longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops(Ordinary Object Pointers)</li><li>相同宽度的字段会被分配在一起，除了oops，其他的长度由长到短</li><li>满足上述条件下，父类定义变量在子类变量之前</li><li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li><li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li></ul></li><li>对齐填充：8Byte整数倍</li></ul><h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h3><ul><li><p>Java通过栈上的reference来操作堆上的具体对象，实现方式主要以下两种</p></li><li><p>句柄访问</p><ul><li>Java堆中划分一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体地址</li><li>好处：reference存储的是稳定句柄，移动对象时不需要改变reference<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" class="" title="对象的访问定位_直接指针访问.png"></li></ul></li><li><p>直接指针</p><ul><li>reference直接存储对象地址，但需要考虑如何存放类型数据的相关信息</li><li>好处：速度快，减少一次指针定位的时间开销<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" class="" title="对象的访问定位_直接指针访问.png"></li></ul></li></ul><h2 id="2-4-实战内存区异常"><a href="#2-4-实战内存区异常" class="headerlink" title="2.4 实战内存区异常"></a>2.4 实战内存区异常</h2><ul><li>VMArgs: <ul><li><code>-Xms20m</code> 最小堆大小</li><li><code>-Xmx20m</code> 最大堆大小</li><li><code>-Xss128k</code> 栈内存大小</li><li><code>-XX:MaxDirectMemorySize=10M</code> 直接内存大小</li><li><code>-XX:+/-UseTLAB</code> 是否使用TLAB</li><li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li><li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code> 内存溢出异常时Dump出当前内存堆转储快照</li></ul></li></ul><h3 id="2-4-1"><a href="#2-4-1" class="headerlink" title="2.4.1"></a>2.4.1</h3><pre><code class="hljs">Java堆溢出：不断new新对象</code></pre><h3 id="2-4-2"><a href="#2-4-2" class="headerlink" title="2.4.2"></a>2.4.2</h3><pre><code class="hljs">虚拟机栈溢出：无限方法递归</code></pre><h3 id="2-4-3"><a href="#2-4-3" class="headerlink" title="2.4.3"></a>2.4.3</h3><pre><code class="hljs">运行时常量池溢出：String::intern 不断向常量池添加字符串方法区溢出：CGLib代理生成大量的类</code></pre><h3 id="2-4-4"><a href="#2-4-4" class="headerlink" title="2.4.4"></a>2.4.4</h3><pre><code class="hljs">直接内存溢出：Unsafe类分配内存</code></pre><h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 - 垃圾收集器与内存分配策略"></a>第三章 - 垃圾收集器与内存分配策略</h1><h2 id="3-2-对象存活判断"><a href="#3-2-对象存活判断" class="headerlink" title="3.2 对象存活判断"></a>3.2 对象存活判断</h2><h3 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h3><ul><li>在对象中添加一个引用计数器</li><li>每当有一个地方引用它，计数器值+1</li><li>当引用失效时，计数器值-1</li><li>任何时刻计数器为0的对象就是不可能再被使用的</li></ul><p>缺陷：</p><ul><li>难以解决对象间相互循环引用的问题，因此现在基本很少使用</li></ul><h3 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h3><ul><li>从根节点<code>GC Roots</code>出发, 根据引用关系向下搜索，搜索过程称为引用链</li><li>如果某个对象到<code>GC Roots</code>间没有任何引用链相连，则此对象不可达，即可回收</li></ul><p><strong>GC Roots</strong>对象：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈JNI引用的对象</li><li>JVM内部的引用</li><li>所有被同步锁<code>synchronized</code>持有的对象</li><li>反映JVM内部情况的<code>JMXBean</code>、<code>JVMTI</code>等等</li></ul><h3 id="3-3-3-引用分类"><a href="#3-3-3-引用分类" class="headerlink" title="3.3.3 引用分类"></a>3.3.3 引用分类</h3><ul><li>强引用<code>Strongly Reference</code>：任何情况下，强引用关系存在，就不会回收此对象，如引用赋值</li><li>软引用<code>Soft Reference</code>：描述有用但非必须的对象。系统在发生内存溢出异常前，会二次回收这些对象</li><li>弱引用<code>Weak Reference</code>：描述非必须对象，弱于软引用。对象只能生存到下一次垃圾收集发生为止</li><li>虚引用<code>PhantomReference</code>：也叫幻影引用。为一个对象设置虚引用关联的唯一目的是为了在这个对象被回收时收到一个系统通知</li></ul><h3 id="3-2-4-是否finalize"><a href="#3-2-4-是否finalize" class="headerlink" title="3.2.4 是否finalize()"></a>3.2.4 是否finalize()</h3><ul><li>回收对象需要经历两次标记过程</li><li>首先进行可达性分析，判断是否与<code>GC Roots</code>存在相连接的引用链</li><li>接着筛选是否需要执行<code>finalize()</code>，如果对象没有覆盖<code>finalize()</code>或者已被JVM调用过，则不需回收</li><li>任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次</li></ul><h3 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h3><ul><li>方法区垃圾收集的”性价比”通常较低</li><li>主要回收废弃的常量和不再使用的类型，条件包括：<ul><li>该类的所有实例都已经被回收</li><li>加载该类的类加载器已被回收</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</li></ul></li></ul><h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h2><h3 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul><p>因此，JVM GC的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(熬过垃圾收集过程的次数)分配到不同的区域之中存储。</p><ul><li>新生代：每次垃圾收集都会有大批对象死去</li><li>老年代：新生代中每次回收后存活的少量对象，将会逐步晋升到老年代</li><li>跨代引用假说：新生代对象可能被老年代所引用。跨代引用相对于同代引用仅占极少数</li></ul><p>垃圾收集分类: </p><ul><li>部分收集 <code>Partial GC</code><ul><li>新生代收集 <code>Minor GC</code></li><li>老年代收集 <code>Major GC</code></li><li>混合收集 <code>Mixed GC</code></li></ul></li><li>整堆收集 <code>Full GC</code></li></ul><h3 id="3-3-2-标记——清除算法-Mark-Sweep"><a href="#3-3-2-标记——清除算法-Mark-Sweep" class="headerlink" title="3.3.2 标记——清除算法 Mark-Sweep"></a>3.3.2 标记——清除算法 Mark-Sweep</h3><ul><li>过程：<ul><li>标记：首先标记出需要回收的对象</li><li>清除：标记完成后，统一回收被标记的对象</li></ul></li><li>缺点：<ul><li>两个过程的执行效率都随对象数量增长而降低</li><li>内存空间的碎片化问题<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" class="" title="alt 标记清除算法"></li></ul></li></ul><h3 id="3-3-3-标记-整理算法-Mark-Copy"><a href="#3-3-3-标记-整理算法-Mark-Copy" class="headerlink" title="3.3.3 标记-整理算法 Mark-Copy"></a>3.3.3 标记-整理算法 Mark-Copy</h3><ul><li><p>半区复制 Semispace Copying</p><ul><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li><li>当一块内存用完，就将还存活的对象复制到另一块上面，然后把已使用的内存块一次清理掉</li></ul></li><li><p>缺点：</p><ul><li>将可用内存缩小为原来的一半<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" class="" title="alt 标记复制算法"></li></ul></li><li><p>改进 —— Appel式回收</p><ul><li>新生代划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配只是用<code>Eden</code>和其中一块<code>Survivor</code></li><li>GC时，将<code>Eden</code>和<code>Survivor</code>中存活对象一次性复制到另一块<code>Survivor</code>，然后清理<code>Eden</code>和原先的<code>Survivor</code></li><li>HotSpot中<code>Eden</code>与<code>Survivor</code>默认大小比例是8:1</li><li>逃生门设计：当<code>Survivor</code>不足以容纳一次GC的存活对象时，需要依赖其它内存区域(如老年代)进行分配担保</li></ul></li></ul><h3 id="3-3-4-标记-整理算法-Mark-Compact"><a href="#3-3-4-标记-整理算法-Mark-Compact" class="headerlink" title="3.3.4 标记-整理算法 Mark-Compact"></a>3.3.4 标记-整理算法 Mark-Compact</h3><ul><li>主要针对老年区，是一种移动式算法</li><li>过程<ul><li>标记：首先标记出需要回收的对象</li><li>整理：让所有存活对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</li></ul></li><li>缺点：<ul><li><code>Stop The World</code>：移动对象必须暂停用户线程<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" class="" title="alt 标记整理算法"></li></ul></li></ul><h2 id="3-4-HotSpot的算法细节"><a href="#3-4-HotSpot的算法细节" class="headerlink" title="3.4 HotSpot的算法细节"></a>3.4 HotSpot的算法细节</h2><h3 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h3><ul><li>通过 <code>OopMap</code> 数据结构来记录对象引用</li></ul><h3 id="3-4-2-安全点-Safepoint"><a href="#3-4-2-安全点-Safepoint" class="headerlink" title="3.4.2 安全点 Safepoint"></a>3.4.2 安全点 Safepoint</h3><ul><li>记录OopMap的地方</li><li>选取标准：<ul><li>不能太少，让GC等待时间过长</li><li>不能太多，增大运行时的内存负荷</li><li>以”是否具有让程序长时间执行的特征”为标准，如方法调用、循环跳转、异常跳转等</li></ul></li><li>中断方案：<ul><li>抢先式中断：GC时，系统先把所有用户线程中断，如果中断位置不在安全点上，就恢复线程，直到到达安全点。如今几乎没有JVM使用。</li><li>主动式中断：GC设置标记位，各个线程轮询标记，发现标记为真则主动在最近的安全点中断挂起。HotSpot使用内存保护陷阱实现。</li></ul></li></ul><h3 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h3><ul><li>指能够确保在某一段代码片段之中，引用关系不会发生变化</li><li>因此，在这个区域中任何地方开始垃圾收集都是安全的</li></ul><h3 id="3-4-4-记忆集和卡表"><a href="#3-4-4-记忆集和卡表" class="headerlink" title="3.4.4 记忆集和卡表"></a>3.4.4 记忆集和卡表</h3><ul><li>记忆集<ul><li>一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li><li>记录精度：<ul><li>字长精度：记录精确到一个机器字长 32&#x2F;64，该字还有跨代指针</li><li>对象精度：精确到一个对象，该对象里有字段含有跨代指针</li><li>卡精度：精确到一块内存区域，该区域内有对象含有跨代指针</li></ul></li></ul></li><li>卡表<ul><li>记忆集的一种实现方式</li><li>对应卡精度</li></ul></li></ul><h3 id="3-4-5-写屏障-Write-Barrier"><a href="#3-4-5-写屏障-Write-Barrier" class="headerlink" title="3.4.5 写屏障 Write Barrier"></a>3.4.5 写屏障 Write Barrier</h3><ul><li>HotSpot通过写屏障技术维护卡表状态</li><li>是对引用类型赋值操作的AOP切面，并产生一个环绕通知</li><li>赋值前的是写前屏障</li><li>赋值后的是写后屏障</li></ul><h3 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h3><ul><li>三色标记<ul><li>白色：表示对象尚未被GC访问过</li><li>黑色：表示对象以及被GC访问过，且该对象的所有引用都已经扫描过</li><li>灰色：表示对象已经被GC访问过，但该对象上至少存在一个引用还没有被扫描过</li></ul></li><li>并发扫描的”对象消失”问题<ul><li>满足两个条件：<ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li><li>赋值器删除了全部从灰色对象到白色对象的直接或间接引用</li></ul></li><li>解决方案：<ul><li>增量更新：破坏条件1。当黑色对象插入新的指向白色对象的引用关系时，记录下新的引用关系，等并发扫描结束，将这些记录的黑色对象为根，重新扫描一次。</li><li>原始快照SATB：破坏条件2。当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用关系记录下来，等并发扫描结束，再将这些记录过的引用关系中的灰色对象为根重新扫描一次。</li></ul></li></ul></li></ul><h2 id="3-5-经典垃圾收集器"><a href="#3-5-经典垃圾收集器" class="headerlink" title="3.5 经典垃圾收集器"></a>3.5 经典垃圾收集器</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt 经典垃圾收集器"><h3 id="3-5-1-Serial-收集器"><a href="#3-5-1-Serial-收集器" class="headerlink" title="3.5.1 Serial 收集器"></a>3.5.1 Serial 收集器</h3><ul><li>新生代GC</li><li>单线程，标记-复制算法</li><li>GC时必须暂停其它所有工作线程，直到它收集结束</li><li>虽然鸡肋，但迄今为止，依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt Serial收集器"><center>Serial/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-2-ParNew-收集器"><a href="#3-5-2-ParNew-收集器" class="headerlink" title="3.5.2 ParNew 收集器"></a>3.5.2 ParNew 收集器</h3><ul><li>新生代GC</li><li><code>ParNew</code>实质上是<code>Serial</code>的多线程并发版本，使用标记-复制算法</li><li>除<code>Serial</code>外，只有<code>ParNew</code>可以和<code>CMS</code>配合使用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt ParNew收集器"><center>ParNew/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-3-Parallel-Scavenge-收集器"><a href="#3-5-3-Parallel-Scavenge-收集器" class="headerlink" title="3.5.3 Parallel Scavenge 收集器"></a>3.5.3 Parallel Scavenge 收集器</h3><ul><li>新生代GC</li><li>与<code>ParNew</code>类似，并行收集，使用标记-复制算法</li><li>目标是达到一个可控制的吞吐量, 因此也称作吞吐量优先收集器<br>$$ 吞吐量 &#x3D; \frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间} $$</li></ul><h3 id="3-5-4-Serial-Old-收集器"><a href="#3-5-4-Serial-Old-收集器" class="headerlink" title="3.5.4 Serial Old 收集器"></a>3.5.4 Serial Old 收集器</h3><ul><li><code>Serial</code>的老年代版本</li><li>单线程，标记-整理算法</li><li><code>CMS</code>发生<code>Concurrent Mode Failure</code>失败时的后备预案<center>Serial/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-5-Parallel-Old-收集器"><a href="#3-5-5-Parallel-Old-收集器" class="headerlink" title="3.5.5 Parallel Old 收集器"></a>3.5.5 Parallel Old 收集器</h3><ul><li><code>Parallel Scavenge</code>的老年代版本</li><li>多线程并发，标记-整理</li><li>注重吞吐量或者处理器资源较为稀缺的场合，优先考虑<code>Parallel Scavenge</code> + <code>Parallel Old</code><center>Parallel Scavenge/Parallel Old 收集器运行示意图</center></li></ul><h3 id="3-5-6-CMS-Concurrent-Mark-Sweep-收集器"><a href="#3-5-6-CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="3.5.6 CMS (Concurrent Mark Sweep) 收集器"></a>3.5.6 CMS (Concurrent Mark Sweep) 收集器</h3><ul><li>老年代GC</li><li>基于标记-清除算法</li><li>四个步骤：<ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。</li><li>重新标记：修正并发标记阶段产生的标记变动(因用户线程的并发执行)。暂停用户线程。</li><li>并发清除：清理标记死亡的对象。与用户线程并发。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt CMS 收集器"></li></ul></li><li>特点：并发收集，低停顿。因此也称”并发低停顿收集器”。</li><li>缺点：<ul><li>对处理器资源非常敏感</li><li>无法处理”浮动垃圾”,可能出现<code>Concurrent Mode Failure</code>进而导致需要一次<code>Full GC</code>(临时启用<code>Serial Old</code>)</li><li>容易产生大量内存碎片空间</li></ul></li></ul><h3 id="3-5-7-Garbage-First-G1-收集器"><a href="#3-5-7-Garbage-First-G1-收集器" class="headerlink" title="3.5.7 Garbage First (G1) 收集器"></a>3.5.7 Garbage First (G1) 收集器</h3><ul><li>开创面向局部收集的设计思路和基于Region内存布局</li><li>Region：<ul><li>连续的Java堆划分为多个大小相等的独立Region，每个Region根据需要扮演Eden&#x2F;Survivor&#x2F;老年代</li><li>Humongous区域专门存储大对象</li><li>G1跟踪各个Region里面的垃圾堆积的”价值”大小。价值即回收所获得的空间大小以及回收所需时间的经验值，后台维护一个优先级列表。</li></ul></li><li>目的：延迟可控的情况下，获得尽可能高的吞吐量。</li><li>四个步骤：<ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象，并修改TAMS指针以便正确分配对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。(用SATB原始快照处理引用变化)</li><li>最终标记：处理并发阶段结束后遗留的少量SATB记录。暂停用户线程。</li><li>筛选回收：更新Region的统计数据，根据优先级选择Region回收集，移动存活对象并清理旧Region的全部空间。暂停用户线程。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt G1 收集器"></li></ul></li></ul><h2 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h2><ul><li>垃圾收集器的衡量指标：<ul><li>内存占用 <code>Footprint</code></li><li>吞吐量 <code>Throughput</code></li><li>延迟 <code>Latency</code></li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%90%84%E6%AC%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5.png" class="" title="alt 各款收集器的并发情况"><center>各款收集器的并发情况</center><h3 id="3-6-1-Shenandoah-收集器"><a href="#3-6-1-Shenandoah-收集器" class="headerlink" title="3.6.1 Shenandoah 收集器"></a>3.6.1 Shenandoah 收集器</h3><ul><li><p>类似G1，基于Region，按照优先级回收</p></li><li><p>特点</p><ul><li>支持并发的整理算法</li><li>默认不使用分代收集</li><li>改用<code>Connection Matrix</code>全局数据结构来记录跨Region的引用关系</li></ul></li><li><p>九个步骤：</p><ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。(时间取决于堆中存活对象的数量和对象图的复杂程度)</li><li>最终标记：处理剩余的SATB扫描，并统计回收价值最高的Region构成回收集。短暂停顿</li><li>并发清理：清理没有存活对象的Region</li><li>并发回收：核心特点。借助<code>读屏障</code>、<code>Brooks Pointers</code>把回收集里的存活对象复制到未被使用的Region</li><li>初始引用更新：把堆中所有指向旧对象的引用修正到复制后的新地址(引用更新)。短暂停顿。</li><li>并发引用更新：真正开始引用更新。与用户线程并发。时间取决于涉及的引用数量。</li><li>最终引用更新：修正存在于GC Roots中的引用。短暂停顿。</li><li>并发清理：回收剩余的回收集中的Region，供以后对象分配使用。<center>Shenandoah 收集器工作流程</center></li></ul></li><li><p>Brooks Pointer</p><ul><li>以前的方案：在被移动对象原有的内存上设置保护陷阱，一旦访问旧对象内存空间产生自陷中断进入预设好的异常处理器中，把访问转发到复制后的对象上</li><li><code>Brooks Pointer</code>在原有对象布局结构的最前面统一增加一个新的引用字段<ul><li>正常情况下，该引用指向对象自己</li><li>移动对象时只需修改该指针即可</li></ul></li><li>缺点：<ul><li>需要额外的间接访问开销</li><li>多线程竞争问题，Shenandoah通过CAS操作保证并发访问正确性</li></ul></li></ul></li></ul><h3 id="3-6-2-ZGC-收集器"><a href="#3-6-2-ZGC-收集器" class="headerlink" title="3.6.2 ZGC 收集器"></a>3.6.2 ZGC 收集器</h3><ul><li>基于Region内存布局，分大、中、小三类容量</li><li>不设分代</li><li>使用读屏障、染色指针、内存多重映射等技术</li><li>可并发，基于标记-整理算法</li><li>以低延迟为首要目标</li></ul><p>染色指针：</p><ul><li><p>直接把少量额外的信息存储在指针上的技术(指针的高位没有用来寻址，需要底层支持)</p></li><li><p>x86-64架构下需要多重映射的支持：将多个不同的虚拟内存地址映射到同一个物理内存地址上(多对一)</p></li><li><p>优势：</p><ul><li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉</li><li>大幅减少垃圾收集过程中内存屏障的使用数量</li><li>可以作为一种可扩展的存储结构用来记录更多数据</li></ul></li><li><p>四个过程</p><ul><li>并发标记：遍历对象图做可达性分析，特殊点在于标记是在指针上而不是在对象上。需短暂停顿。</li><li>并发预备重分配：根据特定查询条件确定回收集</li><li>并发重分配：核心。把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系(用于指针自愈)。</li><li>并发重映射：修正整个堆中指向重分配集中旧对象的所有引用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ZGC%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt ZGC 收集器"></li></ul></li></ul><h1 id="第四章-虚拟机性能监控、故障处理工具"><a href="#第四章-虚拟机性能监控、故障处理工具" class="headerlink" title="第四章 - 虚拟机性能监控、故障处理工具"></a>第四章 - 虚拟机性能监控、故障处理工具</h1><h2 id="4-2-基础故障处理工具"><a href="#4-2-基础故障处理工具" class="headerlink" title="4.2 基础故障处理工具"></a>4.2 基础故障处理工具</h2><ul><li>根据软件可用性和授权的不同，分以下三类：<ul><li>商业授权工具：如JMC(Java Mission Control), JFR(Java Flight Recorder) 等</li><li>正式支持工具：LTS</li><li>试验性工具：Unsupported and Experimental</li></ul></li><li>这些工具JDK9之前在jdk\lib\tools目录下，经过模块化改造后现在在jdk\jmods目录下</li><li>工具本身用Java语言实现</li></ul><h3 id="4-2-1-amp-nbsp-jps-虚拟机进程状况工具"><a href="#4-2-1-amp-nbsp-jps-虚拟机进程状况工具" class="headerlink" title="4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具"></a>4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具</h3><ul><li>JVM Process Status Tool</li><li>列出正在运行的虚拟机进程，并显示虚拟机执行主类，名称，以及这些进程的本地虚拟机唯一ID  (<code>LVMID - Local Virtual Machine Identifier</code>)</li><li>命令格式：<code>jps [options] [hostid]</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E6%A0%B7%E4%BE%8B.png" class="" title="alt jps样例"></li><li>选项参数<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E5%8F%82%E6%95%B0.png" class="" title="alt jps参数"></li></ul><h3 id="4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具"><a href="#4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具" class="headerlink" title="4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具"></a>4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具</h3><ul><li>JVM Statistics Monitoring Tool</li><li>监视虚拟机各种运行状态信息</li><li>命令格式：<code>jstat [ option vmid [interval [s|ms] [count]] ]</code><ul><li>若是本地虚拟机，则VMID与LVMID一致</li><li>若是远程虚拟机，则<code>VMID = [protocol:][//]lvmid[@hostname[:port]/servername]</code></li><li>interval: 查询间隔</li><li>count: 查询次数</li><li>option: 希望查询的虚拟机信息，分三类<ul><li>类加载</li><li>垃圾收集</li><li>运行期编译状况<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E9%80%89%E9%A1%B9.png" class="" title="alt jstat选项"></li></ul></li></ul></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E6%A0%B7%E4%BE%8B.png" class="" title="alt jstat样例"></li></ul><h3 id="4-2-3-amp-nbsp-jinfo-Java配置信息工具"><a href="#4-2-3-amp-nbsp-jinfo-Java配置信息工具" class="headerlink" title="4.2.3 &amp;nbsp; jinfo - Java配置信息工具"></a>4.2.3 &amp;nbsp; jinfo - Java配置信息工具</h3><ul><li>Configuration Info for Java</li><li>实时查看和调整虚拟机各项参数</li><li>命令格式：<code>jinfo [option] pid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jinfo%E6%A0%B7%E4%BE%8B.png" class="" title="alt jinfo样例"></li></ul><h3 id="4-2-4-amp-nbsp-jmap-Java内存映像工具"><a href="#4-2-4-amp-nbsp-jmap-Java内存映像工具" class="headerlink" title="4.2.4 &amp;nbsp; jmap - Java内存映像工具"></a>4.2.4 &amp;nbsp; jmap - Java内存映像工具</h3><ul><li>Memory Map for Java</li><li>生成堆转储快照 (heapdump &#x2F; dump),查询finalize执行队列、Java堆和方法区的详细信息等</li><li>命令格式：<code>jmap [option] vmid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E6%A0%B7%E4%BE%8B.png" class="" title="alt jmap样例"></li><li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E9%80%89%E9%A1%B9.png" class="" title="alt jmap选项"></li></ul><h3 id="4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具"><a href="#4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具"></a>4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具</h3><ul><li>JVM Heap Analysis Tool</li><li>与jmap搭配使用，分析jmap生成的堆转储快照</li><li>比较鸡肋，有更好的Analyzer可以替代</li><li>分析内存泄露问题需要<code>OQL (Object Query Language)</code></li></ul><h3 id="4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具"><a href="#4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具" class="headerlink" title="4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具"></a>4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具</h3><ul><li>Stack Trace for Java</li><li>生成虚拟机当前时刻的线程快照 (threaddump &#x2F; javacore)</li><li>线程快照：当前虚拟机内每条线程正在执行的方法堆栈集合。可以分析线程停顿原因</li><li>JDK5开始，<code>java.lang.Thread</code>类新增<code>getAllStackTraces()</code>方法也可以获取所有线程堆栈</li><li>命令格式：<code>jstack [option] vmid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E6%A0%B7%E4%BE%8B.png" class="" title="alt jstack样例"></li><li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E9%80%89%E9%A1%B9.png" class="" title="alt jstack选项"></li></ul><h3 id="4-2-7-基础工具总结"><a href="#4-2-7-基础工具总结" class="headerlink" title="4.2.7 基础工具总结"></a>4.2.7 基础工具总结</h3><ul><li><p>基础工具：用于支持基本的程序创建和运行</p><ul><li>如<code>jar, java, javac, javadoc, javap, jdb...</code></li></ul></li><li><p>性能监控和故障处理：监控Java虚拟机运行信息，排查问题</p><ul><li>如<code>jps, jstat, jinfo, jmap, jhat...</code></li></ul></li><li><p>安全：用于程序签名，设置安全测试等</p><ul><li>如<code>keytool, jarsigner, policytool</code></li></ul></li><li><p>国际化：用于创建本地语言文件</p><ul><li>如<code>native2ascii</code></li></ul></li><li><p>远程方法调用: 用于跨Web或网络的服务交互</p><ul><li>如<code>rmic, rmiregistry, rmid, serialver</code></li></ul></li><li><p>部署工具：用于程序打包、发布和部署</p><ul><li>如<code>javapackager, pack200, unpack200</code></li></ul></li><li><p>REPL (Read-Eval-Print Loop)和脚本工具：<code>jshell, jjs, jrunscript</code></p></li><li><p>Java IDL 与 RMI-IIOP: 与JDK11的CORBA一起废弃</p></li><li><p>WebService工具：与JDK11的CORBA一起废弃</p></li><li><p>Java Web Start: javaws, jdk11移除</p></li></ul><h2 id="4-3-可视化故障处理工具"><a href="#4-3-可视化故障处理工具" class="headerlink" title="4.3 可视化故障处理工具"></a>4.3 可视化故障处理工具</h2><p><code>JConsole, JHSDB, VisualVM, JMC</code></p><h3 id="4-3-1-JHSDB-基于服务性代理的调试工具"><a href="#4-3-1-JHSDB-基于服务性代理的调试工具" class="headerlink" title="4.3.1 JHSDB: 基于服务性代理的调试工具"></a>4.3.1 JHSDB: 基于服务性代理的调试工具</h3><ul><li>服务性代理<ul><li>一组用于映射Java虚拟机运行信息的，主要基于Java语言实现的API集合</li><li>可以在一个独立的Java虚拟机进程中分析其它HotSpot虚拟机的内存数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节</li></ul></li><li>步骤：<ul><li><code>jps -l</code> 查找对应进程的pid</li><li><code>jhsdb hsdb --pid 3224</code> 进入JHSDB图形化界面</li><li><code>revptrs 0x......</code> 内存块对应的引用指针位置</li></ul></li></ul><h3 id="4-3-2-JConsole-Java监视与管理控制台"><a href="#4-3-2-JConsole-Java监视与管理控制台" class="headerlink" title="4.3.2 JConsole: Java监视与管理控制台"></a>4.3.2 JConsole: Java监视与管理控制台</h3><ul><li>基于<code>JMX(Java Management Extensions)</code>的可视化监视、管理工具</li><li>通过JMX的MBean对系统进行信息收集和参数动态调整</li><li><code>内存</code>页签 - 相当于jstat命令, 监视被收集器直接管理的Java堆和被间接管理的方法区</li><li><code>线程</code>页签 - 相当于jstack命令，分析线程状况、死锁等</li><li>其它还有<code>类、VM摘要、MBean</code>等页签</li></ul><h3 id="4-3-3-VisualVM-多合一故障处理工具"><a href="#4-3-3-VisualVM-多合一故障处理工具" class="headerlink" title="4.3.3 VisualVM: 多合一故障处理工具"></a>4.3.3 VisualVM: 多合一故障处理工具</h3><ul><li>支持插件扩展</li><li>生成、浏览堆转储快照</li><li>分析程序性能</li><li>BTrace动态日志追踪</li></ul><h3 id="4-3-4-Java-Mission-Control-可持续在线的监控工具"><a href="#4-3-4-Java-Mission-Control-可持续在线的监控工具" class="headerlink" title="4.3.4 Java Mission Control: 可持续在线的监控工具"></a>4.3.4 Java Mission Control: 可持续在线的监控工具</h3><ul><li>JMC与虚拟机之间采取JMX协议进行通信</li><li>JMC一方面作为JMX的控制台，显示来自JVM MBean提供的数据，另一方面作为JFR的分析工具，展示来自JFR的数据</li><li><code>JFR(Java Flight Recorder)</code>是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜索框架，用于持续收集数据</li><li>JFR监控对应用完全透明，不需要对程序源码做任何修改或基于特定的代理运行</li></ul><h2 id="4-4-HotSpot虚拟机插件及工具"><a href="#4-4-HotSpot虚拟机插件及工具" class="headerlink" title="4.4 HotSpot虚拟机插件及工具"></a>4.4 HotSpot虚拟机插件及工具</h2><ul><li><code>Ideal Graph Visualizer</code>: 可视化展示C2即时编译器转换字节码</li><li><code>Client Compiler Visualizer</code>: 查看C1即时编译器生成高级中间表示，转换成低级中间表示和做物理寄存器分配的过程</li><li><code>MakeDeps</code>: 帮助处理HotSpot的编译依赖的工具</li><li><code>Project Creator</code>: 帮助生成Visual Studio的.project文件工具</li><li><code>LogCompiler</code>: 整理输出日志</li><li><code>HSDIS</code>: 即时编译器的反汇编插件</li></ul><h3 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h3><ul><li>让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出，并产生有价值的注释</li><li>日志输出量巨大，需配合<code>JITWatch</code>可视化工具使用</li></ul><h1 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 - 调优案例分析与实战"></a>第五章 - 调优案例分析与实战</h1><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><h3 id="5-2-1-大内存硬件上的程序部署策略"><a href="#5-2-1-大内存硬件上的程序部署策略" class="headerlink" title="5.2.1 大内存硬件上的程序部署策略"></a>5.2.1 大内存硬件上的程序部署策略</h3><ul><li><p>单体应用在较大内存的硬件上主要的部署方式分两种</p><ul><li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存</li><li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源</li></ul></li><li><p>对于用户交互性强，对停顿时间敏感，内存又较大的系统，必须控制Full GC频率，关键是老年代的稳定，主要取决于应用中大部分对象是否满足”朝生夕灭”的原则</p></li><li><p>使用单个JVM管理大内存可能面临的问题：</p><ul><li>回收大块堆内存而导致的长时间停顿</li><li>大内存必须有64位虚拟机支持，但64位虚拟机性能普遍略低于32位(指针压缩、处理器缓存行容量等)</li><li>必须保证应用程序的足够稳定</li><li>相同程序在64位下需要比32位消耗更多的内存(指针膨胀、数据类型对齐补白等)</li></ul></li><li><p>逻辑集群方式可能面临的问题：</p><ul><li>节点竞争全局资源，例如磁盘竞争</li><li>很难高效利用某些资源池</li><li>32位系统的节点受到内存限制</li><li>大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费</li></ul></li></ul><h3 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h3><ul><li>集群共享的数据要使用非集中式的集群缓存来同步的话，可以运行读操作频繁，但不应当有过于频繁的写操作</li></ul><h3 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h3><ul><li>在处理小内存或者32位的应用问题时，除了Java堆和方法区之外，还有以下区域会占用较多内存<ul><li>直接内存 (-XX:MaxDirectMemorySize)</li><li>线程堆栈 (-Xss)</li><li>Socket缓存区</li><li>JNI代码</li><li>虚拟机和垃圾收集器</li></ul></li></ul><h3 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h3><ul><li>Java的<code>Runtime.getRuntime().exec()</code>方法可以执行Shell脚本，但会先复制一个当前虚拟机环境变量的进程，再利用新的进程执行外部命令，最后再退出这个进程。频繁执行会造成系统消耗过大</li></ul><h3 id="5-2-5-服务器虚拟机进程崩溃"><a href="#5-2-5-服务器虚拟机进程崩溃" class="headerlink" title="5.2.5 服务器虚拟机进程崩溃"></a>5.2.5 服务器虚拟机进程崩溃</h3><ul><li>异步调用，服务速度不对等，最终超过虚拟机的承受能力</li></ul><h3 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h3><h3 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h3><h3 id="5-2-8-由安全点导致长时间停顿"><a href="#5-2-8-由安全点导致长时间停顿" class="headerlink" title="5.2.8 由安全点导致长时间停顿"></a>5.2.8 由安全点导致长时间停顿</h3><ul><li>三个时间概念：<ul><li>user: 进程执行用户态代码所耗费的处理器时间</li><li>sys: 进程执行核心态代码所耗费的处理器时间</li><li>real: 执行动作从开始到结束耗费的时钟时间</li><li>处理器时间指线程<strong>占用处理器一个核心</strong>的耗时计数</li><li>时钟时间就是指现实世界中的时间计数</li></ul></li><li>安全点的设置<ul><li>一般循环这样的长时间操作是会设置安全点的</li><li>但对于int或范围更小的数据类型作为索引值的循环默认时不放置安全点的，称可数循环(Counted Loop)</li><li>使用long或范围更大的数据类型作为索引值的循环会放置安全点，称不可数循环(Uncounted Loop)</li><li>如果可数循环本身非常耗时，需用<code>-XX:+UseCountedLoopSafepoints</code>强制开启可数循环放置安全点</li></ul></li></ul><h2 id="5-3-实战：Eclipse运行速度调优"><a href="#5-3-实战：Eclipse运行速度调优" class="headerlink" title="5.3 实战：Eclipse运行速度调优"></a>5.3 实战：Eclipse运行速度调优</h2><ul><li>三大块非用户程序时间<ul><li>类加载时间</li><li>编译时间<ul><li>JVM的即时编译器<code>Just In Time Compiler</code>编译热点代码<code>Hot Spot Code</code>的耗时</li></ul></li><li>垃圾收集时间<ul><li>最重要，最耗时，稳定持续的消耗</li></ul></li></ul></li></ul><h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 - 类文件结构"></a>第六章 - 类文件结构</h1><h2 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h2><ul><li>所有平台统一支持的程序存储格式——字节码<code>Byte Code</code>是构成平台无关性的基石<ul><li>Class文件包含了Java虚拟机指令集、符号集以及若干其它辅助信息</li></ul></li><li>语言无关性正在越来越被开发者所重视<ul><li>任何其它语言的实现者都可以将Java虚拟机作为它们语言的运行基础，以Class文件作为它们产品的交付媒介<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png" class="" title="alt JVM语言无关性"></li></ul></li></ul><h2 id="6-3-Class-类文件的结构"><a href="#6-3-Class-类文件的结构" class="headerlink" title="6.3 Class 类文件的结构"></a>6.3 Class 类文件的结构</h2><ul><li>Class文件是一组以8个字节为基础单位的二进制流</li><li>采用一种伪结构来存储数据，包括两种数据类型：<ul><li><code>无符号数</code>：基本数据类型，以u1&#x2F;u2&#x2F;u4&#x2F;u8分别代表1&#x2F;2&#x2F;4&#x2F;8个字节。用来描述数字、索引引用、数量值、UTF-8编码的字符串值</li><li><code>表</code>：多个无符号数或其它表 作为数据项构成的复合数据结构，以_info结尾用来描述有层次关系的复合数据结构</li></ul></li></ul><h3 id="6-3-1-魔数与Class文件版本"><a href="#6-3-1-魔数与Class文件版本" class="headerlink" title="6.3.1 魔数与Class文件版本"></a>6.3.1 魔数与Class文件版本</h3><ul><li>每个Class文件的头4个字节称魔数<code>Magic Number</code><ul><li>固定为<code>0xCAFEBABE</code> (咖啡宝贝)</li><li>作用是确定这个文件是否为一个能被虚拟机接受的Class</li></ul></li></ul><ul><li>第5、6两个字节是次版本号 <code>Minor Version</code><ul><li>若Class使用了实验性功能，则固定为65535，否则全0</li></ul></li></ul><ul><li>第7、8两个字节是主版本号 <code>Major Version</code><ul><li>版本号从45开始，例如JDK17的主版本就是45+17-1&#x3D;61</li><li>高版本JDK仅向下兼容</li><li>JVM必须拒绝执行超过其版本号的Class文件，即使Class格式未发生变化</li></ul></li></ul><h3 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h3><ul><li>位于次、主版本号之后</li><li>相当于Class文件的资源仓库，是Class结构中与其它项目关联最多的数据，占比也最大</li><li>首先入口处需放置一个u2类型的常量池容量计数器 (容量从1开始，即<code>常量数=counter-1</code>)</li><li>主要存放两大类常量，每一项都是一个表，共17种类型：<ul><li>字面量：如文本字符串、final等</li><li>符号引用：<ul><li>被模块导出或者开放的包</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul></li></ul></li><li>可用<code>javap -verbose</code>输出字节码内容</li></ul><h3 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h3><ul><li>常量池之后的两个字节</li><li>用于识别一些类或者接口层次的访问信息</li><li>一共16个标志位可以使用，Java定义了其中9个，未定义的一律为0<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" class="" title="alt 访问标志"></li></ul><h3 id="6-3-4-类索引、父索引与接口索引集合"><a href="#6-3-4-类索引、父索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父索引与接口索引集合"></a>6.3.4 类索引、父索引与接口索引集合</h3><ul><li><p>类索引：u2，用于确定类的全限定名</p></li><li><p>父索引：u2，用于确定这个类的父类的全限定名</p><ul><li>类索引、父索引各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过其中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型常量中的全限定名字符串。搜索关系如下图<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B.png" class="" title="alt 类索引定位过程"></li></ul></li><li><p>接口索引集合：u2类型数据集合，描述该类实现了哪些接口</p><ul><li>接口索引的入口是u2类型的计数器，表示索引表的容量</li></ul><p>这三项数据确定类的继承关系，按顺序排列在访问标志之后</p></li></ul><h3 id="6-3-5-字段表-field-info-集合"><a href="#6-3-5-字段表-field-info-集合" class="headerlink" title="6.3.5 字段表 field_info 集合"></a>6.3.5 字段表 field_info 集合</h3><ul><li>用于描述接口或类中声明的变量，包括类级变量和实例级变量</li><li>结构如下<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="alt 字段表结构"><ul><li><code>access_flags</code> 访问标志位，如是否public&#x2F;private&#x2F;protected&#x2F;static&#x2F;final&#x2F;volatile&#x2F;transient等</li><li><code>name_index</code> 字段的简单名称</li><li><code>descriptor_index</code> 方法描述符</li><li><code>attribute_info</code> 附加的额外信息</li></ul></li></ul><ul><li>类的全限定名：org&#x2F;chanper&#x2F;TestClass</li><li>简单名称：没有类型和参数修饰的方法或字段名称</li><li>描述符：描述字段的数据类型，方法参数列表和返回值。    <ul><li>标识字符含义：</li><li>描述方法时，按照先参数列表，后返回值的顺序描述。参数列表放置于()中。如方法<code>java.lang.String toString()</code>的描述符为：<code>()Ljava/lang/String</code></li></ul></li></ul><h3 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h3><ul><li>结构类似字段表，依次包括<code>access_flags</code>，<code>name_index</code>，<code>descriptor_index</code>，<code>attribute_info</code>。仅标志位略不同</li><li>方法里的代码存放在方法属性表集合中的名为<code>Code</code>的属性中</li><li>Class文件中的方法特征签名范围更大，包括返回值和受查异常表</li></ul><h3 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h3><ul><li>Class文件、字段表、方法表都可以携带自己的属性表集合，且顺序不严格，可以写入自定义属性</li><li>每个属性都要从常量池中引用一个Constant_Utf8_info类型的常量来表示，包括<code>u2 attribute_name_index</code>, <code>u4 attribute_length</code>, <code>u1 info</code>三个字段。</li><li>属性值结构自定义，通过<code>attribute_length</code>指明长度</li></ul><h4 id="1-Code-属性"><a href="#1-Code-属性" class="headerlink" title="1. Code 属性"></a>1. Code 属性</h4><ul><li>方法体里面的代码经编译后存储在Code内。是Class文件最重要的属性</li><li><code>attribute_name_index</code>, <code>attribute_length</code></li><li><code>max_stack</code>: 操作数栈最大深度</li><li><code>max_locals</code>: 局部变量表所需存储空间(单位<code>Slot</code>)。<code>Slot</code>根据局部变量的作用域可复用，所以此大小是同时生存的最大局部变量空间</li><li><code>code</code>: (Code.code)字节码指令，约200种。大小u1，因此最多256种指令。</li><li><code>exception_table</code>: 异常表</li></ul><h4 id="2-Exceptions-属性"><a href="#2-Exceptions-属性" class="headerlink" title="2. Exceptions 属性"></a>2. Exceptions 属性</h4><ul><li>列举方法中可能抛出的受查异常(throws关键字)</li><li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>number_of_exceptions</code></li><li><code>exception_index_table</code>: 受查异常类型，指向常量池中的<code>CONSTANT_Class_info</code></li></ul><h4 id="3-LineNumberTable-属性"><a href="#3-LineNumberTable-属性" class="headerlink" title="3. LineNumberTable 属性"></a>3. LineNumberTable 属性</h4><ul><li>描述Java源码行号与字节码偏移量的对应关系</li><li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>line_number_table_length</code></li><li><code>line_number_table</code></li></ul><h4 id="4-LocalVariableTable-与-LocalVariableTypeTable"><a href="#4-LocalVariableTable-与-LocalVariableTypeTable" class="headerlink" title="4. LocalVariableTable 与 LocalVariableTypeTable"></a>4. LocalVariableTable 与 LocalVariableTypeTable</h4><ul><li><code>LocalVariableTable</code>描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</li><li><code>LocalVariableTypeTable</code>使用字段的特征签名来完成泛型的描述</li></ul><h4 id="5-SourceFile-与-SourceDebugExtension"><a href="#5-SourceFile-与-SourceDebugExtension" class="headerlink" title="5. SourceFile 与 SourceDebugExtension"></a>5. SourceFile 与 SourceDebugExtension</h4><ul><li><code>SourceFile</code>记录生成Class文件的源码文件名称</li><li><code>SourceDebugExtension</code>存储额外的代码调试信息</li></ul><h4 id="6-ConstantValue-属性"><a href="#6-ConstantValue-属性" class="headerlink" title="6. ConstantValue 属性"></a>6. ConstantValue 属性</h4><ul><li><code>ConstantValue</code>通知虚拟机自动为静态变量赋值</li><li>实例变量在实例构造器<code>&lt;init&gt;()</code>方法中完成赋值</li><li>类变量如果是<code>static final</code>的<code>基本类型或String</code>，就用<code>ConstantValue</code>初始化，否则在类构造器<code>&lt;clinit&gt;()</code>方法中初始化</li></ul><h4 id="7-InnerClasses-属性"><a href="#7-InnerClasses-属性" class="headerlink" title="7. InnerClasses 属性"></a>7. InnerClasses 属性</h4><ul><li>记录内部类和宿主类之间的关联</li><li><code>inner_classes</code>, <code>inner_class_info_index</code>, <code>outer_class_info_index</code>, <code>inner_class_flags</code></li></ul><h4 id="8-Deprecated-与-Synthetic"><a href="#8-Deprecated-与-Synthetic" class="headerlink" title="8. Deprecated 与 Synthetic"></a>8. Deprecated 与 Synthetic</h4><ul><li>都是标志类型的布尔属性，没有属性值</li><li><code>Deprecated</code>标识某个类、方法、字段不再推荐使用</li><li><code>Synthetic</code>标识此字段、方法由编译器自动产生，非源码直接产生</li></ul><h4 id="9-StackMapTable-属性"><a href="#9-StackMapTable-属性" class="headerlink" title="9. StackMapTable 属性"></a>9. StackMapTable 属性</h4><ul><li>在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，代替以前消耗性能的基于数据流分析的类型推导验证器</li><li><code>stack_map_frame_entries</code></li></ul><h4 id="10-Signature-属性"><a href="#10-Signature-属性" class="headerlink" title="10. Signature 属性"></a>10. Signature 属性</h4><ul><li>记录泛型签名信息</li><li>Java的泛型实现是伪泛型，实现简单，容易Backport，内存开销较小</li><li>但运行期反射无法获取泛型类型</li></ul><h4 id="11-BootstrapMethods-属性"><a href="#11-BootstrapMethods-属性" class="headerlink" title="11. BootstrapMethods 属性"></a>11. BootstrapMethods 属性</h4><ul><li>用于保存<code>invokeDynamic</code>指令引用的引导方法限定符</li><li><code>bootstrap_methods</code></li></ul><h4 id="12-MethodParameters-属性"><a href="#12-MethodParameters-属性" class="headerlink" title="12. MethodParameters 属性"></a>12. MethodParameters 属性</h4><ul><li>记录方法的各个形参名称和信息</li><li><code>parameters</code></li></ul><h4 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13. 模块化相关属性"></a>13. 模块化相关属性</h4><ul><li><code>Module</code>存储模块名称、版本、标志信息、模块requires、exports、opens、uses、provides等</li><li><code>ModulePackages</code>描述该模块中所有的包</li><li><code>ModuleMainClass</code>确定该模块的主类</li></ul><h4 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14. 运行时注解相关属性"></a>14. 运行时注解相关属性</h4><ul><li><code>RuntimeVisibleAnnotations</code>, <code>RuntimeInvisibleAnnotations</code></li><li><code>RuntimeVisibleParameterAnnotations</code>, <code>RuntimeInvisibleParameterAnnotations</code></li><li><code>RuntimeVisibleTypeAnnotations</code>, <code>RuntimeInvisibleTypeAnnotations</code></li></ul><h2 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h2><ul><li>JVM的指令由一个字节长度的操作码<code>Opcode</code>,和零至多个操作数<code>Operand</code>构成</li><li>面向操作数栈</li></ul><h3 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1 字节码与数据类型"></a>6.4.1 字节码与数据类型</h3><ul><li>大多数指令都包含其操作对应的数据类型信息</li><li>对于<code>boolean，byte，short，char</code>类型的操作，实际上都是使用相应的<code>int</code>类型作为运算类型来进行的<ul><li>编译期或运行期会将<code>byte和short</code>类型的数据带符号扩展为相应的<code>int</code>类型数据</li><li>编译期或运行期会将<code>boolean和char</code>类型数据零位扩展为相应的<code>int</code>类型数据</li></ul></li></ul><h3 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2 加载和存储指令"></a>6.4.2 加载和存储指令</h3><ul><li>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</li><li>如<code>iload，lload，fload，istore，fstore，bipush，sipush...</code></li></ul><h3 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3 运算指令"></a>6.4.3 运算指令</h3><ul><li>对两个操作数栈上的值进行某种特定运算，并将结果重新存入到操作栈顶</li><li>分为对整型数据、浮点型数据运算的指令</li><li>如<code>iadd，isub，imul，idiv...</code></li><li>JVM的向零舍入模式：截断数字</li><li>向最接近数舍入模式：优先选择最低有效位为0的</li></ul><h3 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4 类型转换指令"></a>6.4.4 类型转换指令</h3><ul><li>将两种不同的数值类型相互转换</li><li>JVM直接支持以下类型的宽化类型转换：<ul><li><code>int -&gt; long, float, double</code></li><li><code>long -&gt; float, double</code></li><li><code>float -&gt; double</code></li></ul></li><li>窄化类型转换，必须使用显示转换指令。可能发生上限溢出，下限溢出，精度丢失</li></ul><h3 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5 对象创建与访问指令"></a>6.4.5 对象创建与访问指令</h3><ul><li>创建类：<code>new</code></li><li>创建数组：<code>newarray，anewarray，multianewarray</code></li><li>JVM对类实例和数组的创建与操作使用了不同的字节码指令</li></ul><h3 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6 操作数栈管理指令"></a>6.4.6 操作数栈管理指令</h3><ul><li>出栈：<code>pop</code></li><li>复制栈顶元素：<code>dup</code></li><li>栈顶两个元素互换：<code>swap</code></li></ul><h3 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7 控制转移指令"></a>6.4.7 控制转移指令</h3><ul><li>让JVM有条件或无条件得从指定位置得一下条指令继续执行程序(修改PC值)</li><li>分条件分支、复合条件分支、无条件分支等</li><li>各种类型的比较最终都会转换为int类型的比较操作</li></ul><h3 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8 方法调用和返回指令"></a>6.4.8 方法调用和返回指令</h3><ul><li><code>invokevirtual</code>：调用对象的方法实例</li><li><code>invokeinterface</code>：调用接口方法</li><li><code>invokespecial</code>：调用一些需要特殊处理的实例方法</li><li><code>invokestatic</code>：调用类静态方法</li><li><code>invokedynamic</code>：用于在运行时动态解析出调用点限定符所引用的方法</li></ul><h3 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9 异常处理指令"></a>6.4.9 异常处理指令</h3><ul><li>显式抛出异常：<code>athrow</code></li><li>处理异常(catch)采用异常表完成，而不是字节码指令</li></ul><h3 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10 同步指令"></a>6.4.10 同步指令</h3><ul><li>JVM支持方法级的同步和方法内部一段指令序列的同步，使用管程Monitor来实现</li><li>ACC_SYNCHRONIZED访问标志标记一个方法是否声明为同步方法</li><li>monitorenter和monitorexit两条指令支持synchronized关键字的语义</li></ul><h2 id="6-5-共有设计，私有实现"><a href="#6-5-共有设计，私有实现" class="headerlink" title="6.5 共有设计，私有实现"></a>6.5 共有设计，私有实现</h2><ul><li>JVM实现方式：<ul><li>将输入的JVM代码在加载或执行时翻译成另一种虚拟机的指令集</li><li>将输入的JVM代码在加载或执行时翻译成宿主机处理程序的本地指令集(即时编译)</li></ul></li></ul><h2 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6 Class文件结构的发展"></a>6.6 Class文件结构的发展</h2><ul><li>Class文件格式具备的平台中立、紧凑、稳定和可扩展的特点是Java技术体系实现平台无关、语言无关两项特性的重要支柱</li></ul><h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 - 虚拟机类加载机制"></a>第七章 - 虚拟机类加载机制</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ul><li>类加载机制：JVM把描述类的数据从Class文件加载到内存，并对数据继续校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</li><li>Java中，类型的加载、连接和初始化过程都是在程序运行期完成的</li></ul><h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><ul><li>类加载到卸载的七个阶段，其中验证、准备、解析三个部分统称连接<ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul></li><li>这些阶段通常都是互相交叉混合进行的，一个阶段的执行过程中调用、激活另一个阶段</li><li>JVM有且只有以下六种情况必须对类进行初始化(主动引用)<ul><li>遇到new, getstatic, putstatic, invokestatic这四条字节码指令时。例如new关键字实例化对象，读取或设置一个类的静态字段，调用类型的静态方法时</li><li>java.lang.reflect对类型进行反射调用的时候</li><li>初始化类时发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>JVM启动时，包含main()方法的类需要先初始化</li><li>动态语言支持，方法句柄对应的类尚未进行初始化时</li><li>接口中有default关键字修饰的接口方法，在其实现类初始化时需要先初始化该接口</li></ul></li><li>其它引用类型的方式称为被动引用，都不会触发初始化。如：<ul><li>子类引用父类定义的静态字段，只会初始化父类，而不会初始化子类</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="alt 类的生命周期"><h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h2><h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><ul><li>完成三件事：<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li>获取类的二进制字节流不限于Class文件，还可以是压缩包如jar，网络如applet，动态生成，数据库等等</li><li>数据类本身不通过类加载器创建，它是由JVM直接在内存中动态构造出来的</li></ul><h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><ul><li>目的是确保Class文件的字节流包含的信息符合全部约束要求，保证代码运行不会JVM自身的安全</li><li>分四个阶段：<ul><li>文件格式验证：保证输入的字节流能正确解析并存储于方法区之内</li><li>元数据验证：对字节码描述信息进行语义分析</li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义合法，符合逻辑。(停机问题：不完全保证合法)</li><li>符号引用验证：对类自身以外的各类信息进行匹配性校验</li></ul></li></ul><h3 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h3><ul><li>正式为类中定义的变量(静态变量)分配内存并设置类变量初始值的阶段</li><li>通常情况下初始值是数据类型的零值，除非类字段存在ConstantValue属性</li></ul><h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><ul><li>将常量池内的符号引用替换为直接引用的过程</li><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标</li><li>直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li><li>分为：<ul><li>类或接口的解析</li><li>字段解析</li><li>方法解析</li><li>接口方法解析</li></ul></li></ul><h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><ul><li>类加载的最后一个阶段，根据程序编码初始化类变量和其它资源(执行类构造器<code>&lt;clinit&gt;()</code>)</li><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<code>类变量的赋值动作</code>和<code>静态语句块</code>合并产生的，顺序由源文件中定义顺序决定</li><li>JVM中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型一定是<code>java.lang.Object</code></li><li>接口(实现类)的<code>&lt;clinit&gt;()</code>不需要先执行(父)接口的<code>&lt;clinit&gt;()</code></li><li>同一个类加载器下，一个类型只会被初始化一次</li></ul><h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><ul><li>实现<code>&quot;通过类全限定名来获取描述该类的二进制字节流&quot;</code>这个动作的代码称为<code>类加载器Class Loader</code></li><li>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在JVM中的唯一性</li></ul><h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><ul><li>从JVM角度，只有两种不同的类加载器：<ul><li>启动类加载器Boostrap ClassLoader，C++实现，JVM自身的一部分</li><li>其它类加载器，Java实现，独立于JVM，且全部继承自抽象类<code>java.lang.ClassLoader</code></li></ul></li><li>开发者角度，分三种类加载器<ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li></ul></li><li>各种类加载器之间的层次关系称类加载器的<strong>双亲委派模型</strong>。<ul><li>要求除了顶层的启动类加载器外，其它的类加载器必须有自己的父类加载器(一般通过组合关系实现复用)</li><li>类加载器工作时收到类加载的请求，首先交给父类加载器去完成，父类无法完成时才自己去加载<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class="" title="alt 类加载器的双亲委派模型"></li></ul></li></ul><h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><ul><li>三次破坏</li><li>OSGi实现模块化部署的关键是它自定义的类加载器机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。类加载器不再是双亲委派模型，而是更加复杂的网状结构</li></ul><h2 id="7-5-Java模块化系统"><a href="#7-5-Java模块化系统" class="headerlink" title="7.5 Java模块化系统"></a>7.5 Java模块化系统</h2><ul><li>模块化的关键目标：可配置的封装隔离机制</li><li>JDK 9之后的类加载委派关系：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%A7%94%E6%B4%BE%E5%85%B3%E7%B3%BB.png" class="" title="alt JDK9之后的类加载委派关系"></li></ul><h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 - 虚拟机字节码执行引擎"></a>第八章 - 虚拟机字节码执行引擎</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ul><li>执行引擎是虚拟机核心的组成部分之一</li><li>物理机的执行引擎直接建立在处理器、缓存、指令集和OS层面上，而JVM执行引擎有软件自行实现，不受物理条件制约，能够执行不被硬件直接支持的指令集格式</li><li>分解释执行、编译执行两种方式</li><li>执行引擎的输入是字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果</li></ul><h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><ul><li>JVM以方法作为最基本的执行单元</li><li>栈帧是支持JVM进行方法调用和方法执行的数据结构，也是JVM运行时数据区中<strong>虚拟机栈</strong>的元素</li><li>每一个栈帧包括<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>方法返回地址</code>和一些额外的<code>附加信息</code></li><li>对于执行引擎而言，活动线程中栈顶的方法是运行的，称<strong>当前栈帧</strong>，关联方法称<strong>当前方法</strong>。执行引擎的所有字节码指令只针对当前栈帧操作</li></ul><h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><ul><li>一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</li><li>容量以变量槽<code>Slot</code>为最小单位<ul><li>除了<code>long double</code>需要2个Slot外，其余数据类型都需要1个Slot</li><li>Slot根据变量作用范围可复用</li></ul></li><li>JVM通过索引定位的方法使用局部变量表，范围从0开始至局部变量表最大的变量槽数量</li><li>JVM实现通过引用应完成两件事：<ul><li>根据引用直接或间接找到对象在Java堆种数据存放的起始地址或索引</li><li>根据引用直接或间接找到对象所属数据类型在方法区中存储的类型信息</li></ul></li><li>类字段有两次赋初始值的过程，一次是准备阶段赋系统初始值，另一次是初始化阶段赋程序定义初始值。但局部变量没有初始化就不能使用</li></ul><h3 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h3><ul><li>Operand Stack 后入先出栈</li><li>32位数据栈容量为1，64位栈容量为2</li><li>优化处理：两个不同的栈帧会出现一部分重叠，节约空间，且可以共享一部分数据</li></ul><h3 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h3><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，以便支持调用过程中的动态连接</li></ul><h3 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h3><ul><li>两种退出方法执行的方式：<ul><li>正常调用完成，正常向主调函数提供返回值</li><li>异常调用完成，不会提供任何返回值</li></ul></li></ul><h3 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h3><ul><li>JVM规范没有描述的信息，如调试、性能收集相关信息</li><li>一般把动态连接、方法返回地址以及其它附加信息全部归为栈帧信息</li></ul><h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><ul><li>方法调用阶段唯一的任务是确定被调用方法的版本</li><li>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址</li></ul><h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><ul><li>如果一个方法符合<strong>编译器可知，运行期不可变</strong>，那么JVM在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这类方法的调用称为<code>解析</code></li><li>符合条件的方法包括静态方法、私有方法、实例构造器、父类方法，以及final修饰的方法。这五类方法统称<code>非虚方法</code>。其它方法称为<code>虚方法</code>。</li><li>前四类通过<code>invokestatic, invokespecial</code>指令调用，final方法通过<code>invokevirtual</code>调用(历史原因)</li><li>因此，解析调用是一个静态过程，编译器完全确定</li></ul><h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><p>解析与分派并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticDispatch</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Human guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Human!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Man guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Man!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Woman woman)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Woman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br><br>        <span class="hljs-type">StaticDispatch</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDispatch</span>();<br>        sd.sayHello(man);   <span class="hljs-comment">// 输出：Hello, Human!</span><br>        sd.sayHello(woman); <span class="hljs-comment">// 输出：Hello, Human!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Human称为变量的静态类型(外观类型)，编译期可知</li><li>Man&#x2F;Woman称为变量的实际类型(运行时类型)，运行期确定</li></ul><ul><li>JVM(编译器)在<code>重载</code>时通过参数的静态类型作为判断依据，而非实际类型</li><li>所有依赖静态类型决定方法执行版本的分派动作，都称为静态分派</li><li>发生在编译阶段</li><li>典型应用：方法重载</li></ul><p>一个更加极端恶心的例子，查看调用哪个sayHello，并注释对应方法再次执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Overload</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">long</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Character arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Character&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span>... arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Serializable arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Serializable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        sayHello(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发现重载的顺序是：char -&gt; int -&gt; long -&gt; Character -&gt; Serializable -&gt; Object -&gt; char…</li><li>重载的优先级：<ul><li>优先进行宽化转型</li><li>接着是自动装箱。char可以转型成int，但Character不可能转型成Integer</li><li>接着是实现的接口 -&gt; 父类(根据继承关系从下往上搜索)</li><li>最后是边长参数</li></ul></li></ul><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDispatch</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Man say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Woman say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Man say hello</span><br>        woman.sayHello();   <span class="hljs-comment">// Woman say hello</span><br><br>        man = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Woman say hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>确定调用方法的关键在于<code>invokevirtual</code>指令的步骤<ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，查找过程结束。不通过则返回<code>java.lang.IllegalAccessError</code></li><li>否则，按照继承关系自下而上依次对C的各个父类进行第二步的搜索和验证过程</li><li>如果始终没有找到合适的方法，抛出<code>java.lang.AbstractMethodError</code></li></ol></li><li><code>invokevirtual</code>的第一步就在运行期确定了接收者的实际类型，这就是Java方法重写的本质</li><li>这种在<strong>运行期</strong>根据实际类型确定方法执行版本的分派过程称为动态分配</li><li>典型应用：方法重写</li></ul><p>另外，只存在虚方法，不存在虚字段，即字段永远不参与多态。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldHasNoPolymorphic</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">2</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">guy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br><br>        <span class="hljs-comment">// 输出：</span><br>        <span class="hljs-comment">// I am Son, i have $0</span><br>        <span class="hljs-comment">// I am Son, i have $4</span><br>        <span class="hljs-comment">// This guy has $2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Son的构造器首先隐式调用Father构造器。但Father构造器中的showMeTheMoney()是虚方法调用，实际执行的是Son::showMeTheMoney(),且访问的是Son::money(尚未初始化&#x3D;0)</li><li>然后执行自身的构造器</li></ul><h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>单分派：根据一个宗量对目标方法进行选择</li><li>多分派：根据多于一个宗量对目标方法进行选择</li><li>Java语言是一门静态多分派，动态单分派的语言</li></ul><h4 id="JVM动态分派的实现"><a href="#JVM动态分派的实现" class="headerlink" title="JVM动态分派的实现"></a>JVM动态分派的实现</h4><ul><li>基于执行性能的考虑，JVM通常为类型在方法区建立虚方法表vtable，用虚方法表索引代替元数据以提高性能</li><li>虚方法表存放着各个方法的实际入口地址。<ul><li>如果某个方法在子类中没有重写，那子类的虚方法地址入口和父类一致。</li><li>如果子类重写了该方法，则地址入口被替换成子类实现版本的入口地址<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="alt 方法表结构"></li></ul></li></ul><h2 id="8-4-动态类型语言支持"><a href="#8-4-动态类型语言支持" class="headerlink" title="8.4 动态类型语言支持"></a>8.4 动态类型语言支持</h2><p><strong>JVM 自诞生以来的二十年间，唯一新增的指令 —— <code>invokedynamic</code></strong></p><h3 id="8-4-1-动态类型语言"><a href="#8-4-1-动态类型语言" class="headerlink" title="8.4.1 动态类型语言"></a>8.4.1 动态类型语言</h3><ul><li>关键特征：<ul><li>类型检查的主体过程是在运行期，而非编译期</li><li>变量无类型，而变量值才有类型</li><li>相比于静态类型语言的编译器可以提供全面严谨的类型检查，动态类型语言更加灵活，清晰简洁</li></ul></li></ul><ul><li>运行时异常：只要代码不执行到这一行就不会出现问题</li><li>连接时异常：即使代码放到不会被执行到的路径分支上，类加载时也会抛出异常</li></ul><h3 id="8-4-2-Java与动态类型"><a href="#8-4-2-Java与动态类型" class="headerlink" title="8.4.2 Java与动态类型"></a>8.4.2 Java与动态类型</h3><ul><li>JDK 7以前的4条方法调用指令的实现方式，导致JVM上的动态类型语言实现复杂，同时带来额外的性能和内存开销</li></ul><h3 id="8-4-3-java-lang-invoke包"><a href="#8-4-3-java-lang-invoke包" class="headerlink" title="8.4.3 java.lang.invoke包"></a>8.4.3 java.lang.invoke包</h3><ul><li>主要目的是在之前单纯依赖符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制。称为<code>方法句柄 Method Handle</code></li><li>反射也能实现方法句柄的功能，但存在一些区别：<ul><li>Reflection在模拟Java代码层次的方法调用，而MethodHandle模拟字节码层次</li><li>Reflection中的Method对象(Java端的全面映像)远比MethodHandle中的对象包含的信息更多。也即Reflection重量级，MethodHandle轻量级。</li><li>MethodHandle由于在字节码层次，可以实施各类调用点优化措施</li></ul></li></ul><h3 id="8-4-4-invokedynamic-指令"><a href="#8-4-4-invokedynamic-指令" class="headerlink" title="8.4.4 invokedynamic 指令"></a>8.4.4 invokedynamic 指令</h3><ul><li>和MethodHandle机制作用一样，解决原有4条invoke指令分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，提供更高的自由度</li><li>每一处含有invokedynamic指令的位置称作动态调用点</li></ul><h2 id="8-5-基于栈的字节码解释执行引擎"><a href="#8-5-基于栈的字节码解释执行引擎" class="headerlink" title="8.5 基于栈的字节码解释执行引擎"></a>8.5 基于栈的字节码解释执行引擎</h2><h3 id="8-5-1-解释执行"><a href="#8-5-1-解释执行" class="headerlink" title="8.5.1 解释执行"></a>8.5.1 解释执行</h3><ul><li>基于物理机、JVM、或其他非Java的高级语言虚拟机的代码执行过程，大体上遵循现代经典编译原理的思路：在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树 AST(Abstract Syntax Tree)</li><li>词法、语法分析以及优化器、目标代码生成可以独立于执行引擎，形成完整意义的编译器，如C&#x2F;C++</li><li>也把其中一部分实现为一个半独立的编译器，如Java</li><li>又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子，如JavaScript执行引擎</li></ul><h3 id="8-5-2-基于栈的指令集和基于寄存器的指令集"><a href="#8-5-2-基于栈的指令集和基于寄存器的指令集" class="headerlink" title="8.5.2 基于栈的指令集和基于寄存器的指令集"></a>8.5.2 基于栈的指令集和基于寄存器的指令集</h3><ul><li>基于栈：<ul><li>指令通常不带参数(零地址指令)，使用操作数栈中的数据作为指令的运算输入，运算结果也存储在操作栈中</li><li>优点：可移植，代码相对紧凑，编译器实现更加简单</li><li>缺点：理论执行速度相对稍慢，完成相同功能所需指令数量更多</li></ul></li><li>基于寄存器：<ul><li>指令直接对寄存器进行操作，包含地址和操作数</li></ul></li></ul><h1 id="第九章-类加载及执行子系统的案例和实战"><a href="#第九章-类加载及执行子系统的案例和实战" class="headerlink" title="第九章 - 类加载及执行子系统的案例和实战"></a>第九章 - 类加载及执行子系统的案例和实战</h1><h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><h3 id="9-2-1-Tomcat：正统的类加载器架构"><a href="#9-2-1-Tomcat：正统的类加载器架构" class="headerlink" title="9.2.1 Tomcat：正统的类加载器架构"></a>9.2.1 Tomcat：正统的类加载器架构</h3><ul><li>一个功能健全的Web服务器需要解决以下问题：<ul><li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li><li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以相互共享</li><li>服务器应尽可能保证自身的安全不受部署的程序的影响</li><li>支持HotSwap热替换功能</li></ul></li><li>Tomcat的类加载器<ul><li><code>Common</code>类加载器：加载<code>/commons/*</code>，可被Tomcat和所有Web程序共同使用</li><li><code>Catalina</code>类加载器(Server类加载器)：加载<code>/server/*</code>，可被Tomcat使用，对Web程序不可见</li><li><code>Shared</code>类加载器: 加载<code>/shared/*</code>，被所有Web程序共同使用，对Tomcat本身不可见</li><li><code>Webapp</code>类加载器：加载<code>/WebApp/WEB-INF/*</code>，仅被该Web程序使用</li></ul></li><li>每一个Web应用程序对应一个WebApp类加载器，可以存在多个实例</li><li>每一个JSP文件对应一个JasperLoader类加载器 (HotSpot，JSP文件修改后重新创建新的JSP类加载)<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9E%B6%E6%9E%84.png" class="" title="alt Tomcat类加载器架构"></li></ul><h3 id="9-2-2-OSGi-灵活的类加载器架构"><a href="#9-2-2-OSGi-灵活的类加载器架构" class="headerlink" title="9.2.2 OSGi: 灵活的类加载器架构"></a>9.2.2 OSGi: 灵活的类加载器架构</h3><ul><li>OSGi (Open Service Gateway Initiative) 是OSGi联盟制定的基于Java语言的动态模块化规范</li><li>OSGi的每个模块Bundle的类加载器之间只有规则，没有固定的委派关系</li><li>从双亲委派模型的树形结构进一步发展成更加复杂的、运行时才能确定的网状结构</li></ul><h3 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h3><ul><li>字节码生成技术：javac、字节码类库、JSP编译器、AOP框架、动态代理(如Spring对Bean的增强)、反射等等</li><li>相对于实际用Java代码编写了代理类的<strong>静态代理</strong>，<strong>动态代理</strong>的优势不止是省去编码工作量，更是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为。当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</li></ul><h3 id="9-2-4-Backport工具：Java的时光机器"><a href="#9-2-4-Backport工具：Java的时光机器" class="headerlink" title="9.2.4 Backport工具：Java的时光机器"></a>9.2.4 Backport工具：Java的时光机器</h3><ul><li><code>Java Backporting Tools</code> Java逆向移植工具,把高版本JDK代码部署到低版本JDK环境中。实现工具如 Retrotranslator, Retrolambda</li><li>JDK每次升级的改进大致分以下五类：<ul><li>Java类库API的增强。如JDK 5引入的java.util.concurrent并发包</li><li>前端编译器层面的改进，称作语法糖。如自动装箱拆箱、变长参数、泛型等</li><li>需要在字节码中进行支持的改动。如动态语言支持需要新增invokedynamic指令</li><li>需要在JDK整体结构层面进行支持的改进。如Java模块化系统</li><li>集中在虚拟机内部的改进。如JDK 5重新定义的Java内存模型；G1、ZGC、Shenandoah收集器等</li></ul></li></ul><h2 id="9-3-实战-动手实现远程执行功能"><a href="#9-3-实战-动手实现远程执行功能" class="headerlink" title="9.3 实战 - 动手实现远程执行功能"></a>9.3 实战 - 动手实现远程执行功能</h2><p>使用前面学到的关于类加载及虚拟机执行子系统的知识去完成在服务端执行临时代码的功能。</p><h1 id="第十章-前边编译与优化"><a href="#第十章-前边编译与优化" class="headerlink" title="第十章 - 前边编译与优化"></a>第十章 - 前边编译与优化</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul><li>编译期可分为：<ul><li>前端编译器： *.java -&gt; *.class</li><li>JVM的即时编译器 JIT： 运行期字节码 -&gt; 本地机器码</li><li>静态提前编译器 AOT：  程序 -&gt; 二进制代码</li></ul></li><li>JVM对性能的全部优化集中在运行期的JIT中，让非javac产生的Class文件(如 JRuby、Groovy)也能享受编译器的优化措施</li><li>Java中的即时编译器在运行期的优化措施，支撑了程序执行效率的不断提升；前端编译器在编译期的优化过程，则是支撑了程序员的编码效率和语言使用者幸福感的提升。</li></ul><h2 id="10-2-Javac编译器"><a href="#10-2-Javac编译器" class="headerlink" title="10.2 Javac编译器"></a>10.2 Javac编译器</h2><pre><code class="hljs">Javac本身是由Java语言编写的程序</code></pre><h3 id="10-2-1-Javac的源码与调试"><a href="#10-2-1-Javac的源码与调试" class="headerlink" title="10.2.1 Javac的源码与调试"></a>10.2.1 Javac的源码与调试</h3><p>编译过程大致分为1个准备过程+3个处理过程</p><ul><li>准备过程：初始化插入式注解处理器</li><li>解析与填充符号表过程，包括：<ul><li>词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树</li><li>填充符号表：产生符号地址和符号信息</li></ul></li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程，包括：<ul><li>标注检查：对语法的静态信息进行检查</li><li>数据流及控制流分析：对程序动态运行过程进行检查</li><li>解语法糖：将简化代码编写的语法糖还原为原有的形式</li><li>字节码生成：将前面各个步骤所生成的信息转化为字节码</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" class="" title="alt javac编译过程"><h3 id="10-2-2-解析与填充符号表"><a href="#10-2-2-解析与填充符号表" class="headerlink" title="10.2.2 解析与填充符号表"></a>10.2.2 解析与填充符号表</h3><p><strong>1. 词法、语法分析</strong></p><ul><li>词法分析：将源码中的字符流转变为标记Token的过程。程序编写的最小元素是单个字符，编译时的最小元素是标记。</li><li>语法分析：根据标记序列构造抽象语法树的过程。AST是一种用来描述程序代码语法结构的树形表示形式，其中每个节点都代表着程序代码中的一个语法结构，如包、类型、修饰符、运算符、接口等</li></ul><p><strong>2. 填充符号表</strong></p><ul><li>符号表是由一组符号地址和符号信息构成的数据结构 (类似键值对的存储形式)</li><li>符号表登记的信息在后续语义分析、目标代码生成阶段都要使用</li></ul><h3 id="10-2-3-注解处理器"><a href="#10-2-3-注解处理器" class="headerlink" title="10.2.3 注解处理器"></a>10.2.3 注解处理器</h3><ul><li>插入式注解器可以看作一组编译器的插件，插件工作时可以读取、修改、添加抽象语法树中的任意元素</li><li>处理注解期间，如果注解器对语法树进行过修改，编译器将重新解析、填充符号表。每次循环称为一个轮次Round</li><li>典型应用：Lombok工具</li></ul><h3 id="10-2-4-语义分析与字节码生成"><a href="#10-2-4-语义分析与字节码生成" class="headerlink" title="10.2.4 语义分析与字节码生成"></a>10.2.4 语义分析与字节码生成</h3><p><strong>1. 语义分析</strong></p><ul><li>AST能够表示一个结构正确的源程序，但无法保证语义符合逻辑，因此需要语义分析对结构上正确的源程序进行上下文相关性质的检查。</li><li>分以下两类：<ul><li>标注检查：检查包括变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等，另外还有<code>常量折叠</code>等少量代码优化</li><li>数据及控制流：检查诸如程序局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理了等问题。(某些语义只能在编译期，而不能在运行期检查)</li></ul></li></ul><p><strong>2. 语法糖 Syntactic Sugar</strong></p><ul><li>程序语言中添加的某种语法，这种语法对编译结果和功能并没有实际影响，但却能更方便程序员使用该语言。</li><li>解语法糖：编译阶段还原回基础语法结构</li><li>优点：减少代码量，增加程序可读性，减少代码出错的机会</li></ul><p><strong>3. 字节码生成</strong></p><ul><li>Javac编译过程的最后一个阶段，把前面各个步骤生成的信息(语法树、符号表)转化为字节码指令写入到磁盘中，还进行了少量代码添加和转换工作</li><li>完成对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交由<code>ClassWriter::writeClass()</code>方法输出字节码，生成最终的Class文件。至此编译过程宣告结束。</li></ul><h2 id="10-3-Java语法糖的味道"><a href="#10-3-Java语法糖的味道" class="headerlink" title="10.3 Java语法糖的味道"></a>10.3 Java语法糖的味道</h2><p>除了以下介绍的几种语法糖，还有内部类、枚举类、断言、数值字面量、对枚举和字符串的switch支持、try with、Lambda(非单纯的语法糖)等等</p><h3 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h3><ul><li>泛型的本质是参数化类型或者参数化多态</li><li>Java的泛型实现方式是”类型擦除式泛型” Type Erasure Generics，C#则是”具现化式泛型” Reified Generics</li><li>类型擦除的缺陷：<ul><li>无法支持原始数据类型</li><li>运行期无法取到泛型类型信息</li><li>丧失了面向对象思想应有的优雅，带来了一些模棱两可的状况</li></ul></li><li>未来 - Valhalla项目：<ul><li>新的泛型实现方案</li><li>值类型 Value Type：与引用类型一样具有构造函数、方法、字段等，区别在于赋值时通常是整体复制，而不是传递引用；可以分配在调用栈上，随方法退出而自动释放</li></ul></li></ul><h3 id="10-3-2-自动装箱、拆箱、遍历循环"><a href="#10-3-2-自动装箱、拆箱、遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱、遍历循环"></a>10.3.2 自动装箱、拆箱、遍历循环</h3><ul><li>自动装箱：Integer.valueOf()</li><li>自动拆箱：Integer.intValue()</li><li>遍历循环：Iterable::iterator()</li><li>变长参数：args[]</li></ul><h3 id="10-3-3-条件编译"><a href="#10-3-3-条件编译" class="headerlink" title="10.3.3 条件编译"></a>10.3.3 条件编译</h3><ul><li>Java的条件编译会根据布尔常量值的真假，消除分支中不成立的代码块</li><li>利用了if语句，因此只能实现语句基本块级别的条件编译</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>        System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        System.out.println(<span class="hljs-string">&quot;block 2&quot;</span>);<br>&#125;<br>----------------------------------<br><span class="hljs-comment">// 反编译后：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-4-实战：插入式注解处理器"><a href="#10-4-实战：插入式注解处理器" class="headerlink" title="10.4 实战：插入式注解处理器"></a>10.4 实战：插入式注解处理器</h2><ul><li>注解处理器需要继承<code>javax.annotation.processing.AbstractProcessor,</code>且实现<code>process()</code></li><li><code>@SupportedAnnotationTypes</code>代表注解处理器对哪些注解感兴趣</li><li><code>@SupportedSourceVersion</code>指出可以处理哪些版本的Java代码</li><li>每一个注解处理器在运行时都是单例的</li></ul><h1 id="第十一章-后端编译与优化"><a href="#第十一章-后端编译与优化" class="headerlink" title="第十一章 - 后端编译与优化"></a>第十一章 - 后端编译与优化</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><ul><li>编译器无论在何时、在何种状态下把Class文件转换成本地基础设施(硬件指令集、操作系统)相关的二进制机器码，都可以视为整个编译过程的后端</li><li>后端编译器性能的好坏、代码优化质量的高低是衡量一款商用虚拟机优秀与否的关键指标之一，也是商业JVM的核心，最能体现技术水平与价值</li></ul><h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>Java最初都是通过解释器进行解释执行的，当JVM发现某个方法或代码块运行频繁，就会把它们判定为热点代码，编译成本地机器码，并通过各种手段进行优化，提高热点代码执行效率。完成这一任务的后端编译器称即时编译器 JIT</p><h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><ul><li>主流商用JVM都同时包含解释器和编译器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92.png" class="" title="alt 解释器与编译器的交互"></li><li>解释器<ul><li>启动迅速，节约内存</li><li>可以作为编译器激进优化的后备逃生门</li></ul></li><li>编译器<ul><li>执行效率高</li><li>HotSpot中包括客户端编译器C1，服务端编译器C2，以及Graal编译器</li><li>工作模式：-Xint仅解释模式，-Xcomp优先编译，以及默认的混合模式<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F.png" class="" title="alt JVM执行模式"></li><li>分层编译：根据编译器编译、优化的规模与耗时，划分不同的编译层次，包括：<ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控模式</li><li>第1层：使用C1编译字节码，进行简单可靠的稳定优化，不开启性能监控</li><li>第2层：C1编译，仅开启方法及回边次数统计等有限的性能监控</li><li>第3层：C1编译，开启全部性能监控，收集更多统计信息</li><li>第4层：C2编译，启用更多耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li></ul></li><li>实施分层编译后，解释器、C1、C2同时工作，热点代码可能被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量</li></ul></li></ul><h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><ul><li>编译的对象——热点代码分两类：<ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul></li><li>编译的目标对象都是整个方法体，而非单独的循环体。对于循环体，编译时自动进行”栈上替换”</li><li>热点探测的两种方式：<ul><li>基于采样：<ul><li>周期性检查各个线程的调用栈顶，如果某些方法经常出现在栈顶，即是热点方法。</li><li>实现简单高效，容易获取对象调用关系</li><li>不精确，容易受线程阻塞或其它外界因素的影响</li></ul></li><li>基于计数器：<ul><li>为每个方法、代码块设置计数器，统计方法的执行次数，超过阈值即热点方法</li><li>精确严谨</li><li>实现复杂，需要为每个方法建立并维护计数器，且不能直接获取方法调用关系</li></ul></li></ul></li><li>HotSpot采用第二种计数器方式，为每个方法设置<code>方法调用计数器</code>和<code>回边计数器</code><ul><li><p>方法调用计数器：统计方法一段时间内执行的相对频率。</p><ul><li>超过时间限度会进行热度衰减，计数器减半</li><li>这段时间称半衰周期<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" class="" title="alt 方法调用计数器触发即时编译器"></li></ul></li><li><p>回边计数器：统计方法中循环体代码执行的次数</p><ul><li>统计的是绝对次数，没有热度衰减</li><li>回边计数器溢出时，会同步设置方法调用计数器为溢出状态<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" class="" title="alt 回边计数器触发即时编译器"></li></ul></li></ul></li></ul><h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><ul><li><p>默认条件下，无论时方法调用产生的标准编译请求，还是栈上替换编译请求，JVM在编译器未完成编译前，都仍将解释执行代码，编译动作在后台编译线程中进行</p></li><li><p>客户端编译器：简单快速的三段式编译器，主要是局部优化</p><ul><li>阶段1：一个平台独立的前端将字节码构造成一个高级中间代码表示HIR</li><li>阶段2：一个平台相关的后端从HIR中产生低级中间代码表示LIR</li><li>阶段3：在平台相关的后端使用线性扫描算法在LIR上分配寄存器，做窥孔优化，产生机器代码<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E8%AF%91%E6%9E%B6%E6%9E%84.png" class="" title="alt 客户端编译架构"></li></ul></li><li><p>服务端编译器：</p><ul><li>专门面向服务端的典型应用场景，针对性调整服务端的性能配置，能够容忍高优化复杂度</li><li>执行大部分经典的优化动作</li><li>根据解释器、C1提供的性能监控信息，进行一些不稳定的激进优化</li></ul></li></ul><h3 id="11-2-4-实战：查看及分析即时编译结果"><a href="#11-2-4-实战：查看及分析即时编译结果" class="headerlink" title="11.2.4 实战：查看及分析即时编译结果"></a>11.2.4 实战：查看及分析即时编译结果</h3><p>需要fastdebug&#x2F;slowdebug优化级别的HotSpot虚拟机……</p><h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><h3 id="11-3-1-提前编译的优劣得失"><a href="#11-3-1-提前编译的优劣得失" class="headerlink" title="11.3.1 提前编译的优劣得失"></a>11.3.1 提前编译的优劣得失</h3><ul><li>两条分支：<ul><li>与传统C、C++编译器类似，在程序运行之前把源码编译成机器码的静态翻译<ul><li>直击即时编译的最大弱点——占用程序运行时间和运算资源</li></ul></li><li>把原本即时编译器在运行时要做的编译工作提前做好保存，下次运行直接把它加载进来使用<ul><li>本质是做编译器缓存加速，改善Java程序启动时间，以及需要一段时间预热才能到达最高性能的问题，称为动态提前编译或即时编译缓存</li></ul></li></ul></li><li>然而，即时编译器相对于提前编译器有三条天然的优势：<ul><li>性能分析制导优化：实现一些只能在动态运行时才能显现的执行偏好</li><li>激进预测性优化：依赖性能监控信息可以做出不可靠的激进优化，由低级编译器和解释器负责保底</li><li>链接时优化：Java动态链接的本质使得代码优化没有边界隔阂</li></ul></li></ul><h3 id="11-3-2-实战：Jaotc的提前编译"><a href="#11-3-2-实战：Jaotc的提前编译" class="headerlink" title="11.3.2 实战：Jaotc的提前编译"></a>11.3.2 实战：Jaotc的提前编译</h3><p>Jaotc属于提前编译的第二条分支——编译器缓存加速，支持对Class文件和模块进行提前编译，以减少程序启动时间和到达全速性能的预热时间。但是必须针对特定物理机和目标虚拟机的运行参数。<br>JDK 17中移除了Jaotc</p><h2 id="11-4-编译优化技术"><a href="#11-4-编译优化技术" class="headerlink" title="11.4 编译优化技术"></a>11.4 编译优化技术</h2><h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p>分类：</p><ul><li>编译器策略</li><li>基于性能监控的优化技术</li><li>基于证据的优化技术</li><li>数据流敏感重写</li><li>语言相关的的优化技术</li><li>内存及代码位置变换</li><li>循环交换</li><li>全局代码调整</li><li>控制流图变换</li></ul><h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联:"></a>11.4.2 方法内联:</h3><ul><li>编译器最重要的优化手段，称为优化之母</li><li>目的：<ul><li>去除方法调用的成本</li><li><strong>为其它优化建立良好的基础</strong></li></ul></li><li>措施：把目标方法的代码原封不动复制到发起调用的方法之中</li><li>解决Java实例方法默认是虚方法的解决方案：<ul><li>类型继承关系分析CHA，确定方法类型</li><li>非虚方法 - 直接内联</li><li>虚方法 - 向CHA查询是否只有一个版本<ul><li>是 - 守护内联 (Java动态链接-&gt;激进优化，需预备好逃生门 -&gt; 解释执行&#x2F;重新编译)</li><li>否 - 内联缓存 (仍是方法调用，但快于查虚方法表。后续命中-&gt;单态内联缓存，未命中-&gt;超多态内联缓存)</li></ul></li></ul></li></ul><h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><ul><li>前沿优化技术。不是直接优化代码，而是为其它优化措施提供依据</li><li>基本原理：<ul><li>分析对象动态作用域，当一个对象在方法里面被定义后，它可能传递到外部方法中使用，称为方法逃逸；</li><li>还有可能被外部线程访问，称线程逃逸</li><li>对象由低到高的逃逸程度：从不逃逸-&gt;方法逃逸-&gt;线程逃逸</li></ul></li><li>措施：<ul><li>栈上分配：<ul><li>如果一定对象不会发生线程逃逸，那么可以让这个对象在栈上分配，所占空间随栈帧出栈而销毁，减小GC压力</li><li>支持方法逃逸，不支持线程逃逸</li></ul></li><li>标量替换：<ul><li>标量：无法再分解成更小数据的表示，如原始数值类型、reference类型等</li><li>聚合量：数据可以继续分解</li><li>把一个Java对象拆散，根据程序访问情况，将其用到的成员变量恢复为原始类型来访问，这个过程称标量替换</li><li>不允许对象逃逸出方法之外</li></ul></li><li>同步消除：<ul><li>对不发生线程逃逸的对象，读写不会有竞争，可以安全消除线程同步措施</li></ul></li></ul></li></ul><h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><ul><li>经典的、普遍应用于各种编译器的优化技术</li><li>措施：<ul><li>如果一个表达式E之前被计算过，且中间E的所有变量没有变化，可以直接用之前计算过的结果替代E</li><li>限于程序基本块内的，称局部公共子表达式消除</li><li>涵盖多个基本块的，称全局公共子表达式消除</li></ul></li></ul><h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><ul><li>即时编译器中一项语言相关的经典优化技术</li><li>措施：确定数组长度，访问时直接对下标进行越界判断</li></ul><h2 id="11-5-实战：深入理解Graal编译器"><a href="#11-5-实战：深入理解Graal编译器" class="headerlink" title="11.5 实战：深入理解Graal编译器"></a>11.5 实战：深入理解Graal编译器</h2><ul><li>Graal使用Java编写</li><li>利用JVM CI实现与HotSpot分离。JVM CI的功能：<ul><li>响应HotSpot的编译请求，并将请求分发给Java实现的即时编译器</li><li>允许编译器访问HotSpot中与即时编译相关的数据结构，并提供一组这些数据结构在Java语言层面的抽象表示</li><li>提供HotSpot代码缓存的Java端抽象表示，允许编译器部署编译完成的二进制机器码</li></ul></li></ul><h1 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章 - Java内存模型与线程"></a>第12章 - Java内存模型与线程</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><ul><li>Amadahl定律：通过系统中并行化和串行化的比重来描述多处理器系统能获得的运算加速能力。代理摩尔定律成为计算机性能发展源动力的根本原因。</li><li>并发应用场景：<ul><li>计算机的运算速度与它的存储和通信子系统的速度差距过大，需要充分利用计算机处理器的能力</li><li>一个服务端需要同时对多个客户端提供服务</li></ul></li></ul><h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><ul><li>高速缓存: 内存与处理器之间的缓冲，复制同步策略</li><li>产生新的问题：共享内存多核系统的缓存一致性问题</li><li>乱序执行：尽量充分利用处理器内部的运算单元，且保证结果一致</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" class="" title="alt 计算机内存交互关系"><center>计算机内存交互关系</center><h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><ul><li>模型必须足够严谨，让Java的并发内存访问操作不会产生歧义</li><li>模型必须足够宽松，使得虚拟机的实现能充分利用硬件的各种特性，如寄存器、高速缓存、特殊指令等，来获取更快的执行速度</li></ul><h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><ul><li>Java内存模型规定所有变量都存储在主内存中</li><li>每条线程有自己的工作内存，保存该线程使用的变量的主内存副本</li><li>线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的数据。</li><li>不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.png" class="" title="alt Java内存交互模型"><center>Java内存交互模型</center><h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><ul><li>JVM必须保证以下操作是原子的、不可再分的：<ul><li>lock, unlock, read, load, use, assign, store, write</li></ul></li><li>上述8种基本操作必须满足一定规则<ul><li>略</li></ul></li></ul><h3 id="12-3-3-volatile型变量的特殊规则"><a href="#12-3-3-volatile型变量的特殊规则" class="headerlink" title="12.3.3 volatile型变量的特殊规则"></a>12.3.3 volatile型变量的特殊规则</h3><p>当一个变量被定义成volatile之后，将具备两项特性：</p><ol><li><p>保证此变量对所有线程的可见性(变量值修改后对其它线程立即可知)</p><ul><li>但并不完全保证线程安全</li><li>不符合以下两条规则的场景，仍需通过加锁保证原子性：<ul><li>运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量值</li><li>变量不需要与其它的状态变量共同参与不变约束</li></ul></li></ul></li><li><p>禁止指令重排序优化</p><ul><li>普通变量只能保证执行结果正确，不能保证变量赋值操作的顺序和程序代码中的执行顺序一致。即 <code>线程内表现为串行的语义 Within-Thread As-If-Serial Semantics</code></li></ul></li></ol><p>Java中对volatile变量特殊规定的定义：</p><ul><li>每次使用变量前必须先从主内存刷新最新值，保证能看见其它线程对变量所做的修改</li><li>每次修改变量必须立刻同步回主内存中，保证其它线程看到自己对变量的修改</li><li>volatile修饰变量不会被指令重排序优化，保证代码执行顺序与程序顺序相同</li></ul><h3 id="12-3-4-long、double型变量的特殊规则"><a href="#12-3-4-long、double型变量的特殊规则" class="headerlink" title="12.3.4 long、double型变量的特殊规则"></a>12.3.4 long、double型变量的特殊规则</h3><ul><li>对于没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。即<code>long和double的非原子性协定</code></li><li>但主流64位JVM并不会出现非原子性访问行为</li></ul><h3 id="12-3-5-原子性、可见性、有序性"><a href="#12-3-5-原子性、可见性、有序性" class="headerlink" title="12.3.5 原子性、可见性、有序性"></a>12.3.5 原子性、可见性、有序性</h3><ol><li><p>原子性 Atomicity</p><ul><li>由Java内存模型直接保证的原子性变量操作：read, load, assign, use, store, write</li><li>需要更大范围的原子性保证则可以用lock和unlock操作，反映到字节码层次就是monitorenter和monitorexit指令，而在Java代码中就是同步块synchronized关键字</li></ul></li><li><p>可见性 Visibility</p><ul><li>指当一个线程修改了共享变量的值后，其它线程能够立即得知这个参数</li><li>volatile变量可以保证多线程操作时变量的可见性，普通变量不行</li><li>除volatile外，synchronized、final关键字也可以实现可见性</li></ul></li><li><p>有序性 Ordering</p><ul><li>Java程序中，如果在本线程内观察，所有操作都是有序的；<code>线程内表现为串行的语义</code></li><li>如果在一个线程中观察另一个线程，所有的操作都是无序的。<code>指令重排序</code>和<code>工作内存与主内存同步延迟</code></li><li>volatile和synchronized保证线程之间操作的有序性</li></ul></li></ol><p>synchronized可以实现这三种特性，但也伴随着更大的性能影响</p><h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><ul><li>先行发生是Java内存模型中定义的两项操作之间的偏序关系</li><li>作用：判断数据是否存在竞争，数据是否安全</li><li>Java有且仅有以下这些天然的，无需任何同步器协助就存在的先行发生关系：<ul><li>程序次序规则</li><li>管程锁定规则</li><li>volatile变量规则</li><li>线程启动规则</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li><li>传递性</li></ul></li><li>如果两个操作的关系不满足上述规则，也无法从这些规则推导出来，则它们没有顺序性保障，虚拟机可以对它们随意进行重排序</li><li>时间先后顺序与先行发生原则基本没有因果关系，衡量并发安全问题以先行发生原则为准</li></ul><h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><h3 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h3><ul><li>线程是比进程更轻量化的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度</li><li>目前，线程是Java进行处理器资源调度的最基本单位</li><li>Java提供了不同硬件和OS平台下对线程操作的统一处理。<code>java.lang.Thread</code>类的实例就代表一个线程，它的关键方法都被声明为Native，即依赖于具体平台的实现</li><li>实现线程主要由三种方式 (不局限于Java)：内核线程、用户线程、混合线程</li></ul><h4 id="1-使用内核线程-1-1"><a href="#1-使用内核线程-1-1" class="headerlink" title="1. 使用内核线程 1:1"></a>1. 使用内核线程 1:1</h4><ul><li>内核线程KLT是直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上</li><li>每个内核线程可以视为内核的一个分身，这样OS就能同时处理多件任务，称之为多线程内核</li><li>程序一般使用内核线程的一种高级接口——轻量级进程LWP，即线程。即每个轻量级进程都成为一个独立的调度单元，与内核线程是一对一的关系</li><li>局限性：<ul><li>由于是基于内核线程实现的，因此各种线程操作，如创建、析构、同步，都需要进行系统调用。系统调用需要在用户态和内核态之间切换，代价较高</li><li>每个LWP需要消耗一定的内核资源，因此一个系统支持LWP的数量有限</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" class="" title="alt 内核线程实现"><h4 id="2-使用用户线程-1-N"><a href="#2-使用用户线程-1-N" class="headerlink" title="2. 使用用户线程 1:N"></a>2. 使用用户线程 1:N</h4><ul><li>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及实现</li><li>用户线程的建立、同步、销毁、调度完全在用户态中完成，不需要内核帮助。因此速度快开销低，且支持大规模的线程数量</li><li>进程和用户线程之间是一对多的关系</li><li>缺点：没有内核支援，所有操作都需要用户程序自己去处理，实现复杂</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" class="" title="alt 用户线程实现"><h4 id="3-使用用户线程-轻量级进程混合实现-N-M"><a href="#3-使用用户线程-轻量级进程混合实现-N-M" class="headerlink" title="3. 使用用户线程+轻量级进程混合实现 N:M"></a>3. 使用用户线程+轻量级进程混合实现 N:M</h4><ul><li>既存在用户线程，也存在轻量级进程</li><li>用户线程建立在用户空间，开销低，支持大规模的用户线程并发</li><li>OS支持的LWP作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度及处理器映射，并且用户线程的系统调用要通过LWP完成，大大降低进程被阻塞的风险</li><li>用户线程和LWP是多对多的关系</li></ul><h4 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4. Java线程的实现"></a>4. Java线程的实现</h4><ul><li>早期JDK 1.2以前的Classic虚拟机使用的是名为”绿色线程”的用户线程实现</li><li>目前，主流JVM普遍都是基于OS原生线程模型实现的，即1:1的内核线程模型</li></ul><h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><ul><li>线程调度：系统为线程分配处理器使用权的过程</li><li>调度方式：<ul><li>协同式<ul><li>线程的执行时间由线程本身控制，线程工作执行完后，需要主动通知系统切换线程</li><li>实现简单，但线程执行时间不可控</li></ul></li><li>抢占式 (Java的实现方法)<ul><li>由系统为每个线程分配执行时间</li><li>执行时间由系统控制，不会由一个线程导致进程或系统阻塞</li><li>可以通过线程优先级、优先级推进器等功能调节系统分配的执行时间，但不稳定</li></ul></li></ul></li></ul><h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><ul><li>线程的6种状态：<ul><li>新建 New</li><li>运行 Runnable</li><li>无限期等待 Waiting</li><li>限期等待 Timed Waiting</li><li>阻塞 Blocked</li><li>结束 Terminated</li></ul></li><li>阻塞状态时等待另一个线程释放某个排它锁，而等待是等一段时间，或等某个唤醒的动作</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" class="" title="alt 线程状态转换关系"><h2 id="12-5-Java与协程"><a href="#12-5-Java与协程" class="headerlink" title="12.5 Java与协程"></a>12.5 Java与协程</h2><h3 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h3><ul><li>现代B&#x2F;S系统中一次对外部业务的请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也增加了服务的数量，缩短了留给每个服务的响应时间。例如<strong>微服务架构</strong></li><li>Java的内核线程模式存在切换、调度成本高昂，系统能容纳的线程数量有限等缺陷</li></ul><h3 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h3><ul><li>用户态和核心态的切换开销主要来源于响应中断、保护和恢复执行现场的成本。涉及一系列数据在各种寄存器、缓存中的来回拷贝</li><li>DOS操作系统曾出现过<code>栈纠缠Stack Twine</code>这种由用户模拟多线程的工作模式</li><li>最初的用户线程被设计为协同式调度，也称<code>协程</code>。分为有栈协程和无栈协程</li><li>协程的主要优势是轻量，同时存活数量以十万计</li><li>协程的局限性在于需要应用层实现的内容特别多，如调用栈、调度器</li></ul><h3 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h3><ul><li><code>纤程 Fiber</code>：典型的有栈协程，使用用户线程，并完整实现调用栈的保护、恢复工作</li><li>新并发模式下，使用纤程并发的代码分为执行过程和调度器</li><li>其实也可以不依赖虚拟机实现协程，如Kotlin的协程、Quasar协程库</li></ul><h1 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章- 线程安全与锁优化"></a>第13章- 线程安全与锁优化</h1><h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>“线程安全”的定义 (来自Brian Goetz -《Java Concurrency In Practice》)：<br>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，就称这个对象是线程安全的</p><h3 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h3><p>按线程安全由强至弱，将各种操作共享的数据分为以下五类：</p><ul><li><p><strong>1. 不可变</strong></p><ul><li>Immutable的对象一定是线程安全的，不需要任何保障措施</li><li>对于基本类型只要在定义时使用final修饰，就是不可变的</li><li>对于类对象，需要对象自行保证其行为不会对其状态产生任何影响</li><li>典型的不可变类型包括String, Long、 Double等数值包装类型, BigInteger、BigDecimal等大数据类型</li></ul></li><li><p><strong>2. 绝对线程安全</strong></p><ul><li>满足上述线程安全的定义，不管运行环境如何，都不需要任何额外的同步措施</li></ul></li><li><p><strong>3. 相对线程安全</strong></p><ul><li>即通常意义上的线程安全，需要保证对该对象的单次操作是线程安全的。但对于一些特定顺序的连续调用，需要额外的同步</li><li>Java中大部分声称线程安全的类都是相对线程安全</li></ul></li><li><p><strong>4. 线程兼容</strong></p><ul><li>指对象本身不是线程安全，但可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全使用</li></ul></li><li><p><strong>5. 线程对立</strong></p><ul><li>指不管调用端是否采取同步，都无法在多线程环境中并发使用代码</li><li>由于Java天生支持多线程，线程对立的代码很少出现，且通常是有害的，应尽量避免</li><li>如Thread::suspend(), Thread::resume()等</li></ul></li></ul><h3 id="13-2-2-线程安全的实现方式"><a href="#13-2-2-线程安全的实现方式" class="headerlink" title="13.2.2 线程安全的实现方式"></a>13.2.2 线程安全的实现方式</h3><p><strong>1. 互斥同步</strong></p><ul><li>最常见也最主要的并发正确性保障手段</li><li>同步指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</li><li>互斥是实现互斥的一种手段，例如临界区、互斥量、信号量</li><li>即互斥是因，同步是果；互斥是方法，同步是目的</li></ul><ul><li>synchronized是最基本的，重量级的块结构同步互斥手段<ul><li>编译后在同步块前后生成<code>monitorenter</code>和<code>monitorexit</code>字节码指令</li><li>通过对一个reference类型的参数指定锁定和解锁的对象</li><li>推论：<ul><li>synchronized同步块对同一条线程来说是可重入的。即同一线程不会死锁</li><li>synchronized同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。即无法强制退出</li></ul></li></ul></li><li>Lock接口，以非块结构实现互斥同步。典型实现如ReentrantLock, ReentrantReadWriteLock<ul><li>高级功能：等待可中断、公平锁、锁绑定多个条件</li><li>相同情况下，synchronized更加合适的原因：<ul><li>sychronized是语法层面的同步，足够清晰，也足够简单</li><li>Lock要确保在finally块中释放锁，否则可能永远不释放</li><li>JVM更容易针对synchronized进行优化</li></ul></li></ul></li></ul><p><strong>2. 非阻塞同步</strong></p><ul><li>互斥同步的主要问题在于进行线程阻塞和唤醒所带来的性能开销</li><li>非阻塞同步是一种基于冲突检测的乐观并发策略，即不管有没有风险，先进行操作，发生冲突再进行补偿措施</li><li>比较并交换 <code>CAS指令</code>：<ul><li>原子操作，不会被其它线程中断</li><li>三个操作数，内存位置V，旧的预期值A，准备设置的新值B</li><li>当且仅当V符合A时，处理器才会用B更新V的值，否则就不更新。无论是否更新，都返回旧值</li><li>逻辑漏洞 - ABA问题：原值A，被其他线程修改为B，后来又被修改回A，CAS无法判断是否未被修改过。可以通过控制变量值的版本来保证CAS正确性</li></ul></li></ul><p><strong>3. 无同步方案</strong></p><ul><li>如果程序不涉及共享数据，自然也就不需要任何同步措施保证正确性</li><li>可重入代码：<ul><li>又称纯代码，可以在任何时刻中断，去执行其它代码，不会影响执行结果</li><li>相对线程安全来说，可重入性是更为基础的特性，可以保证代码线程安全</li><li>即所有可重入代码都是线程安全的，但并非所有线程安全的代码都是可重入的</li></ul></li><li>线程本地存储：<ul><li>程序中的共享数据的代码能否保证再同一线程内执行，如果能也不需要进行同步</li><li>典型用例如消费队列的架构模式、经典Web交互模型中的”一个请求对应一个服务器线程”</li></ul></li></ul><h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>目的：为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率</p><h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><ul><li>若一个物理机有一个以上的处理器&#x2F;核心，能让多线程并行执行，就可以让后面请求锁地线程稍等，但不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。</li><li>自旋锁：为了让线程等待，只需让线程执行一个忙循环，即自旋</li><li>JDK 6加入自适应自旋，自选的时间不再固定。根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自旋获得锁的成功次数越多，自旋容许时间就越长</li></ul><h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><ul><li>指JVM即时编译器运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除</li><li>主要依据来源于逃逸分析的数据支持，如果一段代码的所有数据都不会逃逸出去被其他线程访问，就可以当作栈上数据，无需同步加锁</li></ul><h3 id="13-3-3-锁相关"><a href="#13-3-3-锁相关" class="headerlink" title="13.3.3 锁相关"></a>13.3.3 锁相关</h3><ul><li>一般编写代码要求同步块范围尽可能小</li><li>但如果JVM检测到一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围扩展（粗化）到整个操作序列的外部</li></ul><h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><ul><li>目的是在没有多线程竞争的前提下，减少传统的重量级锁使用OS互斥量产生的性能消耗</li><li>对象头Mark Word的32位比特空间里，有2位用于存储锁标志位，标记未被锁定、轻量级锁、重量级锁、GC标记、可偏向等状态</li><li>使用CAS加锁解锁</li><li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁</li><li>轻量级锁能提升程序同步性能的依据是：”<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>“这一经验法则</li><li>如果确实存在锁的竞争，轻量级锁反而比传统的重量级锁更慢<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%87%E5%BF%97%E4%BD%8D.png" class="" title="alt 对象头标志位"></li></ul><h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><ul><li>目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能</li><li>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其它线程获取，则持有偏向锁的线程将永远不需要再进行同步</li><li>一旦另一个线程尝试获取这个锁，偏向模式立刻宣告结束</li><li>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象处于偏向锁状态，又收到需要计算一致性哈希码请求时，偏向状态立刻撤销，并且锁会膨胀为重量级锁(可以通过<code>ObjectMonitor</code>拿到哈希码)</li><li>偏向锁可以提高带有同步但无竞争的程序性能，但同样带有效益权衡。如果程序中大多数锁都总是被多个不同的线程访问，那偏向模式就是多余的</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-位运算</title>
    <link href="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode 136. 只出现一次的数字"></a>LeetCode 136. 只出现一次的数字</h1><p>链接：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode136.png" class="" title="alt LeetCode136"><p>找出数组中唯一成单的数字，主要学习异或运算的性质和哈希表的使用。</p><h2 id="解法1-异或运算"><a href="#解法1-异或运算" class="headerlink" title="解法1. 异或运算"></a>解法1. 异或运算</h2><p>异或运算的三个性质</p><ul><li>任何数和0做异或，结果仍是原来的数<br>  $ a \bigoplus 0 &#x3D; a $</li><li>任何数和自身做异或结果是0<br>  $ a \bigoplus a &#x3D; 0 $</li><li>异或运算满足交换律和结合律<br>  $ a \bigoplus b \bigoplus a &#x3D; b \bigoplus a \bigoplus a &#x3D; b $<br>因此数组中所有元素异或即可得到单个的元素。时间复杂度$O(n)$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            ans ^= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="解法2-哈希表"><a href="#解法2-哈希表" class="headerlink" title="解法2. 哈希表"></a>解法2. 哈希表</h2><p>使用哈希表存储每个数字和该数字出现的次数。最后次数为1的就是单个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.get(i);<br>            map.put(i, count == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++count;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$,空间复杂度$O(n)$</p><hr><h1 id="LeetCode-191-位1的个数"><a href="#LeetCode-191-位1的个数" class="headerlink" title="LeetCode 191. 位1的个数"></a>LeetCode 191. 位1的个数</h1><p>链接：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode191.png" class="" title="alt LeetCode191"><h2 id="方法1-移位"><a href="#方法1-移位" class="headerlink" title="方法1 - 移位"></a>方法1 - 移位</h2><p>循环检查二进制的每一位是否为1，例如让n和 $2^i$ 进行与运算，或者让n和1相与并右移n，得到二进制末尾是否为1<br>时间复杂度$O(k)$, 其中$k$是二进制位数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            count += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注，Java中：</p><ul><li><code>&lt;&lt;</code> 左移，高位舍弃，低位补0</li><li><code>&gt;&gt;</code> 右移，舍弃最低位，高位用符号位填补，正数补0，负数补1</li><li><code>&gt;&gt;&gt;</code> 无符号右移，舍弃最低位，高位用0填补</li></ul><h2 id="方法二-Brian-Kernighan算法"><a href="#方法二-Brian-Kernighan算法" class="headerlink" title="方法二 - Brian Kernighan算法"></a>方法二 - Brian Kernighan算法</h2><p>利用 $n \And (n-1)$ 能够把二进制中的最低位1变为0的特性，反复操作，直至n&#x3D;0</p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/n&n-1.png" class="" title="alt n&amp;n-1"><p>可以看到，n-1会把n末尾的0变1，直到遇到最低位的1把它变0，其余保持不变。相与时，n末尾的0与运算后仍是0，而最低位1和0相与得0，其余位不变。因此，$n \And (n-1)$把n的最低位1变成了0，其余位不变。</p><p>时间复杂度$O(logn)$, 循环次数就是n的二进制中1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法3-分治"><a href="#方法3-分治" class="headerlink" title="方法3 - 分治"></a>方法3 - 分治</h2><p>0x55555555 &#x3D; 0B0101…0101<br>0x33333333 &#x3D; 0B0011…0011<br>0x0f0f0f0f &#x3D; 0B00001111…00001111</p><p>贴上Java中的<code>Integer::bitCount()</code>源码，太神奇了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bitCount</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        i = i - ((i &gt;&gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);                   <span class="hljs-comment">// 此时i每两位的值是原数字每两位1的个数</span><br>        i = (i &amp; <span class="hljs-number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);    <span class="hljs-comment">// 此时i每4位的值是原数字每4位1的个数 </span><br>        i = (i + (i &gt;&gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0f0f0f0f</span>;                   <span class="hljs-comment">// 此时i每8位的值是原数字每8位1的个数</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">8</span>);                                  <span class="hljs-comment">// 每两个8位合并统计</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">16</span>);                                 <span class="hljs-comment">// 两个16位合并统计</span><br>        <span class="hljs-keyword">return</span> i &amp; <span class="hljs-number">0x3f</span>;                                    <span class="hljs-comment">// 取出低6位，因为32bit最高只有32个1</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>注意第二行，前半句保留奇数组的”两位”，后半句保留偶数组的”两位”，然后相加使得相邻的两个”两位”合并统计，即得到每4位1的个数<br>分开&amp;的原因在于2bit最多表示3个1，不足以表示原数字每4位1的个数，因此要多做一次&amp;然后相加<br>而在第三行，4bit(0-15)可以表示8位二进制1的个数，因此只需要&amp;一次</p><hr><h1 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode 461. 汉明距离"></a>LeetCode 461. 汉明距离</h1><p>链接：<a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode461.png" class="" title="alt LeetCode461"><p>先把两数字异或，然后同LeetCode191，统计1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x ^ y, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (s != <span class="hljs-number">0</span>) &#123;<br>            s &amp;= s - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 总结</title>
    <link href="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-复习"><a href="#Java-SE-复习" class="headerlink" title="Java SE 复习"></a>Java SE 复习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>引用数据类型</li><li>基本数据类型 4大类8种 <em>(1-2-4-8)</em><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.svg" class="" title="alt Java基本数据类型"></li></ol><ul><li><p>自动类型转换：类型范围小的变量，可以直接赋值给类型范围大的变量</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 自动类型转换"><p><strong><code>byte --&gt; short (char) --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></p></li><li><p>在表达式中，小范围类型的变量会自动转换成较大范围的类型再运算</p><ul><li><strong><code>byte, short, char --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></li><li>最终结果类型由表达式中的最高类型决定</li><li>在表达式中，byte、short、char 直接转换成int类型参与运算的</li></ul></li><li><p>强制类型转换：可以强行将类型范围大的变量、数据赋值给类型范围小的变量</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 强制类型转换"><ul><li>强制类型转换可能造成数据(丢失)溢出</li><li>浮点型强转成整型，直接丢掉小数部分，保留整数部分返回</li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>短路逻辑运算符<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.svg" class="" title="alt 短路逻辑运算符"></li><li>逻辑与<code>&amp;</code>, 逻辑或<code>|</code>: 无论左边是false还是true，右边都要执行</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>代码块<code>&#123;&#125;</code>是类的5大成分之一(成员变量、构造器、方法、代码块、内部类)</li><li>静态代码块<ul><li><code>static&#123; &#125;</code></li><li>通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次</li><li>使用场景：在类加载的时候做一些静态数据初始化的操作，以便后续使用</li></ul></li><li>构造代码块(很少使用)<ul><li><code>&#123; &#125;</code></li><li>每次创建对象调用构造器前，都会执行该代码块</li><li>使用场景：初始化实例资源</li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>饿汉单例：</p><ul><li>在用类获取对象时，对象已经提前为你创建好了</li><li>设计步骤：定义类，构造器私有，定义静态变量存储单例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 属于类，与类一起仅加载一次</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;创建了一个对象&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉单例：</p><ul><li>在真正需要该对象时，才去创建一个对象(延迟加载对象)</li><li>设计步骤：定义类，构造器私有，定义静态变量存储对象，提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 类加载时初始为null</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance instance;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br>    <span class="hljs-keyword">return</span> instace;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>子类中访问成员满足就近原则，先找子类，子类没有找父类，父类没有报错</li><li>子类可以直接使用父类的静态成员(共享)</li><li>方法重写<ul><li>私有方法不能被重写。但可以定义相同签名的方法。</li><li>子类重写父类方法时，访问权限必须大于或等于父类 <code>缺省 &lt; protected &lt; public</code></li><li>子类不能重写父类的静态方法</li></ul></li><li>权限修饰符<ul><li><code>private &lt; 缺省 &lt; protected &lt; public</code><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4.svg" class="" title="alt 权限修饰符作用范围"></li></ul></li><li>final 修饰符<ul><li>修饰类，表明该类不能被继承</li><li>修饰方法，表明该方法不能被重写</li><li>修饰变量，表明该变量不能被重新赋值 <ul><li>基本类型 – 数据值不能改变</li><li>引用类型 – 存储的地址值不能改变(地址指向的对象可变)</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>一种约束规范</li><li>接口中的变量默认都是 <code>public static final</code></li><li>接口中的方法默认都是 <code>public abstract</code></li><li>JDK 8&#x2F;9 新增特性：<ul><li><ol><li>默认方法 - default修饰，自动public，需用接口实现类的对象来调用</li></ol></li><li><ol start="2"><li>静态方法 - static修饰，自动public，需用接口本身的接口名调用</li></ol></li><li><ol start="3"><li>私有方法 - private修饰，只能在 接口中被其它的方法访问</li></ol></li></ul></li><li>一个类同时继承父类和实现接口中的同名方法，优先使用父类的</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>访问特点：<ul><li>方法调用：编译看左边，运行看右边</li><li>变量调用：编译看左边，运行也看左边</li></ul></li><li>强制类型转换<ul><li>可以转换成真正的子类型，从而调用子类的独有功能</li><li>强转前尽量使用<code>instanceof</code>判断对象的真实类型再进行强转</li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1. 静态内部类"></a>1. 静态内部类</h3><ul><li><code>static</code>修饰，属于外部类这个类</li><li>创建格式：<code>Outer.Inner in = new Outer.Inner()</code></li><li>可以直接访问外部类静态对象</li><li>不可以直接访问外部类实例成员</li></ul><h3 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2. 成员内部类"></a>2. 成员内部类</h3><ul><li><code>无 static</code>修饰，属于外部类的对象</li><li>创建格式：Outer.Inner in &#x3D; new Outer().new Inner();</li><li>可以直接访问外部类静态对象</li><li>可以直接访问外部类实例成员(必须先有外部类对象，才能有成员内部类对象)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>          System.out.println(hearbeat); <span class="hljs-comment">// 78</span><br>          System.out.println(<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 110</span><br>          System.out.println(People.<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 150</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a>3. 局部内部类</h3><ul><li>放在方法、代码块、构造器等执行体中</li><li>类文件名：<code>Outer$NInner.class</code></li><li>鸡肋</li></ul><h3 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h3><ul><li>本质上是没有名字的局部内部类</li><li>既是一个类，也代表一个对象(new的类型的子类类型)，写出来就会产生一个匿名内部类的对象</li><li>可以直接作为对象传给方法</li><li>作用：方便创建子类对象，简化代码编写</li><li>创建格式：<code>new 类/抽象类名/接口( )&#123; 重写方法 &#125;</code></li></ul><ul><li>Lambda表达式：<ul><li>一个匿名函数，是一段可以传递的代码</li><li>用于简化函数式接口的匿名内部类的写法形式</li><li>函数式接口：有且仅有一个抽象方法的接口，通常加上@FunctionalInterface注解</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两种创建过程"><a href="#两种创建过程" class="headerlink" title="两种创建过程"></a>两种创建过程</h3><ol><li><p><code>&quot;&quot;</code>双引号创建字符串：会先判断常量池里面是否有相同的字符串，若有则直接指向该地址</p></li><li><p><code>new</code>关键字不论常量池中是否已经有该串，都会在堆中开辟新的内存空间存放该字符串</p></li></ol><h3 id="String-面试题"><a href="#String-面试题" class="headerlink" title="String 面试题"></a>String 面试题</h3><ul><li>问题：下列代码的运行结果是？<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E9%9D%A2%E8%AF%95%E9%A2%98.svg" class="" title="alt String面试题1"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先在堆的字符串常量池里创建&quot;abc&quot;的串，然后new再创建一个新串赋给s2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-comment">// 由于是双引号，直接指向常量池里的&quot;abc&quot;，因此这条语句没有创建新字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-comment">//false, s1指向的是常量池里的&quot;abc&quot;,s2指向的是堆里的&quot;abc&quot;</span><br>System.out.println(s1 == s2) <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s7</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qwe&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qw&quot;</span>;<br><span class="hljs-comment">// 只要不是直接双引号给出的字符串，都是非常量池的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s9</span> <span class="hljs-operator">=</span> s8 + <span class="hljs-string">&quot;e&quot;</span>;<br><span class="hljs-comment">// false, s7指向常量池的&quot;qwe&quot;,s9指向堆里的&quot;qwe&quot;</span><br>System.out.println(s7 == s9);  <br><span class="hljs-type">String</span> <span class="hljs-variable">s10</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s11</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;s&quot;</span> + <span class="hljs-string">&quot;d&quot;</span>;<br><span class="hljs-comment">// true, 编译优化机制：直接将&quot;a&quot;+&quot;s&quot;+&quot;d&quot;转换为&quot;asd&quot;，可以通过class文件确认</span><br><span class="hljs-comment">// 而s9由于s8是变量，不是字面量，因此没有优化</span><br>System.out.println(s10 == s11);<br></code></pre></td></tr></table></figure><h3 id="StringBuilder-拼接字符串"><a href="#StringBuilder-拼接字符串" class="headerlink" title="StringBuilder 拼接字符串"></a>StringBuilder 拼接字符串</h3><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt String拼接字符串"> <center>**String拼接字符串原理 - 每次拼接都会产生新的对象**</center><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/StringBuilder%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt StringBuilder拼接字符串"> <center>**StringBuilder拼接字符串原理 - 对同一个对象做修改**</center><ul><li>StringBuilder相当于一个容器，拼接、修改更加高效</li><li>StringBuilder只是个工具，最终的目的是得到String </li><li>StringBuffer是StringBuilder的多线程安全版，单线程下StringBuilder效率更高</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li><p><strong>List</strong>: 有序、可重复、有索引</p><ul><li><strong>ArrayList</strong>: 底层基于数组，默认长度10，存满时扩容1.5倍</li><li><strong>LinkedList</strong>: 底层基于双链表，可模拟栈&#x2F; 队列</li></ul></li><li><p><strong>Set</strong>: 无序、不重复、无索引</p><ul><li><strong>HashSet</strong>:<br>基于哈希表，底层采用<code>数组+链表+红黑树</code>实现。哈希表默认长度16，加载因子0.75，每次扩容2倍。相同哈希值的元素构成链表，新元素挂在老元素后面，当链表长度超过8自动转为红黑树。</li><li><strong>LinkedHashSet</strong>:<br>有序，底层<code>哈希表+双链表</code>记录存储顺序</li><li><strong>TreeSet</strong>:<br>自动排序，底层基于<code>红黑树</code>实现。必须指定比较规则 (比较器&#x2F;比较接口)</li></ul><p>如果希望 Set 认为两个内容一样的对象是重复的，必须重写对象的<code>hashCode()</code>和<code>equals()</code>方法</p></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.svg" class="" title="alt 集合体系"><ul><li><p>遍历方式：</p><ol><li>迭代器 <code>Iterator::hasNext, Iterator::next</code></li><li><code>for-each 循环</code> 注意集合中存储的是对象的地址，因此修改第三方变量不会影响到集合中的元素</li><li>lambda表达式 <code>forEach(Consumer&lt;? super T&gt; action)</code></li></ol><p>遍历时直接用集合删除元素可能出现并发异常，可以通过迭代器删除</p></li><li><p><strong>Collections</strong> 集合工具类</p><ul><li>addAll</li><li>sort</li><li>shuffle</li></ul></li><li><p>不可变集合 <strong>ImmutableCollections</strong>：</p><ul><li>List.of</li><li>Set.of</li><li>Map.of</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><strong>HashMap</strong>: </p><ul><li>无序，不重复，无索引，值不作要求</li><li>基于哈希表、数组、红黑树实现</li><li>基于hashCode()和equals()保证键的唯一</li></ul></li><li><p><strong>LinkedHashMap</strong>：</p><ul><li>按键有序，不重复，无索引，值不作要求</li><li>基于哈希表、双链表记录存储顺序</li></ul></li><li><p><strong>TreeMap</strong>: </p><ul><li>自动按键排序 ，不重复，无索引，值不作要求</li><li>底层基于<code>红黑树</code>实现，必须指定键的比较规则(比较器&#x2F;比较接口)</li></ul></li><li><p><strong>Properties</strong></p><ul><li>本质是Map集合，一般代表一个属性文件，存储对象键值对，作为系统配置信息</li><li><code>store(Stream, comments), load(Stream), setProperty, getProperty</code></li></ul><p>Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据。</p></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/map%E4%BD%93%E7%B3%BB.svg" class="" title="alt map体系"><ul><li>遍历方式：<ol><li>键找值：<code>map.keySet(), map.get(key)</code></li><li>键值对：<code>map.entrySet(), entry.getKey(), entry.getValue()</code></li><li>Lambda表达式：<code>map.forEach(BiConsumer&lt;K, V&gt;)</code></li></ol></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>自定义泛型类<br><code>public class MyGeneric&lt;T&gt; &#123;&#125;</code></li><li>自定义泛型方法<br><code>public &lt;T&gt; void MyFun(T t) &#123;&#125;</code></li><li>自定义泛型接口<br><code>public interface MyInterface&lt;E&gt; &#123;&#125;</code></li><li>泛型通配符<br>？可以在使用泛型时代表一切类型<br><code>? extends Class</code> 泛型上限，限定必须是Class或其子类<br><code>? super Class</code> 泛型下限，限定必须是Class或其父类</li><li>底层实现上，字节码中的泛型类型都会被擦除</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>对于任何一个Class对象，可以在运行时得到这个类的全部成分</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul><li>Class.forName(String)</li><li>类目.class</li><li>对象.getClass()<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96Class.svg" class="" title="alt 反射获取Class对象"></li></ul><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><ul><li>Class::getConstructors([paramTypes]) 获取公有构造器, Class::getDeclaredConstructors([paramTypes]) 获取所有构造器</li><li>Constructor::newInstance() 根据指定构造器创建新对象</li><li>Constructor::setAccessible(boolean) 设置访问检查，实现暴力反射(调用私有构造器，破坏了封装性)</li></ul><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ul><li>Class::getFields(name), Class::getDeclaredFields(name)</li><li>Field::set(object, val), Field::get(obj) 设置&#x2F;获取成员变量的值</li><li>Field::setAccessible(boolean)</li></ul><h3 id="获取方法对象"><a href="#获取方法对象" class="headerlink" title="获取方法对象"></a>获取方法对象</h3><ul><li>Class::getMethods([name, params]), Class::getDeclaredMethods([name, params])</li><li>Method::invoke(obj, args…) 对obj对象调用目标方法，可以获取返回值</li><li>Method::setAccessible(boolean)</li></ul><h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><ul><li><p>结合Lambda表达式，简化集合、数组操作的API</p></li><li><p>流的三类方法：</p><ul><li><p>获取Stream流：<br>创建一条流水线，并把数据放到流水线上准备进行操作。如<code>Collection.stream(), Arrays.stream(T[]), Stream.of(T...)</code></p></li><li><p>中间方法：<br>流水线上的操作，调用完成后返回新的Stream流，支持链式编程。如<code>filter, limit, skip, distinct, map, concat</code></p></li><li><p>终结方法：<br>流水线的最后一个操作，调用后不返回Stream，因此一个Stream流仅有一个。如<code>forEach, count</code></p></li></ul></li><li><p>流的收集</p><ul><li>把Stream流操作后的结果转回集合或数组。Stream是手段，集合&#x2F;数组才是目的</li><li>流只能使用一次 </li><li>方法：<code>stream.collect, stream.toArray, stream.toList</code>, Collector包括<code>Collectors::toList, Collectors::toSet, Collectors::toMap</code>等</li></ul></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul><li>代表OS的文件&#x2F;文件夹对象。提供定位、获取文件信息、删除、创建等功能</li><li><code>createNewFile</code></li><li><code>mkdir</code>创建一级目录, <code>mkdirs</code>创建多级目录</li><li><code>delete</code>删除文件&#x2F;空文件夹且不走回收站</li><li><code>list</code>返回目录下文件名数组,<code>listFiles</code>返回目录下文件对象数组，仅包括一级</li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>常见字符集:<ul><li>ASCII: 1个字节存储1个字符，共128个</li><li>GBK: 包含汉字等字符，一个中文2个字节存储</li><li>Unicode (UTF-8): 一个中文3个字节存储</li></ul></li><li>编解码：<ul><li>英文、数字在任何字符集都占1字节，不会乱码</li><li>编码：<code>string.getBytes(chatset)</code></li><li>解码：<code>String(byte[], charset)</code></li></ul></li></ul><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><ul><li><p>分类</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E5%88%86%E7%B1%BB.svg" class="" title="alt IO流分类"></li><li><p>体系</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E4%BD%93%E7%B3%BB.svg" class="" title="alt IO流体系"></li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><ul><li><p>InputStream</p><ul><li><code>read(), read(byte[len]), readAllBytes</code> 读取1 &#x2F; len &#x2F; 所有字节</li></ul></li><li><p>OutputStream</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字节流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><ul><li><p>Reader</p><ul><li><code>read(), read(char[len])</code> 读取 1 &#x2F; len 个字符</li></ul></li><li><p>Writer</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字符流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><ul><li>使用总结<ul><li>字节流适合一切文件数据的拷贝，包括音视频、文本等</li><li>字节流不适合读取中文内容输出</li><li>字符流适合文本文件的读写</li></ul></li></ul><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul><li>也称高效流、高级流。自带8KB缓冲区，可以提高原始字节流、字符流读写数据的性能。建议使用<strong>缓冲流+字节数组</strong></li><li><code>BufferedInputStream(InputStream)</code></li><li><code>BufferedOutputStream(OutputStream)</code></li><li><code>BufferedReader(Reader)</code>, <code>readline()</code></li><li><code>BufferedWriter(Writer)</code>, <code>newLine()</code></li></ul><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><ul><li>把原始的字节流按照指定编码转换</li><li>字符输入转换流：<code>InputStreamReader(InputStream, charset)</code></li><li>字符输出转换流：<code>OutputStreamWriter(OutputStream, charset)</code></li><li>建议创建转换流后使用缓冲流进行包装，提高性能</li></ul><h4 id="对象字节流-序列化"><a href="#对象字节流-序列化" class="headerlink" title="对象字节流 - 序列化"></a>对象字节流 - 序列化</h4><ul><li>以内存为基准，把内存中的对象存储到磁盘文件中，称为对象序列化</li><li>对象字节输出流：<code>ObjectOutputStream(OutputStream)</code></li><li><code>oos.writeObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li>以内存为基准，把存储在磁盘文件中的数据恢复成内存中的对象，称为对象反序列化</li><li>对象字节输入流：<code>ObjectInputStream(InputStream)</code></li><li><code>ois.readObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li><code>transient</code>修饰的成员变量不参与序列化</li><li>通常指定一个序列化版本号，以确保序列化、反序列化的对象保持一致</li></ul><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><ul><li>方便、高效地打印数据到文件中</li><li>基于字节<code>PrintStream</code>, 基于字符<code>PrintWriter</code></li><li><code>print()</code>, PrintStream支持写字节，PrintWriter支持写字符</li><li><code>System.out</code>就是一个PrintStream对象。可以重定向输出语句到文件中：<code>System.setOut(new PrintStream(File))</code></li></ul><h4 id="commons-io-库"><a href="#commons-io-库" class="headerlink" title="commons-io 库"></a>commons-io 库</h4><ul><li>IOUtils::copy</li><li>FileUtils::copyFileToDirectory</li><li>FileUtils::copyDirectoryToDirectory</li><li>…</li></ul><ul><li>JDK 1.7 引入了 NIO库</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><ul><li>定义任务类继承java.lang.Thread，重写run()方法</li><li>创建线程对象， 调用Thread::start()启动线程</li></ul><ul><li>优点：编码简单</li><li>缺点：不利于扩展，自定义线程无法继承其它类</li></ul><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><ul><li>创建Runnable接口匿名内部类，重写run()方法</li><li>把Runnable交给Thread类处理，调用start()启动线程</li></ul><ul><li>优点：可以继续继承、实现，扩展性强</li><li>缺点：多一层包装，线程如果有执行结果不可以直接返回</li></ul><h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><ul><li>定义任务类实现Callable接口，重写call()方法</li><li>用FutureTask把Callable对象封装成线程任务对象</li><li>把FutureTask交给Thread类处理调用，start()启动线程</li><li>线程执行完毕后，通过FutureTask::get()获取任务执行的结果</li></ul><ul><li>优点：可以继续继承、实现，扩展性强。且可以在线程执行完毕后获取执行结果</li><li>缺点：编码稍复杂</li></ul><h3 id="Thread常用API"><a href="#Thread常用API" class="headerlink" title="Thread常用API"></a>Thread常用API</h3><ul><li>setName, getName</li><li>currentThread() 返回当前正在执行的线程对象的引用</li><li>sleep(long) 让线程休眠指定时间，单位毫秒</li><li>yield, join, interrupt…</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><p>多个线程同时访问同一个共享资源且修改该资源</p></li><li><p>线程同步的核心思想：加锁</p><ul><li>同步代码块 <ul><li>synchronized(锁对象) </li><li>一般把共享资源作为锁对象</li><li>建议实例方法使用this作为锁对象，静态方法使用类.class对象作为锁对象</li></ul></li><li>同步方法 <ul><li>synchronized 修饰方法</li><li>底层：实例方法默认对this加锁，静态方法默认对类.class加锁</li></ul></li><li>Lock锁<ul><li>实现类：ReentrantLock</li><li>lock, unlock</li></ul></li></ul></li><li><p>线程通信</p><ul><li>wait() 让当前线程释放锁并进入等待，直到另一个线程唤醒</li><li>notify(), notifyAll() 唤醒正在等待的单个 &#x2F; 所有线程</li><li>必须通过当前同步锁对象进行调用</li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>创建线程的开销很大，可以通过复用线程，提高系统性能</p></li><li><p>线程池接口：<code>ExecutorService</code>; 实现类：<code>ThreadPoolExecutor</code>;  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-type">int</span> corePoolSize,                   //指定线程池的线程数量 (核心线程)</span><br>  <span class="hljs-type">int</span> maximumPoolSize,                <span class="hljs-comment">//指定线程池可支持的最大线程数 (&gt;=核心线程数)</span><br>  <span class="hljs-type">long</span> keepAliveTime,                 <span class="hljs-comment">//指定临时线程的最大存活时间</span><br>  TimeUnit unit,                      <span class="hljs-comment">//指定存活时间的单位(秒、分、时、天)</span><br>  BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//指定任务队列</span><br>  ThreadFactory threadFactory,        <span class="hljs-comment">//指定用哪个线程工厂创建线程</span><br>  RejectedExecutionHandler handler    <span class="hljs-comment">//指定线程忙，任务满的时候，新任务来了怎么办</span><br>)<br></code></pre></td></tr></table></figure><ul><li>新任务提交时的服务顺序：核心线程 -&gt; 任务队列 -&gt; 创建临时线程 -&gt; 拒绝服务<ul><li>如果核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li><li>核心线程、临时线程都在忙，任务队列也满了，新的任务到达时才会开始拒绝服务</li></ul></li><li>常用方法：<code>execute(Runnable), submit(Callable), shutdown(), shutdownNow()</code></li><li>拒绝策略：<ul><li><code>ThreadPoolExecutor.AbortPolicy</code> 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>ThreadPoolExecutor.DiscardPolicy</code> 丢弃且不抛异常，不推荐</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 抛弃队列中等待最久的任务 然后把当前任务加入队列中</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 绕过线程池，由主线程直接调用任务的run()方法执行</li></ul></li></ul></li><li><p>线程池工具类: <code>Executors</code> 通过调用方法返回不同类型的线程池对象</p><ul><li><code>newCachedThreadPool()</code> 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉</li><li><code>newFixedThreadPool​(int nThreads)</code> 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它</li><li><code>newSingleThreadExecutor()</code> 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程</li><li><code>newScheduledThreadPool​(int corePoolSize)</code> 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务</li><li>底层仍是基于ThreadPoolExecutor实现的</li><li>最大任务队列长度&#x2F;线程数量是Integer.MAX_VALUE,可能出现OOM</li></ul></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul><li>一种控制任务延时调用，或者周期调用的技术</li><li>实现方式：<ol><li>Timer<ul><li>Timer::schedule(task, delay&#x2F;time, period);</li><li>Timer单线程，处理多个任务按顺序执行，存在延时，和设置定时器的时间有出入</li><li>可能因为异常导致Timer线程死掉，从而影响后续任务执行</li></ul></li><li>ScheduledExecutorService<ul><li>Executors.newScheduledThreadPool​(int corePoolSize)</li><li>ScheduledExecutorService.scheduleAtFixedRate(Runnable, delay, period, unit)</li><li>基于线程池，某个任何的执行情况不会影响其它定时任务</li></ul></li></ol></li></ul><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul><li>并发: CPU分时轮询执行</li><li>并行: 同一时刻同时执行</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li>Java定义了6中状态：Thread.State::{NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED}<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" class="" title="线程的生命周期"></li></ul><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li>操作类 <code>InetAddress</code></li><li>getLocalHost 返回本主机的地址对象</li><li>getByName(host) 得到指定主机(域名&#x2F;IP)的IP地址对象</li><li>getHostName 返回此IP地址的主机名</li><li>getHostAddress 返回IP地址字符串 </li><li>isReachable(timeout) 指定时间ms内是否连通该IP</li></ul><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ul><li>标识主机上的进程，16bit，0-65535</li><li>周知端口 0-1023：预先定义的知名应用，如HTTP 80，FTP 21</li><li>注册端口 1024-49151：分配给用户进程&#x2F;应用程序，如Tomcat 8080，MySQL 3306</li><li>动态端口 49152-65535</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li>Ping命令直接基于网络层ICMP协议，无连接，不针对特定端口。与传输层TCP&#x2F;UDP，或是应用层HTTP等都无关</li><li>Socket是一个调用接口，实际是对TCP&#x2F;IP协议的封装</li><li>UDP协议的数据包大小限制64KB</li></ul><h3 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h3><ul><li>DatagramPacket 数据包对象<ul><li>DatagramPacket(byte[] buf, length, InetAddress, port)</li><li>getLength() 获取实际接受的字节个数</li></ul></li><li>DatagramSocket 发送者&#x2F;接收者对象<ul><li>DatagramSocket(port)</li><li>send(packet)</li><li>receive(packet)</li></ul></li></ul><ul><li>广播 Broadcast<ul><li>使用广播地址 255.255.255.255</li><li>发送端指定端口，其它主机注册该端口即可</li></ul></li><li>组播 Multicast<ul><li>使用组播地址 224.0.0.0 - 239.255.255.255</li><li>发送端指定组播IP和端口，接收端绑定该组播IP，并注册该端口</li><li>DatagramSocket的子类MulticastSocket::joinGroup负责绑定组播IP</li></ul></li></ul><h3 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h3><ul><li><code>java.net.Socket</code> 基于TCP协议<ul><li>Socket(host, port)</li><li>Socket::getOutputStream()</li><li>Socket::getInputStream()</li></ul></li><li>ServerSocket 服务端<ul><li>ServerSocket(port)</li><li>ServerSocket::accept() 等待接收客户端的Socket通信连接，连接成功返回Socket对象与客户端建立端到端通信</li></ul></li><li>服务端一般使用循环，负责接收客户端Socket管道连接,每接收到一个Socket管道后分配一个独立的线程负责处理它(线程池技术)</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><ul><li><strong>Error</strong>：系统级别问题、JVM退出等，代码无法控制</li><li><strong>Exception</strong>：java.lang包下，称为异常类，表示程序本身可以处理的问题<ul><li><strong>RuntimeException</strong>及其子类：运行时异常，编译阶段不会报错。如空指针、数组索引越界等</li><li>除<strong>RuntimeException</strong>之外的所有异常：编译时异常，编译期必须处理，也称受检异常。如日期格式化异常</li></ul></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.svg" class="" title="alt 异常体系"><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><strong>throws</strong>：用在方法声明上，将方法内部出现的异常抛出给调用者</li><li><strong>try-catch</strong>：监视捕获异常，在方法内部自己处理，程序继续执行</li><li><strong>try-catch-finally</strong>: 除非JVM崩溃，否则必须执行finally块</li><li><strong>try-with-resource</strong>: 自动关闭资源(Closeable&#x2F;AutoCloseable)，即使出现异常</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>定义异常继承 Exception &#x2F; RuntimeException</li><li>重写构造器</li><li>在出现异常的地方主动 throw 自定义异常对象</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>又称Java标注，对Java中类、方法、变量做标记，然后进行特殊处理</p><ul><li><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Book &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">100</span>;<br>    String[] author();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>元注解：对注解类的注解</p><ul><li>@Target：约束注解标记的位置<ul><li>ElementType.TYPE 类，接口</li><li>ElementType.FIELD 成员变量</li><li>ElementType.METHOD 成员方法</li><li>ElementType.PARAMETER 方法参数</li><li>ElementType.CONSTRUCTOR 构造器</li><li>ElementType.LOCAL_VARIABLE 局部变量</li></ul></li><li>@Retention：约束注解的存活范围<ul><li>RetentionPolicy.SOURCE 注解只作用在源码阶段，生成的字节码文件中不存在</li><li>RetentionPolicy.CLASS 默认值，注解作用在源码阶段，字节码文件阶段，运行阶段不存在</li><li>RetentionPolicy.RUNTIME 注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li></ul></li></ul></li><li><p>注解解析</p><ul><li>Annotation: 注解对象</li><li>AnnotatedElement: 注解解析相关方法的接口，所有类成分Class&#x2F;Method&#x2F;Field&#x2F;Constructor均已实现<ul><li>getDeclaredAnnotations()</li><li>getDeclaredAnnotation(class)</li><li>isAnnotationPresent(class)</li></ul></li><li>解析技巧：注解在哪个成分上，就先拿哪个成分对象</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>对业务功能进行代理，类似AOP编程</li><li>Proxy::newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li><li>InvocationHandler::invoke(Object proxy, Method method, Object[] args)</li><li>优点：<ul><li>非常灵活，支持任意接口类型做代理，也可以直接为接口本身做代理</li><li>可以为被代理对象的所有方法做代理</li><li>不改变方法源码的情况下，实现对功能的增强</li><li>简化编程，提高可扩展性，提高了开发效率</li></ul></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li>解决浮点型运算精度失真问题</li><li>禁止使用BigDecimal(double)把double值转换为BigDecimal对象，依然存在精度损失风险</li><li>推荐使用<code>BigDecimal(String)或BigDecimal.valueOf(Double)</code>的构造方式，自动对精度进行截断处理</li><li>BigDecimal只是手段，目的是Double</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举类都继承了 <code>java.lang.Enum</code></li><li>枚举都是最终类，不可以被继承</li><li>构造器都是私有，对外不能创建对象</li><li>枚举类相当于多例模式<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8F%8D%E7%BC%96%E8%AF%91.svg" class="" title="alt 枚举类型反编译"><center>枚举类型反编译</center></li></ul><h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><ul><li>Date 日期对象<ul><li>Date() </li><li>setTime(), getTime() 时间毫秒值</li></ul></li><li>SimpleDateFormat<ul><li>new SimpleDateFormat(pattern)</li><li>format(Date&#x2F;time): Date&#x2F;time -&gt; String</li><li>parse(dateStr): String -&gt; Date</li></ul></li><li>Calendar 系统此刻日历对象<ul><li>Calendar.getInstance()</li></ul></li></ul><p>JDK 8新增日期时间API：</p><ul><li>LocalDate 不包含具体时间的日期</li><li>LocalTime 不包含日期的时间</li><li>LocalDateTime 包含日期和时间</li><li>Instant 时间戳</li><li>DateTimeFormatter 时间格式化和解析</li><li>Duration 计算两个时间间隔</li><li>Period 计算两个日期间隔</li><li>ChronoUnit 针对特定时间单位测量时间差</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>Pattern.complie(regex)</li><li>pattern.matcher(String)</li><li>matcher.find()</li><li>matcher.group()</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><p>优势：可以将系统执行的信息选择性的记录到指定的位置，如控制台、文件、数据库等。并且随时以开关的形式控制是否记录，灵活性好</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB.svg" class="" title="alt 日志体系"></li><li><p>Logback 模块</p><ul><li>logback-core: 核心模块</li><li>logback-classic: log4j 改良版本，完整实现 slf4j API</li><li>logback-access: 与Tomcat和Jetty等Servlet容器集成，提供HTTP访问日志功能</li></ul></li><li><p>使用：</p><ul><li>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR，默认DEBUG</li><li>配置文件<code>logback.xml</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;Test.class&quot;</span>);<br>LOGGER.debug(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.info(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.trace(<span class="hljs-string">&quot;a = &quot;</span> + a);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>针对最小的功能单元，即Java中的方法，编写测试代码</li><li>传统测试方法的缺陷：只能测试main，方法之间相互影响，无法得到测试结果的报告，无法实现自动化测试</li><li>Junit单元测试框架<ul><li>优点：可以灵活选择测试方法，自动生成测试报告</li><li>使用：<ul><li>导入JUnit</li><li>编写公共的，无参数无返回值测试方法，并加上@Test注解</li><li>允许测试</li></ul></li><li>测试注解：@Before, @After, @BeforeClass, @AfterClass, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll</li></ul></li></ul><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li>可扩展标记语言（eXtensible Markup Language），一种数据表示格式</li><li>纯文本，默认UTF-8编码，可嵌套，经常用于网络传输、配置文件</li><li>XML格式：<ul><li>第一行文档声明 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</code></li><li>特殊字符：小于 &amp;lt;  大于 &amp;gt; 和号 &amp;amp; 单引号 &amp;apos; 引号 &amp;quot;</li><li>解释器忽略文本：&lt;![CDATA[…内容…]]&gt;</li></ul></li><li>XML约束：限定xml文件中的标签以及属性规则<ul><li>DTD <code>&lt;!DOCTYPE 根标签名 PUBLIC/SYSTEM &quot;dtd文件名&quot; &quot;dtd文件位置&quot;&gt;</code> 不能约束具体数据类型</li><li>SCHEME <code>&lt;根标签 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xxx.com&quot; xsi:schemaLocation=&quot;http://xxx.xsd&quot;&gt;</code> 约束更严谨</li></ul></li><li>XML解析<ul><li>SAX解析：一行一行解析</li><li>DOM解析：整个文件解析，如JAXP、JDOM、<strong>Dom4j</strong>、jsoup</li><li>Dom4j API:<ul><li>List<Element> elements() 得到当前元素下所有子元素</li><li>List<Element> elements(String name) 得到当前元素下指定名字的子元素返回集合</li><li>Element element(String name) 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</li><li>String getName() 得到元素名字</li><li>String attributeValue(String name) 通过属性名直接得到属性值</li><li>String elementText(子元素名) 得到指定名称的子元素的文本</li><li>String getText() 得到文本</li></ul></li></ul></li><li>XML检索——XPath<ul><li>使用路径表达式来定位元素节点或属性节点</li><li>基于dom4j和jaxen</li><li>selectSingleNode(exp), selectNodes(exp)</li><li>四大检索方案：<ul><li>绝对路径：<code>/根元素/子元素/孙元素</code> 从根元素开始，一级一级向下查找，不能跨级</li><li>相对路径: <code>./子元素/孙元素</code> 从当前元素开始，一级一级向下查找，不能跨级</li><li>全文检索: <code>//name</code> <code>//father/son</code> <code>//father//grandson</code> 直接全文搜索所有的name元素并打印</li><li>属性查找: <code>//@attr</code> <code>//ele[@attr]</code> <code>//ele//[@attr=val]</code> 查找属性&#x2F;含有指定值的属性的元素</li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>工厂模式：<ul><li>对象通过工厂的方法创建返回</li><li>可以为该对象进行加工和数据注入，实现类与类之间的解耦操作</li></ul></li><li>装饰模式<ul><li>创建新类，包装原始类</li><li>可以在不改变原有类的基础上，动态扩展一个类的功能</li></ul></li></ul><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><ul><li>JVM内存区：<strong>虚拟机栈、堆、方法区</strong>、本地方法栈、程序计数器<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/Java%E5%86%85%E5%AD%98%E5%8C%BA.svg" class="" title="alt Java内存区"></li></ul><ul><li>基本内存分配：<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" class="" title="alt 基本内存分配"><ul><li>方法区存放加载的类信息</li><li>栈(栈帧): 局部变量表</li><li>堆: new出来的对象实例 （如数组）</li></ul></li></ul><ul><li><p>两个引用指向同一对象</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1.png" class="" title="alt 两个引用指向同一对象"><ul><li>栈内存中两个引用的地址值指向堆中同一块内存区</li><li>利用引用修改堆中数据后，所有引用指向该内存区域的数据都会反映出来</li></ul></li></ul><ul><li>Java参数传递机制<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 基本类型参数传递"><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 引用类型参数传递"><ul><li>无论基本类型还是引用类型，都是值传递</li><li>基本类型传递的是本身的数据值</li><li>引用类型的值是指向堆内存的某个地址</li></ul></li></ul><ul><li>两个对象内存图;<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 两个类对象内存图"><ul><li>方法区保存了类的信息，包括类名、成员变量、成员方法等</li><li>堆中实际类对象的成员方法存的是方法区里类的成员方法引用</li></ul></li></ul><ul><li><p>集合存储内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 集合存储内存图"><ul><li>数组&#x2F;集合中存储的元素并不是对象本身，而是对象的地址</li></ul></li><li><p>静态常量内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 静态常量内存图"></li><li><p>子类继承内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 子类继承内存图"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows平台搭建Dash系统</title>
    <link href="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows平台搭建Dash系统"><a href="#Windows平台搭建Dash系统" class="headerlink" title="Windows平台搭建Dash系统"></a>Windows平台搭建Dash系统</h1><h2 id="1-Dash简介"><a href="#1-Dash简介" class="headerlink" title="1. Dash简介"></a>1. Dash简介</h2><p><strong>Dynamic Adaptation Streaming over HTTP (Dash):</strong><br>HTTP上的动态自适应视频流技术，它将一个视频划分为许多个segment，每个segment有不同质量的副本，能够在播放时根据用户当前的网络状况选择最佳的码率，减少卡顿。详情: <a href="https://dashif.org/">https://dashif.org/</a></p><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2. 配置环境"></a>2. 配置环境</h2><ul><li>环境<ul><li>系统：Windows 10</li><li>客户端：Chrome</li></ul></li><li>工具 (安装好并将<code>bin</code>目录加入系统环境变量)<ul><li>服务器：Nginx <a href="https://www.cnblogs.com/taiyonghai/p/9402734.html">安装教程</a></li><li>编解码器：<a href="https://github.com/BtbN/FFmpeg-Builds/releases">FFmpeg</a></li><li>视频切片工具：<a href="https://www.bento4.com/downloads/">Bento4</a></li><li>播放器：<a href="https://github.com/Dash-Industry-Forum/dash.js">dash.js</a></li></ul></li><li>视频<ul><li>Big Buck Bunny   可以去 <a href="https://download.blender.org/peach/bigbuckbunny_movies/">https://download.blender.org/peach/bigbuckbunny_movies/</a> 下载</li></ul></li></ul><h2 id="3-对视频进行编码"><a href="#3-对视频进行编码" class="headerlink" title="3. 对视频进行编码"></a>3. 对视频进行编码</h2><ul><li>目标编码格式：H.264&#x2F;AVC</li><li>目标分辨率级别：<ul><li>1920×1080 (1080p)</li><li>1280×720 (720p)</li><li>854×480 (480p)</li><li>640×360 (360p)</li><li>256×144 (144p)</li></ul></li><li>编码命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1920x1080 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1920x1080.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1280x720 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1280x720.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 896x504 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_896x504.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 640x360 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_640x360.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 256x144 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_256x144.mp4<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>：输入文件名</li><li><code>-s</code>：输出的分辨率</li><li><code>-c:v libx264</code>：将视频编码为H.264&#x2F;AVC格式</li><li><code>-keyint_min 48 -g 48 -sc_threshold 0</code>：固定GOP长度为48帧(即2s，具体由帧率决定)。这里如果没有这个参数后面bento4切分时会报错，具体原因见 <a href="https://blog.csdn.net/LvGreat/article/details/103540007">FFmpeg的GOP（I帧）对齐问题</a></li><li><code>-an</code>：不对音频进行编码，dash中音视频分开编码</li><li>最后是输出文件名</li></ul></li></ul><p> 可以写个bat，扔那边慢慢跑，视频小的话几十秒就好了。完成后：<br> <img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90.png" class="" title="alt 视频编码完成"><br>​</p><h2 id="4-视频切片"><a href="#4-视频切片" class="headerlink" title="4. 视频切片"></a>4. 视频切片</h2><ol><li><p>使用bento4的<code>mp4fragment</code>对视频进行fragment</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4fragment --fragment-duration 2000 BBB_1920x1080.mp4 fragmented_1080p.mp4<br>mp4fragment --fragment-duration 2000 BBB_1280x720.mp4 fragmented_720p.mp4<br>mp4fragment --fragment-duration 2000 BBB_896x504.mp4 fragmented_480p.mp4<br>mp4fragment --fragment-duration 2000 BBB_640x360.mp4 fragmented_360p.mp4<br>mp4fragment --fragment-duration 2000 BBB_256x144.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>  <code>--fragment-duration</code>：指定fragment时长为2s</p></li><li><p>使用<code>mp4dash</code>对已fragment的视频进行切片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4dash fragmented_1080p.mp4 fragmented_720p.mp4 fragmented_480p.mp4 fragmented_360p.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>成后目录中会自动生成out文件夹，里面有mpd文件和切分的segment</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E5%AE%8C%E6%88%90.png" class="" title="alt 视频切片完成"></li></ol><h2 id="5-编写简易网页播放器"><a href="#5-编写简易网页播放器" class="headerlink" title="5. 编写简易网页播放器"></a>5. 编写简易网页播放器</h2><p>参考：<a href="https://github.com/Dash-Industry-Forum/dash.js%E2%80%8B">https://github.com/Dash-Industry-Forum/dash.js​</a></p><p>将out里面的video文件夹和<code>stream.mpd</code>放到nginx的html文件夹里，下载<code>dash.all.min.js</code>也放入html文件夹中。</p><p>具体的目录结构可以自定义。我这边的目录如下：</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/demo%E7%9B%AE%E5%BD%95.png" class="" title="alt Demo目录"><p>DashJS.html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dash.js Rocks<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">            <span class="hljs-selector-tag">video</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>;</span><br><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">360px</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;videoPlayer&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dash.all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;./stream.mpd&quot;</span>;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> player = dashjs.<span class="hljs-title class_">MediaPlayer</span>().<span class="hljs-title function_">create</span>();</span><br><span class="language-javascript">                player.<span class="hljs-title function_">initialize</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#videoPlayer&quot;</span>), url, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">            &#125;)();</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="6-配置Nginx服务器"><a href="#6-配置Nginx服务器" class="headerlink" title="6. 配置Nginx服务器"></a>6. 配置Nginx服务器</h2><p>配置访问控制，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨源资源共享（CORS） - HTTP | MDN</a></p><p>修改Nginx的conf下的nginx.conf文件中的server段，主要是加入location &#x2F;file那一块</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">server <span class="hljs-punctuation">&#123;</span><br>    listen       <span class="hljs-number">8800</span>;<br>    server_name  localhost;<br><br>    location / <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>        index  index.html index.htm;<br>    <span class="hljs-punctuation">&#125;</span><br>    location /file <span class="hljs-punctuation">&#123;</span><br>        if ($request_method = &#x27;OPTIONS&#x27;) <span class="hljs-punctuation">&#123;</span><br>            add_header Access-Control-Allow-Origin $http_origin;<br>            add_header Access-Control-Allow-Methods             <br>            $http_access_control_request_method;<br>            add_header Access-Control-Allow-Credentials <span class="hljs-literal"><span class="hljs-keyword">true</span></span>;<br>            add_header Access-Control-Allow-Headers <br>            $http_access_control_request_method;<br>            add_header Access-Control-Max-Age <span class="hljs-number">1728000</span>;<br>            return <span class="hljs-number">204</span>;<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><br>    #error_page  <span class="hljs-number">404</span>              /<span class="hljs-number">404.</span>html;<br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>验证Nginx配置是否正确，正确后启动Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br>start nginx<br></code></pre></td></tr></table></figure><h2 id="7-验证"><a href="#7-验证" class="headerlink" title="7. 验证"></a>7. 验证</h2><p>最后打开 <a href="http://localhost:8800/DashDemo/DashJS.html">http://localhost:8800/DashDemo/DashJS.html</a> 验证是否成功即可</p><p>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://codeleading.com/article/26092631381/#5_Bento4_90">DSAH视频系统（服务器&amp;播放器）搭建 - 代码先锋网</a></li><li>[2] <a href="https://blog.csdn.net/OCTODOG/article/details/79007302">Nginx 搭建DASH服务器_山城过雨的博客-CSDN博客</a></li><li>[3] <a href="https://www.instructables.com/Making-Your-Own-Simple-DASH-MPEG-Server-Windows-10/">Making Your Own Simple MPEG-DASH Server (Windows 10) : 12 Steps - Instructables</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Dash</tag>
      
      <tag>视频流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
