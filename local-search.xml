<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 并发</title>
    <link href="/2022/11/20/Java-%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/11/20/Java-%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-走入并行世界"><a href="#第-1-章-走入并行世界" class="headerlink" title="第 1 章 - 走入并行世界"></a>第 1 章 - 走入并行世界</h1><h2 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h2><ul><li>同步：一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li><li>异步：一旦开始，调用就会立即返回，调用者可以继续后续的操作</li></ul><ul><li>并发：多个任务交替执行</li><li>并行：多个任务同时执行</li></ul><ul><li>临界区：表示一种公共资源或共享数据，可以被多个线程使用，但同一时间只能有一个线程使用。一旦临界区资源被占用，其它线程想要使用就必须等待</li></ul><ul><li>阻塞：一个线程占用了临界区资源，其它线程必须等待，导致线程挂起，就是阻塞</li><li>非阻塞：没有一个线程可以防碍其他线程执行，所有线程都会尝试不断前进</li></ul><p>多线程的活跃性问题：</p><ul><li>死锁：多个线程都占有其它线程需要的资源，且都不释放，从而没有一个线程可以同时拿到所有资源，造成所有线程都进入等待</li><li>饥饿：某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行</li><li>活锁：多个线程在竞争资源时，都主动释放给其它线程使用，导致资源不断在两个线程间跳动，从而没有一个线程可以同时拿到所有资源</li></ul><h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><ul><li>阻塞：其它线程释放资源之前，当前线程无法继续执行（悲观）</li><li>无饥饿：对于公平锁，所有线程遵守先进先出的原则，就不会产生饥饿</li><li>无障碍：任何线程都可以进入临界区，但是一旦检测到冲突就需要回滚（乐观）</li><li>无锁：无锁并行都是无障碍的，任何线程都可以进入临界区，且必然有一个线程可以在有限步内完成操作并离开。通常包含一个无限循环尝试竞争</li><li>无等待：要求所有线程在有限步内完成操作，分为有界无等待和与线程数无关的无等待。典型的如RCU（Read Copy Update），对读不加控制，修改只针对副本，并在合适的时机写回</li></ul><h2 id="并行加速定律"><a href="#并行加速定律" class="headerlink" title="并行加速定律"></a>并行加速定律</h2><pre><code class="hljs">加速比 = 优化前耗时 / 优化后耗时</code></pre><ol><li>Amdahl 定律<br>并行优化的效果取决于CPU数量，以及系统中的串行化代码的比例。CPU数量越多，串行化比例越低，优化效果越好。仅增加CPU数量而不降低串行化比例，无法提高系统性能。</li><li>Gustafson 定律<br>只要增加处理器，就能获得更快的速度。如果可被并行化的代码所占比例足够大，那么加速比就能随着处理器数量线性增长。</li></ol><h2 id="回到Java：JMM"><a href="#回到Java：JMM" class="headerlink" title="回到Java：JMM"></a>回到Java：JMM</h2><ul><li>原子性：<ul><li>一个操作不可中断</li><li>对于32位JVM，long和double两个64位数据的读写是不保证原子性的</li></ul></li><li>可见性：<ul><li>一个线程修改了某个共享变量，其它线程是否能够立即得知这个修改。</li><li>原因在于缓存优化、硬件优化、指令重排、编辑器的优化等</li><li>在一个线程中观察另一个线程的变量，它们的值是否能观察到、何时能观察到是没有保证的</li></ul></li><li>有序性：<ul><li>程序在执行时可能会进行指令重排，于原指令的顺序未必一致</li><li>原因在于一条指令的执行，对于CPU来说需要分为多个步骤依次执行，为了提高CPU效率，使用了流水线技术。这样就可能某个步骤需要等另一指令的某个步骤先完成，从而产生中断。为了尽可能减少流水线的中断，因此需要做指令重排</li><li>不能重排的指令：Happen-Before规则 保证指令重排不会破坏原有的语义<ul><li>程序顺序原则：在一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写先于读发生，保证了volatile变量的可见性</li><li>锁规则：unlock必然发生在随后的lock前</li><li>传递性：A先于B，B先于C，则A必先于C</li><li>线程<code>start()</code>方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结<code>Thread.join()</code></li><li>线程的中断<code>interrupt()</code>先于被中断线程的代码</li><li>对象构造函数的执行、结束先于<code>finalize()</code></li></ul></li></ul></li></ul><hr><h1 id="第-2-章-Java并行程序基础"><a href="#第-2-章-Java并行程序基础" class="headerlink" title="第 2 章 - Java并行程序基础"></a>第 2 章 - Java并行程序基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>进程是程序的基本执行实体，是线程的容器</li><li>线程是轻量级进程，是程序执行的最小单位</li><li>线程的切换和调度的成本远远小于进程</li><li>线程的状态：<ul><li>NEW：刚刚创建，线程还没开始执行</li><li>RUNNABLE：线程正在执行，拥有所需的一切资源</li><li>BLOCKED：遇到sychronized同步块暂停执行，进入同步队列(尝试获取锁但失败的线程)，直到获得请求的锁</li><li>WAITING：无限等待，等待一些特殊事件，如notify(), join()</li><li>TIMED_WAITING：有限等待</li><li>TERMINATED：线程执行完毕</li></ul></li></ul><pre><code class=" mermaid">stateDiagram  NEW --&gt; RUNNABLE: 启动  RUNNABLE --&gt; BLOCKED: synchronized  BLOCKED --&gt; RUNNABLE: synchronized  RUNNABLE --&gt; WAITING: wait()  WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TIMED_WAITING: wait()  TIMED_WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TERMINATED: 结束</code></pre><h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><ul><li><p>新建线程：</p><ul><li>extends Thread()::run()</li><li>implements Runnable::run()</li><li>new Thread(Runnable)::start()</li></ul></li><li><p>终止线程：</p><ul><li>Thread::stop(), 不推荐使用。因为会立即终止线程，并释放持有的锁，可能破坏对象一致性</li></ul></li><li><p>线程中断：</p><ul><li>Thread::interrupt() 中断线程</li><li>Thread::isInterrupted() 判断是否中断</li><li>static boolean Thread.interrupted() 判断是否中断，并清除当前中断状态</li><li>Thread::sleep()方法由于中断抛出异常时，会清除中断标志位</li></ul></li><li><p>线程等待</p><ul><li>Object::wait() 对象所在线程停止运行，释放CPU和锁资源，进入等待队列</li><li>Object::notify() 随机唤醒一个等待队列中的线程进入同步队列</li><li>Object::notifyAll() 唤醒等待队列中的的所有线程进入同步队列</li><li>工作原理：<ul><li>每个Object拥有一个等待该对象锁的<code>等待队列</code>，和一个尝试获取锁但失败的线程<code>同步队列</code></li><li>wait()和notify()执行前会先获取Object对象的监视器，执行后释放监视器。因此调用必须包含在对应的synchronized块中</li><li>wait()会主动释放目标对象锁，而sleep()不会释放锁资源，仅让出CPU，且不能被唤醒</li><li>notify()不会立即释放CPU和锁资源，而是等同步代码执行完毕才释放</li></ul></li></ul></li><li><p>线程挂起和恢复 – deprecated</p><ul><li>Thread::suspend() 挂起线程且不释放任何锁资源。挂起的线程竟然属于Runnable状态</li><li>Thread::resume()</li></ul></li><li><p>等待线程结束和谦让</p><ul><li>Thread::join( [millis] ) 无限&#x2F;有限等待，直到目标线程，也就是调用的对象线程执行完毕</li><li>Thread::yield() 让出当前CPU</li><li>join()方法底层是通过wait()实现的，调用的线程执行完毕后会执行notifyAll()唤醒所有等待队列的线程进入同步队列</li></ul></li></ul><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul><li>volatile关键字告诉JVM,该变量极有可能会被某些程序或者线程修改</li><li>volatile有助于操作的原子性,可见性,有序性</li><li>但volatile不能代替锁，不保证一些复合操作的原子性</li></ul><h2 id="线程组-ThreadGroup"><a href="#线程组-ThreadGroup" class="headerlink" title="线程组 - ThreadGroup"></a>线程组 - ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">tg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>( <span class="hljs-string">&quot;PrintGroup&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T2&quot;</span>);<br>t1.start();<br>t2.start();<br>System.out.println(tg.activeCount()); <span class="hljs-comment">// 获得活动线程总数</span><br>tg.list();  <span class="hljs-comment">//打印线程组中所有线程</span><br></code></pre></td></tr></table></figure><h2 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程 - Daemon"></a>守护线程 - Daemon</h2><ul><li>完成一些系统性服务，例如GC线程、JIT线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonT</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 必须在守护线程开始之前设置，否则当作普通的用户线程执行</span><br>t.start();  <span class="hljs-comment">// 只要主线程结束，整个程序就会结束，不管守护线程是否结束</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>Java的线程优先级从低到高为1-10</li><li>Thread::setPriority(int)</li><li>优先级的后果不可预测，无法精确控制。因此如果要求严格，仍需要自己在应用层解决线程调度问题</li></ul><h2 id="线程安全-Synchronized"><a href="#线程安全-Synchronized" class="headerlink" title="线程安全 - Synchronized"></a>线程安全 - Synchronized</h2><ul><li>对同步的代码加锁，使得每次只有一个线程进入同步块，从而保证现成的安全性</li><li>如果指定加锁对象，则进入同步代码前要先获得指定对象的锁</li><li>如果作用于实例方法，相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>如果作用于静态方法，相当于对当前类加锁，进入同步代码前要获得当前类的锁</li><li>synchronized还可以保证线程间的可见性和有序性（使多线程串行执行）</li></ul><h2 id="并发下的隐蔽错误"><a href="#并发下的隐蔽错误" class="headerlink" title="并发下的隐蔽错误"></a>并发下的隐蔽错误</h2><ul><li>如非线程安全的ArrayList, HashMap, Integer等等</li><li>jps查看系统运行的Java程序，jstack pid 打印指定java进程的内部线程及其堆栈</li></ul><hr><h1 id="第3章-JDK并发包"><a href="#第3章-JDK并发包" class="headerlink" title="第3章 - JDK并发包"></a>第3章 - JDK并发包</h1><h2 id="同步控制工具"><a href="#同步控制工具" class="headerlink" title="同步控制工具"></a>同步控制工具</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote><p>可重入锁，性能和synchronized相当，但使用更灵活，提供额外的高级功能</p></blockquote><ul><li>ReentrantLock::lock() 获得锁，如果锁已经被占用，则等待</li><li>ReentrantLock::lock(boolean fair) 公平锁，维护一个等待队列，先来后到</li><li>ReentrantLock::lockInterruptibly() 获得锁，但优先响应中断</li><li>ReentrantLock::tryLock() 尝试获得锁，不等待直接返回。如果成功返回true，失败返回false。</li><li>ReentrantLock::tryLock(time, TimeUnit) 在给定时间内尝试获取锁</li><li>ReentrantLock::unlock 释放锁</li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><blockquote><p>与重入锁关联的wait &#x2F; notify机制</p></blockquote><ul><li>Lock::newCondition()</li><li>Condition::await() 使当前线程进入等待队列，同时释放当前锁。要求先获得相关锁</li><li>Condition::awaitUninterruptibly() 使当前线程进入等待队列，但等待时不响应中断。要求先获得相关锁</li><li>Condition::signal() &#x2F; signalAll() 唤醒一个&#x2F;所有等待队列中的线程。要求先获得相关锁</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote><ol><li>基于许可的多线程控制<br>  为每个访问共享区间的线程派发一个许可，拿到许可的线程才能进入共享区间活动。完成任务离开共享区间时，必须归还许可，以确保后续的线程可以正常取得许可。如果许可用完，则线程必须先等待。</li><li>排他锁和共享锁<br>  排他模式下，只有一个线程可以访问共享变量。而共享模式下，则允许多个线程同时访问共享变量。例如，重入锁是排他的，信号量是共享的。</li></ol></blockquote><p>信号量是对锁的扩展，允许多个线程同时访问共享资源</p><ul><li>Semaphore(int permits, [boolean fair]) 构造信号量，指定准入数，可选是否公平</li><li>Semaphore::acquire(), Semaphore::acquireUninterruptibly()</li><li>Semaphore::tryAcquire(), Semaphore::tryAcquire(timeout, TimeUnit)</li><li>Semaphore::release()</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><blockquote><p>JDK5提供的读写分离锁，可以有效地减少锁竞争，提升系统性能。</p></blockquote><ul><li>读写锁的访问约束：<ul><li>读与读不互斥</li><li>读与写互斥</li><li>写与写互斥</li></ul></li><li>API:<ul><li>实现类：ReentrantReadWriteLock()</li><li>ReadWriteLock::readLock(), ReadWriteLock::writeLock()</li><li>锁操作和ReentrantLock基本一致</li></ul></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote><p>倒计数器，Latch：门闩。通常用来控制线程等待，让某一个线程等倒计数结束再开始执行</p></blockquote><ul><li>CountDownLatch(int count) 指定数量的线程完成任务后，等待在Latch上的线程才能继续执行</li><li>CountDownLatch::countDown() 通知Latch一个线程已经完成了任务，计数器减一</li><li>CountDownLatch::await() 设置Latch阻止线程继续执行，直到指定数量的线程执行至此</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote><p>循环栅栏，每若干个线程任务执行完，调用一次指定的动作</p></blockquote><ul><li>CyclicBarrier(int parties, Runnable barrierAction) 每若干个任务完成，执行一次barrierAction</li><li>CyclicBarrier::await() 设置Barrier阻止线程继续执行，直到指定数量的线程执行至此</li><li>BrokenBarrierException 表示当前Barrier已经破损，可能无法等待所有线程到齐。例如一个线程被中断，其它线程就会收到该异常</li></ul><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote><p>线程阻塞工具，可以在线程内任意位置让线程阻塞，不需要先获得对象锁，也不抛出InterruptedException，弥补了suspend&#x2F;resume导致线程无法继续执行的情况</p></blockquote><ul><li>static LockSupport::park(), parkNanos(), parkUntil() (有限)阻塞当前线程。支持中断响应，通过Thread.interrupted()获得中断标记</li><li>static LockSupport::unpark(thread) 类似信号量机制给予线程继续执行的许可，但许可数量仅为1</li></ul><h3 id="深度理解-AbstractQueuedSynchronizer"><a href="#深度理解-AbstractQueuedSynchronizer" class="headerlink" title="深度理解 AbstractQueuedSynchronizer"></a>深度理解 AbstractQueuedSynchronizer</h3><blockquote><p>重入锁、信号量内部各有一个AbstractQueuedSynchronizer的子类Sync。<br>Sync内部维护了一个同步等待队列，保存等待在这个锁上的线程，如lock()引起的等待。<br>还维护了一个条件变量等待队列，保存等待在条件变量上的等待变量，如Condition.await()引起阻塞的线程。<br>一个重入锁可以生成多个条件变量，因此可能有多个条件变量等待队列<br>AbstractQueuedSynchronizer是重入锁、信号量、读写锁等并发工具的核心</p></blockquote><h3 id="Guava-和-RateLimiter"><a href="#Guava-和-RateLimiter" class="headerlink" title="Guava 和 RateLimiter"></a>Guava 和 RateLimiter</h3><blockquote><p>Guava是Google的一个核心库，常用作项目的基础工具库。RateLimiter是其中的一个限流工具库<br>为了维持服务器的负载平稳，需要进行限流措施。普通的平均限流过于简单粗暴。经典的两种限流算法：</p><ul><li>漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先保存在缓存区内，然后再以固定的流速流出缓存区并加以处理。特点是无论外部请求压力如何，总是以固定的流速处理数据。漏桶容积和流出速率是该算法的两个重要参数。</li><li>令牌桶算法：桶中存放令牌，程序只有拿到令牌才能对请求进行处理。没有令牌则要么丢弃请求，要么等待可用令牌。该算法在单位时间产生一定量的令牌存入桶中，桶的容量有限，且令牌数不会超过桶的容量。</li></ul><p>Guava中的RateLimiter采用了令牌桶算法</p></blockquote><h2 id="线程复用-ThreadPool"><a href="#线程复用-ThreadPool" class="headerlink" title="线程复用 - ThreadPool"></a>线程复用 - ThreadPool</h2><blockquote><p>虽然与进程相比，线程是一种轻量级的工具，但其创建和销毁依然需要花费时间，线程过多容易导致创建和销毁的开销大于真实工作的时间，同时大量线程会抢占宝贵的内存资源，导致OOM，给GC带来压力。因此，对线程的使用需要掌握一个度。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为了避免系统频繁的创建和销毁线程，利用线程池技术对线程进行复用<br>线程池负责对线程进行控制和管理。其中有活跃线程，需要时直接拿来用，完成工作后不关闭，返回线程池，方便其它任务执行。</p><h3 id="JDK-Executor框架"><a href="#JDK-Executor框架" class="headerlink" title="JDK - Executor框架"></a>JDK - Executor框架</h3><ul><li>Executors 线程池工厂，返回ExecutorService (ThreadPoolExecutor) 对象，表示一个线程池<ul><li><code>newFixedThreadPool</code>: 返回一个固定线程数量的线程池。新任务提交时，若有空闲线程立即执行，否则暂存在任务队列中</li><li><code>newSingleThreadExecutor</code>: 返回只有一个线程的线程池</li><li><code>newCachedThreadPool</code>: 返回一个可调整线程数量的线程池。新任务提交时，优先使用可复用线程，否则创建新线程处理任务。所有线程完成后返回线程池，空闲线程有存活时间</li><li><code>newSingleThreadScheduledExecutor</code>: 返回一个ScheduledExecutorService对象，线程数量为1。用于实现延时、周期任务。如果中途任务出现异常，后续执行都会被中断。<ul><li>schedule(Runnable, delay, TimeUnit) 延迟执行任务</li><li>scheduleAtFixedRate(Runnable, initialDelay, period, TimeUnit) 固定速率循环执行任务。但必须等上一个任务执行完才会开始下一个</li><li>scheduleWithFixedDelay(Runnable, initialDelay, delay, TimeUnit) 上一个任务执行完间隔delay后开始下一个</li></ul></li><li><code>newScheduledThreadPool</code>: 返回一个ScheduledExecutorService对象，线程数量可指定</li></ul></li></ul><pre><code class=" mermaid">classDiagram  Executor &lt;|-- ExecutorService  &lt;&lt;interface&gt;&gt; Executor  Executor: + execute(Runnable)  &lt;&lt;interface&gt;&gt; ExecutorService  ExecutorService: + shutdown()  ExecutorService: + isTerminated()  ExecutorService: + submit()  ExecutorService: + ......()  AbstractExecutorService ..|&gt; ExecutorService  AbstractExecutorService &lt;|-- ThreadPoolExecutor  ThreadPoolExecutor: +ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</code></pre><h3 id="线程池内部实现-ThreadPoolExecutor"><a href="#线程池内部实现-ThreadPoolExecutor" class="headerlink" title="线程池内部实现 - ThreadPoolExecutor"></a>线程池内部实现 - ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,      <span class="hljs-comment">// 指定常驻线程数量</span><br>                   <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">// 指定允许的最大线程数量</span><br>                   <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">// 当线程数量超过corePoolSize后，多余的空闲线程的存活时间</span><br>                   TimeUnit unit,         <span class="hljs-comment">// keepAliveTime单位</span><br>                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">// 任务队列，保存被提交但尚未被执行的任务</span><br>                   ThreadFactory threadFactory,       <span class="hljs-comment">// 线程工厂，用于创建线程</span><br>                   RejectedExecutionHandler handler   <span class="hljs-comment">// 任务过多时的拒绝策略</span><br>                   )<br></code></pre></td></tr></table></figure><h4 id="任务队列-BlockingQueue"><a href="#任务队列-BlockingQueue" class="headerlink" title="任务队列 - BlockingQueue"></a>任务队列 - BlockingQueue</h4><p>指被提交但未执行的任务队列，一个BlockingQueue接口的对象，仅用于存放Runnable对象。常用的队列实现有：</p><ul><li><code>SynchronousQueue</code>: 直接提交的队列，没有容量，来一个任务执行一个，没有多余线程则执行拒绝策略</li><li><code>ArrayBlockingQueue</code>: 有界任务队列，构造时指定容量</li><li><code>LinkedBlockingQueue</code>: 无界任务队列，任务繁忙时会一直创建线程执行，直至资源耗尽</li><li><code>PriorityBlockingQueue</code>: 带有执行优先级的无界队列</li></ul><p>使用自定义线程池时，需要根据应用的具体情况，选择合适的并发队列为任务做缓冲。当线程资源紧张时，不同的并发队列对系统行为和性能的影响均不同。</p><pre><code class=" mermaid">graph LR  任务提交 -- 小于corePoolSize --&gt; end1(分配线程执行)  任务提交 -- 大于corePoolSize --&gt; 提交到等待队列 -- 成功 --&gt;等待执行  提交到等待队列 -- 失败 --&gt; 提交线程池 -- 已达到最大线程数 --&gt; 拒绝执行  提交线程池 -- 未达到最大线程数 --&gt; end2(分配线程执行)</code></pre><h4 id="拒绝策略-RejectedExecutionHandler"><a href="#拒绝策略-RejectedExecutionHandler" class="headerlink" title="拒绝策略 - RejectedExecutionHandler"></a>拒绝策略 - RejectedExecutionHandler</h4><p>指定当任务数量超过系统实际承载能力时的策略，通常是线程池中的线程已经用完，达到了最大线程数，排队队列也已满的情况。ThreadPoolExecutor提供了以下策略：</p><ul><li><code>AbortPolicy</code>: 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>CallersRunsPolicy</code>: 绕过线程池，由主线程直接调用任务的run()方法执行</li><li><code>DiscardOldestPolicy</code>: 抛弃队列中等待最久的任务，然后尝试再次提交当前任务</li><li><code>DiscardPolicy</code>: 丢弃且不抛异常</li></ul><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 - ThreadFactory"></a>线程工厂 - ThreadFactory</h4><p>ThreadFactory接口用来创建线程，其中仅有一个方法<code>Thread newThread(Runnable r);</code><br>通常使用<code>Executors.defaultThreadFactory()</code>即可</p><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>通过重写ThreadPoolExecutor中提供的接口对线程池进行控制</p><ul><li>ThreadPoolExecutor::beforeExecute(Thread t, Runnable r) 线程执行前</li><li>ThreadPoolExecutor::afterExecute(Runnable r, Throwable t) 线程执行后</li><li>ThreadPoolExecutor::terminated() 线程池销毁后</li></ul><h4 id="获取线程池的堆栈信息"><a href="#获取线程池的堆栈信息" class="headerlink" title="获取线程池的堆栈信息"></a>获取线程池的堆栈信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(...);<br><br><span class="hljs-comment">// 1. 用execute()替代submit()</span><br>pools.execute(task)<br><br><span class="hljs-comment">// 2. 使用Future (第五章)</span><br><span class="hljs-type">Future</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pools.submit(task)<br>result.get();<br><br><span class="hljs-comment">// 3. 扩展ThreadPoolExecutor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h3><blockquote><p>Java Concurrency in Practice 一书给出了估算线程池大小的公式：<br>$$<br>N_{threads} &#x3D; N_{cpu} \times U_{cpu} \times (1 + \frac{W}{C}<br>$$<br>其中，<br>$ N_{cpu} &#x3D; CPU的数量 $<br>$ U_{cpu} &#x3D; 目标CPU的使用率0-1之间 $<br>$ \frac{W}{C} &#x3D; 等待时间与计算时间的比率 $</p></blockquote><h3 id="Fork-x2F-Join-框架"><a href="#Fork-x2F-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><blockquote><p>Fork: 创建子线程，使得系统进程可以多一个执行分支<br>Join: 等待分支执行结束，获得最终结果<br>ForkJoinPool 可以优化多分支任务的执行，提高效率。例如多线程的负载均衡。但如果任务的划分层次很多且一直得不到返回值，可能出现性能严重下降，或导致栈溢出，引发异常。</p></blockquote><ul><li>ForkJoinPool::submit(ForkJoinTask&lt;T&gt;)  向ForkJoinPool线程池提交一个ForkJoinTask (支持 fork() &#x2F; join() 的任务)</li><li>ForkJoinTask两个子类：RecursiveAction 和 RecursiveTask, 前者没有返回值，后者可以携带返回值</li></ul><h3 id="Guava-线程池"><a href="#Guava-线程池" class="headerlink" title="Guava 线程池"></a>Guava 线程池</h3><ul><li>MoreExecutors::DirectExecutor 提供了一个简单的线程池实现。该线程池不创建额外线程，总是在当前线程中执行任务。便于使用统一的编码风格处理同步和异步调用，简化设计。</li><li>MoreExecutors::getExitingExecutorService() 将普通线程转为Daemon线程池，从而可以在程序执行外后，即便有线程池存在，也能结束线程</li><li>MoreExecutors还提供了对Future模式的扩展，见第5章</li></ul><h2 id="JDK-并发容器"><a href="#JDK-并发容器" class="headerlink" title="JDK 并发容器"></a>JDK 并发容器</h2><h2 id="JMH-性能测试"><a href="#JMH-性能测试" class="headerlink" title="JMH 性能测试"></a>JMH 性能测试</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板-Java</title>
    <link href="/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-Java/"/>
    <url>/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-Java/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题模板-Java"><a href="#算法题模板-Java" class="headerlink" title="算法题模板 - Java"></a>算法题模板 - Java</h1><span id="more"></span><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先写check函数，想一下check如何更新区间</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-comment">// 不用(left + right)/2 是为了防止整数溢出</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>; <br><span class="hljs-keyword">while</span>(left &lt; right)<br>&#123;<br><span class="hljs-keyword">if</span>(check(mid)) <br>            right = mid;<br><span class="hljs-keyword">else</span> <br>            left = mid + <span class="hljs-number">1</span>;<br>        mid = left + (right - left) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class=" mermaid">stateDiagram    java.util.Collection&amp;nbsp[I] --&gt; java.util.List&amp;nbsp[I]    java.util.List&amp;nbsp[I] --&gt; java.util.ArrayList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.LinkedList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.Vector&amp;nbsp[C]    java.util.Vector&amp;nbsp[C] --&gt; java.util.Stack&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Set&amp;nbsp[I]    java.util.Set&amp;nbsp[I] --&gt; java.util.HashSet&amp;nbsp[C]       java.util.Set&amp;nbsp[I] --&gt; java.util.SortedSet&amp;nbsp[I]    java.util.SortedSet&amp;nbsp[I] --&gt; java.util.TreeSet&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Queue&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.Deque&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.PriorityQueue&amp;nbsp[C]</code></pre><pre><code class=" mermaid">stateDiagram    java.util.Map&amp;nbsp[I] --&gt; java.util.SortedMap&amp;nbsp[I]    java.util.SortedMap&amp;nbsp[I] --&gt; java.util.TreeMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.Hashtable&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.HashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.LinkedHashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.WeakHashMap&amp;nbspC]</code></pre><p>[I]: 接口<br>[C]: 类<br>其中，Vector、Stack、HashTable线程安全，但已经基本不用了。</p><h3 id="数组-Array或ArrayList"><a href="#数组-Array或ArrayList" class="headerlink" title="数组 - Array或ArrayList"></a>数组 - Array或ArrayList</h3><ul><li>get和set操作时间上都是O(1)</li><li>add和remove都是O(N)</li><li>ArrayList添加元素不必考虑越界，超出容量时自动扩张</li><li>Vector相比于ArrayList，实现了线程安全，但效率较低</li></ul><h3 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 - LinkedList"></a>链表 - LinkedList</h3><ul><li>get和set操作时间上都是O(N)</li><li>add和remove都是O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;addd&quot;</span>);<span class="hljs-comment">//add</span><br>linkedList.set(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;s&quot;</span>); <span class="hljs-comment">//set，必须先保证 linkedList中已经有第0个元素</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span>  linkedList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//get</span><br>linkedList.contains(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//查找</span><br>linkedList.remove(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//删除</span><br><span class="hljs-comment">// 以上方法也适用于ArrayList</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="队列-LinkedList"><a href="#队列-LinkedList" class="headerlink" title="队列 - LinkedList"></a>队列 - LinkedList</h3><ul><li>LinkedList实现了Deque，可以作为双向&#x2F;单向队列</li><li>PriorityQueue实现了带优先级的队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 尾部入队，区别在于如果失败了，add方法会抛出一个IllegalStateException异常，而offer方法返回false</span><br>deque.offer(<span class="hljs-number">122</span>);<br>deque.add(<span class="hljs-number">122</span>);<br><span class="hljs-comment">// 头部出队，区别在于如果失败了，remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span><br><span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> deque.poll();<span class="hljs-comment">//删除第一个元素并返回</span><br>head = deque.remove();  <span class="hljs-comment">//删除第一个元素并返回</span><br><span class="hljs-comment">// 头部出队，区别在于如果失败了，element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span><br>head = deque.peek();    <span class="hljs-comment">//返回第一个元素，不删除</span><br>head = deque.element(); <span class="hljs-comment">//返回第一个元素，不删除</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="栈-ArrayDeque"><a href="#栈-ArrayDeque" class="headerlink" title="栈 - ArrayDeque"></a>栈 - ArrayDeque</h3><ul><li>Stack实现了后进先出，但继承自Vector，线程安全但效率低，因此不推荐使用</li><li>ArrayDeque实现了Deque，可以作为栈（但仍可以违反栈的单端操作规则）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>stack.push(<span class="hljs-number">12</span>);<span class="hljs-comment">//尾部入栈</span><br>stack.push(<span class="hljs-number">16</span>);<span class="hljs-comment">//尾部入栈</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> stack.pop();<span class="hljs-comment">//尾部出栈，并删除该元素</span><br>tail = stack.peek();<span class="hljs-comment">//尾部出栈，不删除该元素</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 - Deque"></a>双端队列 - Deque</h3><ul><li>ArrayDeque基于数组实现了双端队列</li><li>LinkedList基于双向链表实现了双端队列</li><li>另有两个线程安全的实现类：ConcurrentLinkedDeque, LinkedBlockingDeque<pre><code class=" mermaid">classDiagram    Queue &lt;|-- Deque    Deque ..|&gt; ArrayDeque    Deque ..|&gt; LinkedList    &lt;&lt;interface&gt;&gt; Queue    &lt;&lt;interface&gt;&gt; Deque</code></pre></li><li>Deque和Queue提供了两套API，一种抛出异常，另一种返回特殊值</li><li>Deque额外提供了First、Last后缀的方法。<table><thead><tr><th align="center">操作类型</th><th align="center">抛出异常</th><th align="center">返回特殊值</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td></tr><tr><td align="center">拾取</td><td align="center">element()</td><td align="center">peek()</td></tr></tbody></table></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建next数组</span><br><span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];<br>next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; p.length - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || p[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>        next[i] = j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br>i = <span class="hljs-number">0</span>;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-keyword">if</span> (j == p.length)<br>    <span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// Java 的 pop 写作 poll()</span><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(node.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            queue.add(node.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 复习</title>
    <link href="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-复习"><a href="#Java-SE-复习" class="headerlink" title="Java SE 复习"></a>Java SE 复习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>引用数据类型</li><li>基本数据类型 4大类8种 <em>(1-2-4-8)</em><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.svg" class="" title="alt Java基本数据类型"></li></ol><ul><li><p>自动类型转换：类型范围小的变量，可以直接赋值给类型范围大的变量</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 自动类型转换"><p><strong><code>byte --&gt; short (char) --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></p></li><li><p>在表达式中，小范围类型的变量会自动转换成较大范围的类型再运算</p><ul><li><strong><code>byte, short, char --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></li><li>最终结果类型由表达式中的最高类型决定</li><li>在表达式中，byte、short、char 直接转换成int类型参与运算的</li></ul></li><li><p>强制类型转换：可以强行将类型范围大的变量、数据赋值给类型范围小的变量</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 强制类型转换"><ul><li>强制类型转换可能造成数据(丢失)溢出</li><li>浮点型强转成整型，直接丢掉小数部分，保留整数部分返回</li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>短路逻辑运算符<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.svg" class="" title="alt 短路逻辑运算符"></li><li>逻辑与<code>&amp;</code>, 逻辑或<code>|</code>: 无论左边是false还是true，右边都要执行</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>代码块<code>&#123;&#125;</code>是类的5大成分之一(成员变量、构造器、方法、代码块、内部类)</li><li>静态代码块<ul><li><code>static&#123; &#125;</code></li><li>通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次</li><li>使用场景：在类加载的时候做一些静态数据初始化的操作，以便后续使用</li></ul></li><li>构造代码块(很少使用)<ul><li><code>&#123; &#125;</code></li><li>每次创建对象调用构造器前，都会执行该代码块</li><li>使用场景：初始化实例资源</li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>饿汉单例：</p><ul><li>在用类获取对象时，对象已经提前为你创建好了</li><li>设计步骤：定义类，构造器私有，定义静态变量存储单例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 属于类，与类一起仅加载一次</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;创建了一个对象&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉单例：</p><ul><li>在真正需要该对象时，才去创建一个对象(延迟加载对象)</li><li>设计步骤：定义类，构造器私有，定义静态变量存储对象，提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 类加载时初始为null</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance instance;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br>    <span class="hljs-keyword">return</span> instace;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>子类中访问成员满足就近原则，先找子类，子类没有找父类，父类没有报错</li><li>子类可以直接使用父类的静态成员(共享)</li><li>方法重写<ul><li>私有方法不能被重写。但可以定义相同签名的方法。</li><li>子类重写父类方法时，访问权限必须大于或等于父类 <code>缺省 &lt; protected &lt; public</code></li><li>子类不能重写父类的静态方法</li></ul></li><li>权限修饰符<ul><li><code>private &lt; 缺省 &lt; protected &lt; public</code><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4.svg" class="" title="alt 权限修饰符作用范围"></li></ul></li><li>final 修饰符<ul><li>修饰类，表明该类不能被继承</li><li>修饰方法，表明该方法不能被重写</li><li>修饰变量，表明该变量不能被重新赋值 <ul><li>基本类型 – 数据值不能改变</li><li>引用类型 – 存储的地址值不能改变(地址指向的对象可变)</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>一种约束规范</li><li>接口中的变量默认都是 <code>public static final</code></li><li>接口中的方法默认都是 <code>public abstract</code></li><li>JDK 8&#x2F;9 新增特性：<ul><li><ol><li>默认方法 - default修饰，自动public，需用接口实现类的对象来调用</li></ol></li><li><ol start="2"><li>静态方法 - static修饰，自动public，需用接口本身的接口名调用</li></ol></li><li><ol start="3"><li>私有方法 - private修饰，只能在 接口中被其它的方法访问</li></ol></li></ul></li><li>一个类同时继承父类和实现接口中的同名方法，优先使用父类的</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>访问特点：<ul><li>方法调用：编译看左边，运行看右边</li><li>变量调用：编译看左边，运行也看左边</li></ul></li><li>强制类型转换<ul><li>可以转换成真正的子类型，从而调用子类的独有功能</li><li>强转前尽量使用<code>instanceof</code>判断对象的真实类型再进行强转</li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1. 静态内部类"></a>1. 静态内部类</h3><ul><li><code>static</code>修饰，属于外部类这个类</li><li>创建格式：<code>Outer.Inner in = new Outer.Inner()</code></li><li>可以直接访问外部类静态对象</li><li>不可以直接访问外部类实例成员</li></ul><h3 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2. 成员内部类"></a>2. 成员内部类</h3><ul><li><code>无 static</code>修饰，属于外部类的对象</li><li>创建格式：Outer.Inner in &#x3D; new Outer().new Inner();</li><li>可以直接访问外部类静态对象</li><li>可以直接访问外部类实例成员(必须先有外部类对象，才能有成员内部类对象)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>          System.out.println(hearbeat); <span class="hljs-comment">// 78</span><br>          System.out.println(<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 110</span><br>          System.out.println(People.<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 150</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a>3. 局部内部类</h3><ul><li>放在方法、代码块、构造器等执行体中</li><li>类文件名：<code>Outer$NInner.class</code></li><li>鸡肋</li></ul><h3 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h3><ul><li>本质上是没有名字的局部内部类</li><li>既是一个类，也代表一个对象(new的类型的子类类型)，写出来就会产生一个匿名内部类的对象</li><li>可以直接作为对象传给方法</li><li>作用：方便创建子类对象，简化代码编写</li><li>创建格式：<code>new 类/抽象类名/接口( )&#123; 重写方法 &#125;</code></li></ul><ul><li>Lambda表达式：<ul><li>一个匿名函数，是一段可以传递的代码</li><li>用于简化函数式接口的匿名内部类的写法形式</li><li>函数式接口：有且仅有一个抽象方法的接口，通常加上@FunctionalInterface注解</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两种创建过程"><a href="#两种创建过程" class="headerlink" title="两种创建过程"></a>两种创建过程</h3><ol><li><p><code>&quot;&quot;</code>双引号创建字符串：会先判断常量池里面是否有相同的字符串，若有则直接指向该地址</p></li><li><p><code>new</code>关键字不论常量池中是否已经有该串，都会在堆中开辟新的内存空间存放该字符串</p></li></ol><h3 id="String-面试题"><a href="#String-面试题" class="headerlink" title="String 面试题"></a>String 面试题</h3><ul><li>问题：下列代码的运行结果是？<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E9%9D%A2%E8%AF%95%E9%A2%98.svg" class="" title="alt String面试题1"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先在堆的字符串常量池里创建&quot;abc&quot;的串，然后new再创建一个新串赋给s2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-comment">// 由于是双引号，直接指向常量池里的&quot;abc&quot;，因此这条语句没有创建新字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-comment">//false, s1指向的是常量池里的&quot;abc&quot;,s2指向的是堆里的&quot;abc&quot;</span><br>System.out.println(s1 == s2) <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s7</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qwe&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qw&quot;</span>;<br><span class="hljs-comment">// 只要不是直接双引号给出的字符串，都是非常量池的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s9</span> <span class="hljs-operator">=</span> s8 + <span class="hljs-string">&quot;e&quot;</span>;<br><span class="hljs-comment">// false, s7指向常量池的&quot;qwe&quot;,s9指向堆里的&quot;qwe&quot;</span><br>System.out.println(s7 == s9);  <br><span class="hljs-type">String</span> <span class="hljs-variable">s10</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s11</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;s&quot;</span> + <span class="hljs-string">&quot;d&quot;</span>;<br><span class="hljs-comment">// true, 编译优化机制：直接将&quot;a&quot;+&quot;s&quot;+&quot;d&quot;转换为&quot;asd&quot;，可以通过class文件确认</span><br><span class="hljs-comment">// 而s9由于s8是变量，不是字面量，因此没有优化</span><br>System.out.println(s10 == s11);<br></code></pre></td></tr></table></figure><h3 id="StringBuilder-拼接字符串"><a href="#StringBuilder-拼接字符串" class="headerlink" title="StringBuilder 拼接字符串"></a>StringBuilder 拼接字符串</h3><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt String拼接字符串"> <center>**String拼接字符串原理 - 每次拼接都会产生新的对象**</center><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/StringBuilder%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt StringBuilder拼接字符串"> <center>**StringBuilder拼接字符串原理 - 对同一个对象做修改**</center><ul><li>StringBuilder相当于一个容器，拼接、修改更加高效</li><li>StringBuilder只是个工具，最终的目的是得到String </li><li>StringBuffer是StringBuilder的多线程安全版，单线程下StringBuilder效率更高</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li><p><strong>List</strong>: 有序、可重复、有索引</p><ul><li><strong>ArrayList</strong>: 底层基于数组，默认长度10，存满时扩容1.5倍</li><li><strong>LinkedList</strong>: 底层基于双链表，可模拟栈&#x2F; 队列</li></ul></li><li><p><strong>Set</strong>: 无序、不重复、无索引</p><ul><li><strong>HashSet</strong>:<br>基于哈希表，底层采用<code>数组+链表+红黑树</code>实现。哈希表默认长度16，加载因子0.75，每次扩容2倍。相同哈希值的元素构成链表，新元素挂在老元素后面，当链表长度超过8自动转为红黑树。</li><li><strong>LinkedHashSet</strong>:<br>有序，底层<code>哈希表+双链表</code>记录存储顺序</li><li><strong>TreeSet</strong>:<br>自动排序，底层基于<code>红黑树</code>实现。必须指定比较规则 (比较器&#x2F;比较接口)</li></ul><p>如果希望 Set 认为两个内容一样的对象是重复的，必须重写对象的<code>hashCode()</code>和<code>equals()</code>方法</p></li></ul><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.svg" class="" title="alt 集合体系"><ul><li><p>遍历方式：</p><ol><li>迭代器 <code>Iterator::hasNext, Iterator::next</code></li><li><code>for-each 循环</code> 注意集合中存储的是对象的地址，因此修改第三方变量不会影响到集合中的元素</li><li>lambda表达式 <code>forEach(Consumer&lt;? super T&gt; action)</code></li></ol><p>遍历时直接用集合删除元素可能出现并发异常，可以通过迭代器删除</p></li><li><p><strong>Collections</strong> 集合工具类</p><ul><li>addAll</li><li>sort</li><li>shuffle</li></ul></li><li><p>不可变集合 <strong>ImmutableCollections</strong>：</p><ul><li>List.of</li><li>Set.of</li><li>Map.of</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><strong>HashMap</strong>: </p><ul><li>无序，不重复，无索引，值不作要求</li><li>基于哈希表、数组、红黑树实现</li><li>基于hashCode()和equals()保证键的唯一</li></ul></li><li><p><strong>LinkedHashMap</strong>：</p><ul><li>按键有序，不重复，无索引，值不作要求</li><li>基于哈希表、双链表记录存储顺序</li></ul></li><li><p><strong>TreeMap</strong>: </p><ul><li>自动按键排序 ，不重复，无索引，值不作要求</li><li>底层基于<code>红黑树</code>实现，必须指定键的比较规则(比较器&#x2F;比较接口)</li></ul></li><li><p><strong>Properties</strong></p><ul><li>本质是Map集合，一般代表一个属性文件，存储对象键值对，作为系统配置信息</li><li><code>store(Stream, comments), load(Stream), setProperty, getProperty</code></li></ul><p>Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据。</p></li></ul><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/map%E4%BD%93%E7%B3%BB.svg" class="" title="alt map体系"><ul><li>遍历方式：<ol><li>键找值：<code>map.keySet(), map.get(key)</code></li><li>键值对：<code>map.entrySet(), entry.getKey(), entry.getValue()</code></li><li>Lambda表达式：<code>map.forEach(BiConsumer&lt;K, V&gt;)</code></li></ol></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>自定义泛型类<br><code>public class MyGeneric&lt;T&gt; &#123;&#125;</code></li><li>自定义泛型方法<br><code>public &lt;T&gt; void MyFun(T t) &#123;&#125;</code></li><li>自定义泛型接口<br><code>public interface MyInterface&lt;E&gt; &#123;&#125;</code></li><li>泛型通配符<br>？可以在使用泛型时代表一切类型<br><code>? extends Class</code> 泛型上限，限定必须是Class或其子类<br><code>? super Class</code> 泛型下限，限定必须是Class或其父类</li><li>底层实现上，字节码中的泛型类型都会被擦除</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>对于任何一个Class对象，可以在运行时得到这个类的全部成分</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul><li>Class.forName(String)</li><li>类目.class</li><li>对象.getClass()<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96Class.svg" class="" title="alt 反射获取Class对象"></li></ul><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><ul><li>Class::getConstructors([paramTypes]) 获取公有构造器, Class::getDeclaredConstructors([paramTypes]) 获取所有构造器</li><li>Constructor::newInstance() 根据指定构造器创建新对象</li><li>Constructor::setAccessible(boolean) 设置访问检查，实现暴力反射(调用私有构造器，破坏了封装性)</li></ul><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ul><li>Class::getFields(name), Class::getDeclaredFields(name)</li><li>Field::set(object, val), Field::get(obj) 设置&#x2F;获取成员变量的值</li><li>Field::setAccessible(boolean)</li></ul><h3 id="获取方法对象"><a href="#获取方法对象" class="headerlink" title="获取方法对象"></a>获取方法对象</h3><ul><li>Class::getMethods([name, params]), Class::getDeclaredMethods([name, params])</li><li>Method::invoke(obj, args…) 对obj对象调用目标方法，可以获取返回值</li><li>Method::setAccessible(boolean)</li></ul><h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><ul><li><p>结合Lambda表达式，简化集合、数组操作的API</p></li><li><p>流的三类方法：</p><ul><li><p>获取Stream流：<br>创建一条流水线，并把数据放到流水线上准备进行操作。如<code>Collection.stream(), Arrays.stream(T[]), Stream.of(T...)</code></p></li><li><p>中间方法：<br>流水线上的操作，调用完成后返回新的Stream流，支持链式编程。如<code>filter, limit, skip, distinct, map, concat</code></p></li><li><p>终结方法：<br>流水线的最后一个操作，调用后不返回Stream，因此一个Stream流仅有一个。如<code>forEach, count</code></p></li></ul></li><li><p>流的收集</p><ul><li>把Stream流操作后的结果转回集合或数组。Stream是手段，集合&#x2F;数组才是目的</li><li>流只能使用一次 </li><li>方法：<code>stream.collect, stream.toArray, stream.toList</code>, Collector包括<code>Collectors::toList, Collectors::toSet, Collectors::toMap</code>等</li></ul></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul><li>代表OS的文件&#x2F;文件夹对象。提供定位、获取文件信息、删除、创建等功能</li><li><code>createNewFile</code></li><li><code>mkdir</code>创建一级目录, <code>mkdirs</code>创建多级目录</li><li><code>delete</code>删除文件&#x2F;空文件夹且不走回收站</li><li><code>list</code>返回目录下文件名数组,<code>listFiles</code>返回目录下文件对象数组，仅包括一级</li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>常见字符集:<ul><li>ASCII: 1个字节存储1个字符，共128个</li><li>GBK: 包含汉字等字符，一个中文2个字节存储</li><li>Unicode (UTF-8): 一个中文3个字节存储</li></ul></li><li>编解码：<ul><li>英文、数字在任何字符集都占1字节，不会乱码</li><li>编码：<code>string.getBytes(chatset)</code></li><li>解码：<code>String(byte[], charset)</code></li></ul></li></ul><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><ul><li><p>分类</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E5%88%86%E7%B1%BB.svg" class="" title="alt IO流分类"></li><li><p>体系</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E4%BD%93%E7%B3%BB.svg" class="" title="alt IO流体系"></li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><ul><li><p>InputStream</p><ul><li><code>read(), read(byte[len]), readAllBytes</code> 读取1 &#x2F; len &#x2F; 所有字节</li></ul></li><li><p>OutputStream</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字节流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><ul><li><p>Reader</p><ul><li><code>read(), read(char[len])</code> 读取 1 &#x2F; len 个字符</li></ul></li><li><p>Writer</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字符流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><ul><li>使用总结<ul><li>字节流适合一切文件数据的拷贝，包括音视频、文本等</li><li>字节流不适合读取中文内容输出</li><li>字符流适合文本文件的读写</li></ul></li></ul><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul><li>也称高效流、高级流。自带8KB缓冲区，可以提高原始字节流、字符流读写数据的性能。建议使用<strong>缓冲流+字节数组</strong></li><li><code>BufferedInputStream(InputStream)</code></li><li><code>BufferedOutputStream(OutputStream)</code></li><li><code>BufferedReader(Reader)</code>, <code>readline()</code></li><li><code>BufferedWriter(Writer)</code>, <code>newLine()</code></li></ul><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><ul><li>把原始的字节流按照指定编码转换</li><li>字符输入转换流：<code>InputStreamReader(InputStream, charset)</code></li><li>字符输出转换流：<code>OutputStreamWriter(OutputStream, charset)</code></li><li>建议创建转换流后使用缓冲流进行包装，提高性能</li></ul><h4 id="对象字节流-序列化"><a href="#对象字节流-序列化" class="headerlink" title="对象字节流 - 序列化"></a>对象字节流 - 序列化</h4><ul><li>以内存为基准，把内存中的对象存储到磁盘文件中，称为对象序列化</li><li>对象字节输出流：<code>ObjectOutputStream(OutputStream)</code></li><li><code>oos.writeObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li>以内存为基准，把存储在磁盘文件中的数据恢复成内存中的对象，称为对象反序列化</li><li>对象字节输入流：<code>ObjectInputStream(InputStream)</code></li><li><code>ois.readObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li><code>transient</code>修饰的成员变量不参与序列化</li><li>通常指定一个序列化版本号，以确保序列化、反序列化的对象保持一致</li></ul><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><ul><li>方便、高效地打印数据到文件中</li><li>基于字节<code>PrintStream</code>, 基于字符<code>PrintWriter</code></li><li><code>print()</code>, PrintStream支持写字节，PrintWriter支持写字符</li><li><code>System.out</code>就是一个PrintStream对象。可以重定向输出语句到文件中：<code>System.setOut(new PrintStream(File))</code></li></ul><h4 id="commons-io-库"><a href="#commons-io-库" class="headerlink" title="commons-io 库"></a>commons-io 库</h4><ul><li>IOUtils::copy</li><li>FileUtils::copyFileToDirectory</li><li>FileUtils::copyDirectoryToDirectory</li><li>…</li></ul><ul><li>JDK 1.7 引入了 NIO库</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><ul><li>定义任务类继承java.lang.Thread，重写run()方法</li><li>创建线程对象， 调用Thread::start()启动线程</li></ul><ul><li>优点：编码简单</li><li>缺点：不利于扩展，自定义线程无法继承其它类</li></ul><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><ul><li>创建Runnable接口匿名内部类，重写run()方法</li><li>把Runnable交给Thread类处理，调用start()启动线程</li></ul><ul><li>优点：可以继续继承、实现，扩展性强</li><li>缺点：多一层包装，线程如果有执行结果不可以直接返回</li></ul><h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><ul><li>定义任务类实现Callable接口，重写call()方法</li><li>用FutureTask把Callable对象封装成线程任务对象</li><li>把FutureTask交给Thread类处理调用，start()启动线程</li><li>线程执行完毕后，通过FutureTask::get()获取任务执行的结果</li></ul><ul><li>优点：可以继续继承、实现，扩展性强。且可以在线程执行完毕后获取执行结果</li><li>缺点：编码稍复杂</li></ul><h3 id="Thread常用API"><a href="#Thread常用API" class="headerlink" title="Thread常用API"></a>Thread常用API</h3><ul><li>setName, getName</li><li>currentThread() 返回当前正在执行的线程对象的引用</li><li>sleep(long) 让线程休眠指定时间，单位毫秒</li><li>yield, join, interrupt…</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><p>多个线程同时访问同一个共享资源且修改该资源</p></li><li><p>线程同步的核心思想：加锁</p><ul><li>同步代码块 <ul><li>synchronized(锁对象) </li><li>一般把共享资源作为锁对象</li><li>建议实例方法使用this作为锁对象，静态方法使用类.class对象作为锁对象</li></ul></li><li>同步方法 <ul><li>synchronized 修饰方法</li><li>底层：实例方法默认对this加锁，静态方法默认对类.class加锁</li></ul></li><li>Lock锁<ul><li>实现类：ReentrantLock</li><li>lock, unlock</li></ul></li></ul></li><li><p>线程通信</p><ul><li>wait() 让当前线程释放锁并进入等待，直到另一个线程唤醒</li><li>notify(), notifyAll() 唤醒正在等待的单个 &#x2F; 所有线程</li><li>必须通过当前同步锁对象进行调用</li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>创建线程的开销很大，可以通过复用线程，提高系统性能</p></li><li><p>线程池接口：<code>ExecutorService</code>; 实现类：<code>ThreadPoolExecutor</code>;  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-type">int</span> corePoolSize,                   //指定线程池的线程数量 (核心线程)</span><br>  <span class="hljs-type">int</span> maximumPoolSize,                <span class="hljs-comment">//指定线程池可支持的最大线程数 (&gt;=核心线程数)</span><br>  <span class="hljs-type">long</span> keepAliveTime,                 <span class="hljs-comment">//指定临时线程的最大存活时间</span><br>  TimeUnit unit,                      <span class="hljs-comment">//指定存活时间的单位(秒、分、时、天)</span><br>  BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//指定任务队列</span><br>  ThreadFactory threadFactory,        <span class="hljs-comment">//指定用哪个线程工厂创建线程</span><br>  RejectedExecutionHandler handler    <span class="hljs-comment">//指定线程忙，任务满的时候，新任务来了怎么办</span><br>)<br></code></pre></td></tr></table></figure><ul><li>新任务提交时的服务顺序：核心线程 -&gt; 任务队列 -&gt; 创建临时线程 -&gt; 拒绝服务<ul><li>如果核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li><li>核心线程、临时线程都在忙，任务队列也满了，新的任务到达时才会开始拒绝服务</li></ul></li><li>常用方法：<code>execute(Runnable), submit(Callable), shutdown(), shutdownNow()</code></li><li>拒绝策略：<ul><li><code>ThreadPoolExecutor.AbortPolicy</code> 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>ThreadPoolExecutor.DiscardPolicy</code> 丢弃且不抛异常，不推荐</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 抛弃队列中等待最久的任务 然后把当前任务加入队列中</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 绕过线程池，由主线程直接调用任务的run()方法执行</li></ul></li></ul></li><li><p>线程池工具类: <code>Executors</code> 通过调用方法返回不同类型的线程池对象</p><ul><li><code>newCachedThreadPool()</code> 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉</li><li><code>newFixedThreadPool​(int nThreads)</code> 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它</li><li><code>newSingleThreadExecutor()</code> 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程</li><li><code>newScheduledThreadPool​(int corePoolSize)</code> 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务</li><li>底层仍是基于ThreadPoolExecutor实现的</li><li>最大任务队列长度&#x2F;线程数量是Integer.MAX_VALUE,可能出现OOM</li></ul></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul><li>一种控制任务延时调用，或者周期调用的技术</li><li>实现方式：<ol><li>Timer<ul><li>Timer::schedule(task, delay&#x2F;time, period);</li><li>Timer单线程，处理多个任务按顺序执行，存在延时，和设置定时器的时间有出入</li><li>可能因为异常导致Timer线程死掉，从而影响后续任务执行</li></ul></li><li>ScheduledExecutorService<ul><li>Executors.newScheduledThreadPool​(int corePoolSize)</li><li>ScheduledExecutorService.scheduleAtFixedRate(Runnable, delay, period, unit)</li><li>基于线程池，某个任何的执行情况不会影响其它定时任务</li></ul></li></ol></li></ul><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul><li>并发: CPU分时轮询执行</li><li>并行: 同一时刻同时执行</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li>Java定义了6中状态：Thread.State::{NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED}<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" class="" title="线程的生命周期"></li></ul><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li>操作类 <code>InetAddress</code></li><li>getLocalHost 返回本主机的地址对象</li><li>getByName(host) 得到指定主机(域名&#x2F;IP)的IP地址对象</li><li>getHostName 返回此IP地址的主机名</li><li>getHostAddress 返回IP地址字符串 </li><li>isReachable(timeout) 指定时间ms内是否连通该IP</li></ul><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ul><li>标识主机上的进程，16bit，0-65535</li><li>周知端口 0-1023：预先定义的知名应用，如HTTP 80，FTP 21</li><li>注册端口 1024-49151：分配给用户进程&#x2F;应用程序，如Tomcat 8080，MySQL 3306</li><li>动态端口 49152-65535</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li>Ping命令直接基于网络层ICMP协议，无连接，不针对特定端口。与传输层TCP&#x2F;UDP，或是应用层HTTP等都无关</li><li>Socket是一个调用接口，实际是对TCP&#x2F;IP协议的封装</li><li>UDP协议的数据包大小限制64KB</li></ul><h3 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h3><ul><li>DatagramPacket 数据包对象<ul><li>DatagramPacket(byte[] buf, length, InetAddress, port)</li><li>getLength() 获取实际接受的字节个数</li></ul></li><li>DatagramSocket 发送者&#x2F;接收者对象<ul><li>DatagramSocket(port)</li><li>send(packet)</li><li>receive(packet)</li></ul></li></ul><ul><li>广播 Broadcast<ul><li>使用广播地址 255.255.255.255</li><li>发送端指定端口，其它主机注册该端口即可</li></ul></li><li>组播 Multicast<ul><li>使用组播地址 224.0.0.0 - 239.255.255.255</li><li>发送端指定组播IP和端口，接收端绑定该组播IP，并注册该端口</li><li>DatagramSocket的子类MulticastSocket::joinGroup负责绑定组播IP</li></ul></li></ul><h3 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h3><ul><li><code>java.net.Socket</code> 基于TCP协议<ul><li>Socket(host, port)</li><li>Socket::getOutputStream()</li><li>Socket::getInputStream()</li></ul></li><li>ServerSocket 服务端<ul><li>ServerSocket(port)</li><li>ServerSocket::accept() 等待接收客户端的Socket通信连接，连接成功返回Socket对象与客户端建立端到端通信</li></ul></li><li>服务端一般使用循环，负责接收客户端Socket管道连接,每接收到一个Socket管道后分配一个独立的线程负责处理它(线程池技术)</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><ul><li><strong>Error</strong>：系统级别问题、JVM退出等，代码无法控制</li><li><strong>Exception</strong>：java.lang包下，称为异常类，表示程序本身可以处理的问题<ul><li><strong>RuntimeException</strong>及其子类：运行时异常，编译阶段不会报错。如空指针、数组索引越界等</li><li>除<strong>RuntimeException</strong>之外的所有异常：编译时异常，编译期必须处理，也称受检异常。如日期格式化异常</li></ul></li></ul><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.svg" class="" title="alt 异常体系"><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><strong>throws</strong>：用在方法声明上，将方法内部出现的异常抛出给调用者</li><li><strong>try-catch</strong>：监视捕获异常，在方法内部自己处理，程序继续执行</li><li><strong>try-catch-finally</strong>: 除非JVM崩溃，否则必须执行finally块</li><li><strong>try-with-resource</strong>: 自动关闭资源(Closeable&#x2F;AutoCloseable)，即使出现异常</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>定义异常继承 Exception &#x2F; RuntimeException</li><li>重写构造器</li><li>在出现异常的地方主动 throw 自定义异常对象</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>又称Java标注，对Java中类、方法、变量做标记，然后进行特殊处理</p><ul><li><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Book &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">100</span>;<br>    String[] author();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>元注解：对注解类的注解</p><ul><li>@Target：约束注解标记的位置<ul><li>ElementType.TYPE 类，接口</li><li>ElementType.FIELD 成员变量</li><li>ElementType.METHOD 成员方法</li><li>ElementType.PARAMETER 方法参数</li><li>ElementType.CONSTRUCTOR 构造器</li><li>ElementType.LOCAL_VARIABLE 局部变量</li></ul></li><li>@Retention：约束注解的存活范围<ul><li>RetentionPolicy.SOURCE 注解只作用在源码阶段，生成的字节码文件中不存在</li><li>RetentionPolicy.CLASS 默认值，注解作用在源码阶段，字节码文件阶段，运行阶段不存在</li><li>RetentionPolicy.RUNTIME 注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li></ul></li></ul></li><li><p>注解解析</p><ul><li>Annotation: 注解对象</li><li>AnnotatedElement: 注解解析相关方法的接口，所有类成分Class&#x2F;Method&#x2F;Field&#x2F;Constructor均已实现<ul><li>getDeclaredAnnotations()</li><li>getDeclaredAnnotation(class)</li><li>isAnnotationPresent(class)</li></ul></li><li>解析技巧：注解在哪个成分上，就先拿哪个成分对象</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>对业务功能进行代理，类似AOP编程</li><li>Proxy::newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li><li>InvocationHandler::invoke(Object proxy, Method method, Object[] args)</li><li>优点：<ul><li>非常灵活，支持任意接口类型做代理，也可以直接为接口本身做代理</li><li>可以为被代理对象的所有方法做代理</li><li>不改变方法源码的情况下，实现对功能的增强</li><li>简化编程，提高可扩展性，提高了开发效率</li></ul></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li>解决浮点型运算精度失真问题</li><li>禁止使用BigDecimal(double)把double值转换为BigDecimal对象，依然存在精度损失风险</li><li>推荐使用<code>BigDecimal(String)或BigDecimal.valueOf(Double)</code>的构造方式，自动对精度进行截断处理</li><li>BigDecimal只是手段，目的是Double</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举类都继承了 <code>java.lang.Enum</code></li><li>枚举都是最终类，不可以被继承</li><li>构造器都是私有，对外不能创建对象</li><li>枚举类相当于多例模式<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8F%8D%E7%BC%96%E8%AF%91.svg" class="" title="alt 枚举类型反编译"><center>枚举类型反编译</center></li></ul><h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><ul><li>Date 日期对象<ul><li>Date() </li><li>setTime(), getTime() 时间毫秒值</li></ul></li><li>SimpleDateFormat<ul><li>new SimpleDateFormat(pattern)</li><li>format(Date&#x2F;time): Date&#x2F;time -&gt; String</li><li>parse(dateStr): String -&gt; Date</li></ul></li><li>Calendar 系统此刻日历对象<ul><li>Calendar.getInstance()</li></ul></li></ul><p>JDK 8新增日期时间API：</p><ul><li>LocalDate 不包含具体时间的日期</li><li>LocalTime 不包含日期的时间</li><li>LocalDateTime 包含日期和时间</li><li>Instant 时间戳</li><li>DateTimeFormatter 时间格式化和解析</li><li>Duration 计算两个时间间隔</li><li>Period 计算两个日期间隔</li><li>ChronoUnit 针对特定时间单位测量时间差</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>Pattern.complie(regex)</li><li>pattern.matcher(String)</li><li>matcher.find()</li><li>matcher.group()</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><p>优势：可以将系统执行的信息选择性的记录到指定的位置，如控制台、文件、数据库等。并且随时以开关的形式控制是否记录，灵活性好</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB.svg" class="" title="alt 日志体系"></li><li><p>Logback 模块</p><ul><li>logback-core: 核心模块</li><li>logback-classic: log4j 改良版本，完整实现 slf4j API</li><li>logback-access: 与Tomcat和Jetty等Servlet容器集成，提供HTTP访问日志功能</li></ul></li><li><p>使用：</p><ul><li>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR，默认DEBUG</li><li>配置文件<code>logback.xml</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;Test.class&quot;</span>);<br>LOGGER.debug(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.info(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.trace(<span class="hljs-string">&quot;a = &quot;</span> + a);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>针对最小的功能单元，即Java中的方法，编写测试代码</li><li>传统测试方法的缺陷：只能测试main，方法之间相互影响，无法得到测试结果的报告，无法实现自动化测试</li><li>Junit单元测试框架<ul><li>优点：可以灵活选择测试方法，自动生成测试报告</li><li>使用：<ul><li>导入JUnit</li><li>编写公共的，无参数无返回值测试方法，并加上@Test注解</li><li>允许测试</li></ul></li><li>测试注解：@Before, @After, @BeforeClass, @AfterClass, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll</li></ul></li></ul><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li>可扩展标记语言（eXtensible Markup Language），一种数据表示格式</li><li>纯文本，默认UTF-8编码，可嵌套，经常用于网络传输、配置文件</li><li>XML格式：<ul><li>第一行文档声明 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</code></li><li>特殊字符：小于 &amp;lt;  大于 &amp;gt; 和号 &amp;amp; 单引号 &amp;apos; 引号 &amp;quot;</li><li>解释器忽略文本：&lt;![CDATA[…内容…]]&gt;</li></ul></li><li>XML约束：限定xml文件中的标签以及属性规则<ul><li>DTD <code>&lt;!DOCTYPE 根标签名 PUBLIC/SYSTEM &quot;dtd文件名&quot; &quot;dtd文件位置&quot;&gt;</code> 不能约束具体数据类型</li><li>SCHEME <code>&lt;根标签 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xxx.com&quot; xsi:schemaLocation=&quot;http://xxx.xsd&quot;&gt;</code> 约束更严谨</li></ul></li><li>XML解析<ul><li>SAX解析：一行一行解析</li><li>DOM解析：整个文件解析，如JAXP、JDOM、<strong>Dom4j</strong>、jsoup</li><li>Dom4j API:<ul><li>List<Element> elements() 得到当前元素下所有子元素</li><li>List<Element> elements(String name) 得到当前元素下指定名字的子元素返回集合</li><li>Element element(String name) 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</li><li>String getName() 得到元素名字</li><li>String attributeValue(String name) 通过属性名直接得到属性值</li><li>String elementText(子元素名) 得到指定名称的子元素的文本</li><li>String getText() 得到文本</li></ul></li></ul></li><li>XML检索——XPath<ul><li>使用路径表达式来定位元素节点或属性节点</li><li>基于dom4j和jaxen</li><li>selectSingleNode(exp), selectNodes(exp)</li><li>四大检索方案：<ul><li>绝对路径：<code>/根元素/子元素/孙元素</code> 从根元素开始，一级一级向下查找，不能跨级</li><li>相对路径: <code>./子元素/孙元素</code> 从当前元素开始，一级一级向下查找，不能跨级</li><li>全文检索: <code>//name</code> <code>//father/son</code> <code>//father//grandson</code> 直接全文搜索所有的name元素并打印</li><li>属性查找: <code>//@attr</code> <code>//ele[@attr]</code> <code>//ele//[@attr=val]</code> 查找属性&#x2F;含有指定值的属性的元素</li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>工厂模式：<ul><li>对象通过工厂的方法创建返回</li><li>可以为该对象进行加工和数据注入，实现类与类之间的解耦操作</li></ul></li><li>装饰模式<ul><li>创建新类，包装原始类</li><li>可以在不改变原有类的基础上，动态扩展一个类的功能</li></ul></li></ul><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><ul><li>JVM内存区：<strong>虚拟机栈、堆、方法区</strong>、本地方法栈、程序计数器<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/Java%E5%86%85%E5%AD%98%E5%8C%BA.svg" class="" title="alt Java内存区"></li></ul><ul><li>基本内存分配：<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" class="" title="alt 基本内存分配"><ul><li>方法区存放加载的类信息</li><li>栈(栈帧): 局部变量表</li><li>堆: new出来的对象实例 （如数组）</li></ul></li></ul><ul><li><p>两个引用指向同一对象</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1.png" class="" title="alt 两个引用指向同一对象"><ul><li>栈内存中两个引用的地址值指向堆中同一块内存区</li><li>利用引用修改堆中数据后，所有引用指向该内存区域的数据都会反映出来</li></ul></li></ul><ul><li>Java参数传递机制<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 基本类型参数传递"><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 引用类型参数传递"><ul><li>无论基本类型还是引用类型，都是值传递</li><li>基本类型传递的是本身的数据值</li><li>引用类型的值是指向堆内存的某个地址</li></ul></li></ul><ul><li>两个对象内存图;<img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 两个类对象内存图"><ul><li>方法区保存了类的信息，包括类名、成员变量、成员方法等</li><li>堆中实际类对象的成员方法存的是方法区里类的成员方法引用</li></ul></li></ul><ul><li><p>集合存储内存图</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 集合存储内存图"><ul><li>数组&#x2F;集合中存储的元素并不是对象本身，而是对象的地址</li></ul></li><li><p>静态常量内存图</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 静态常量内存图"></li><li><p>子类继承内存图</p><img src="/2022/11/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 子类继承内存图"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-位运算</title>
    <link href="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode 136. 只出现一次的数字"></a>LeetCode 136. 只出现一次的数字</h1><p>链接：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode136.png" class="" title="alt LeetCode136"><p>找出数组中唯一成单的数字，主要学习异或运算的性质和哈希表的使用。</p><h2 id="解法1-异或运算"><a href="#解法1-异或运算" class="headerlink" title="解法1. 异或运算"></a>解法1. 异或运算</h2><p>异或运算的三个性质</p><ul><li>任何数和0做异或，结果仍是原来的数<br>  $ a \bigoplus 0 &#x3D; a $</li><li>任何数和自身做异或结果是0<br>  $ a \bigoplus a &#x3D; 0 $</li><li>异或运算满足交换律和结合律<br>  $ a \bigoplus b \bigoplus a &#x3D; b \bigoplus a \bigoplus a &#x3D; b $<br>因此数组中所有元素异或即可得到单个的元素。时间复杂度$O(n)$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            ans ^= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="解法2-哈希表"><a href="#解法2-哈希表" class="headerlink" title="解法2. 哈希表"></a>解法2. 哈希表</h2><p>使用哈希表存储每个数字和该数字出现的次数。最后次数为1的就是单个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.get(i);<br>            map.put(i, count == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++count;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$,空间复杂度$O(n)$</p><hr><h1 id="LeetCode-191-位1的个数"><a href="#LeetCode-191-位1的个数" class="headerlink" title="LeetCode 191. 位1的个数"></a>LeetCode 191. 位1的个数</h1><p>链接：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode191.png" class="" title="alt LeetCode191"><h2 id="方法1-移位"><a href="#方法1-移位" class="headerlink" title="方法1 - 移位"></a>方法1 - 移位</h2><p>循环检查二进制的每一位是否为1，例如让n和 $2^i$ 进行与运算，或者让n和1相与并右移n，得到二进制末尾是否为1<br>时间复杂度$O(k)$, 其中$k$是二进制位数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            count += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注，Java中：</p><ul><li><code>&lt;&lt;</code> 左移，高位舍弃，低位补0</li><li><code>&gt;&gt;</code> 右移，舍弃最低位，高位用符号位填补，正数补0，负数补1</li><li><code>&gt;&gt;&gt;</code> 无符号右移，舍弃最低位，高位用0填补</li></ul><h2 id="方法二-Brian-Kernighan算法"><a href="#方法二-Brian-Kernighan算法" class="headerlink" title="方法二 - Brian Kernighan算法"></a>方法二 - Brian Kernighan算法</h2><p>利用 $n \And (n-1)$ 能够把二进制中的最低位1变为0的特性，反复操作，直至n&#x3D;0</p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/n&n-1.png" class="" title="alt n&amp;n-1"><p>可以看到，n-1会把n末尾的0变1，直到遇到最低位的1把它变0，其余保持不变。相与时，n末尾的0与运算后仍是0，而最低位1和0相与得0，其余位不变。因此，$n \And (n-1)$把n的最低位1变成了0，其余位不变。</p><p>时间复杂度$O(logn)$, 循环次数就是n的二进制中1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法3-分治"><a href="#方法3-分治" class="headerlink" title="方法3 - 分治"></a>方法3 - 分治</h2><p>0x55555555 &#x3D; 0B0101…0101<br>0x33333333 &#x3D; 0B0011…0011<br>0x0f0f0f0f &#x3D; 0B00001111…00001111</p><p>贴上Java中的<code>Integer::bitCount()</code>源码，太神奇了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bitCount</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        i = i - ((i &gt;&gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);                   <span class="hljs-comment">// 此时i每两位的值是原数字每两位1的个数</span><br>        i = (i &amp; <span class="hljs-number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);    <span class="hljs-comment">// 此时i每4位的值是原数字每4位1的个数 </span><br>        i = (i + (i &gt;&gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0f0f0f0f</span>;                   <span class="hljs-comment">// 此时i每8位的值是原数字每8位1的个数</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">8</span>);                                  <span class="hljs-comment">// 每两个8位合并统计</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">16</span>);                                 <span class="hljs-comment">// 两个16位合并统计</span><br>        <span class="hljs-keyword">return</span> i &amp; <span class="hljs-number">0x3f</span>;                                    <span class="hljs-comment">// 取出低6位，因为32bit最高只有32个1</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>注意第二行，前半句保留奇数组的”两位”，后半句保留偶数组的”两位”，然后相加使得相邻的两个”两位”合并统计，即得到每4位1的个数<br>分开&amp;的原因在于2bit最多表示3个1，不足以表示原数字每4位1的个数，因此要多做一次&amp;然后相加<br>而在第三行，4bit(0-15)可以表示8位二进制1的个数，因此只需要&amp;一次</p><hr><h1 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode 461. 汉明距离"></a>LeetCode 461. 汉明距离</h1><p>链接：<a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode461.png" class="" title="alt LeetCode461"><p>先把两数字异或，然后同LeetCode191，统计1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x ^ y, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (s != <span class="hljs-number">0</span>) &#123;<br>            s &amp;= s - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows平台搭建Dash系统</title>
    <link href="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows平台搭建Dash系统"><a href="#Windows平台搭建Dash系统" class="headerlink" title="Windows平台搭建Dash系统"></a>Windows平台搭建Dash系统</h1><h2 id="1-Dash简介"><a href="#1-Dash简介" class="headerlink" title="1. Dash简介"></a>1. Dash简介</h2><p><strong>Dynamic Adaptation Streaming over HTTP (Dash):</strong><br>HTTP上的动态自适应视频流技术，它将一个视频划分为许多个segment，每个segment有不同质量的副本，能够在播放时根据用户当前的网络状况选择最佳的码率，减少卡顿。详情: <a href="https://dashif.org/">https://dashif.org/</a></p><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2. 配置环境"></a>2. 配置环境</h2><ul><li>环境<ul><li>系统：Windows 10</li><li>客户端：Chrome</li></ul></li><li>工具 (安装好并将<code>bin</code>目录加入系统环境变量)<ul><li>服务器：Nginx <a href="https://www.cnblogs.com/taiyonghai/p/9402734.html">安装教程</a></li><li>编解码器：<a href="https://github.com/BtbN/FFmpeg-Builds/releases">FFmpeg</a></li><li>视频切片工具：<a href="https://www.bento4.com/downloads/">Bento4</a></li><li>播放器：<a href="https://github.com/Dash-Industry-Forum/dash.js">dash.js</a></li></ul></li><li>视频<ul><li>Big Buck Bunny   可以去 <a href="https://download.blender.org/peach/bigbuckbunny_movies/">https://download.blender.org/peach/bigbuckbunny_movies/</a> 下载</li></ul></li></ul><h2 id="3-对视频进行编码"><a href="#3-对视频进行编码" class="headerlink" title="3. 对视频进行编码"></a>3. 对视频进行编码</h2><ul><li>目标编码格式：H.264&#x2F;AVC</li><li>目标分辨率级别：<ul><li>1920×1080 (1080p)</li><li>1280×720 (720p)</li><li>854×480 (480p)</li><li>640×360 (360p)</li><li>256×144 (144p)</li></ul></li><li>编码命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1920x1080 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1920x1080.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1280x720 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1280x720.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 896x504 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_896x504.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 640x360 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_640x360.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 256x144 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_256x144.mp4<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>：输入文件名</li><li><code>-s</code>：输出的分辨率</li><li><code>-c:v libx264</code>：将视频编码为H.264&#x2F;AVC格式</li><li><code>-keyint_min 48 -g 48 -sc_threshold 0</code>：固定GOP长度为48帧(即2s，具体由帧率决定)。这里如果没有这个参数后面bento4切分时会报错，具体原因见 <a href="https://blog.csdn.net/LvGreat/article/details/103540007">FFmpeg的GOP（I帧）对齐问题</a></li><li><code>-an</code>：不对音频进行编码，dash中音视频分开编码</li><li>最后是输出文件名</li></ul></li></ul><p> 可以写个bat，扔那边慢慢跑，视频小的话几十秒就好了。完成后：<br> <img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90.png" class="" title="alt 视频编码完成"><br>​</p><h2 id="4-视频切片"><a href="#4-视频切片" class="headerlink" title="4. 视频切片"></a>4. 视频切片</h2><ol><li><p>使用bento4的<code>mp4fragment</code>对视频进行fragment</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4fragment --fragment-duration 2000 BBB_1920x1080.mp4 fragmented_1080p.mp4<br>mp4fragment --fragment-duration 2000 BBB_1280x720.mp4 fragmented_720p.mp4<br>mp4fragment --fragment-duration 2000 BBB_896x504.mp4 fragmented_480p.mp4<br>mp4fragment --fragment-duration 2000 BBB_640x360.mp4 fragmented_360p.mp4<br>mp4fragment --fragment-duration 2000 BBB_256x144.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>  <code>--fragment-duration</code>：指定fragment时长为2s</p></li><li><p>使用<code>mp4dash</code>对已fragment的视频进行切片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4dash fragmented_1080p.mp4 fragmented_720p.mp4 fragmented_480p.mp4 fragmented_360p.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>成后目录中会自动生成out文件夹，里面有mpd文件和切分的segment</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E5%AE%8C%E6%88%90.png" class="" title="alt 视频切片完成"></li></ol><h2 id="5-编写简易网页播放器"><a href="#5-编写简易网页播放器" class="headerlink" title="5. 编写简易网页播放器"></a>5. 编写简易网页播放器</h2><p>参考：<a href="https://github.com/Dash-Industry-Forum/dash.js%E2%80%8B">https://github.com/Dash-Industry-Forum/dash.js​</a></p><p>将out里面的video文件夹和<code>stream.mpd</code>放到nginx的html文件夹里，下载<code>dash.all.min.js</code>也放入html文件夹中。</p><p>具体的目录结构可以自定义。我这边的目录如下：</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/demo%E7%9B%AE%E5%BD%95.png" class="" title="alt Demo目录"><p>DashJS.html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dash.js Rocks<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">            <span class="hljs-selector-tag">video</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>;</span><br><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">360px</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;videoPlayer&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dash.all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;./stream.mpd&quot;</span>;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> player = dashjs.<span class="hljs-title class_">MediaPlayer</span>().<span class="hljs-title function_">create</span>();</span><br><span class="language-javascript">                player.<span class="hljs-title function_">initialize</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#videoPlayer&quot;</span>), url, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">            &#125;)();</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="6-配置Nginx服务器"><a href="#6-配置Nginx服务器" class="headerlink" title="6. 配置Nginx服务器"></a>6. 配置Nginx服务器</h2><p>配置访问控制，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨源资源共享（CORS） - HTTP | MDN</a></p><p>修改Nginx的conf下的nginx.conf文件中的server段，主要是加入location &#x2F;file那一块</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">server <span class="hljs-punctuation">&#123;</span><br>    listen       <span class="hljs-number">8800</span>;<br>    server_name  localhost;<br><br>    location / <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>        index  index.html index.htm;<br>    <span class="hljs-punctuation">&#125;</span><br>    location /file <span class="hljs-punctuation">&#123;</span><br>        if ($request_method = &#x27;OPTIONS&#x27;) <span class="hljs-punctuation">&#123;</span><br>            add_header Access-Control-Allow-Origin $http_origin;<br>            add_header Access-Control-Allow-Methods             <br>            $http_access_control_request_method;<br>            add_header Access-Control-Allow-Credentials <span class="hljs-literal"><span class="hljs-keyword">true</span></span>;<br>            add_header Access-Control-Allow-Headers <br>            $http_access_control_request_method;<br>            add_header Access-Control-Max-Age <span class="hljs-number">1728000</span>;<br>            return <span class="hljs-number">204</span>;<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><br>    #error_page  <span class="hljs-number">404</span>              /<span class="hljs-number">404.</span>html;<br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>验证Nginx配置是否正确，正确后启动Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br>start nginx<br></code></pre></td></tr></table></figure><h2 id="7-验证"><a href="#7-验证" class="headerlink" title="7. 验证"></a>7. 验证</h2><p>最后打开 <a href="http://localhost:8800/DashDemo/DashJS.html">http://localhost:8800/DashDemo/DashJS.html</a> 验证是否成功即可</p><p>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://codeleading.com/article/26092631381/#5_Bento4_90">DSAH视频系统（服务器&amp;播放器）搭建 - 代码先锋网</a></li><li>[2] <a href="https://blog.csdn.net/OCTODOG/article/details/79007302">Nginx 搭建DASH服务器_山城过雨的博客-CSDN博客</a></li><li>[3] <a href="https://www.instructables.com/Making-Your-Own-Simple-DASH-MPEG-Server-Windows-10/">Making Your Own Simple MPEG-DASH Server (Windows 10) : 12 Steps - Instructables</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Dash</tag>
      
      <tag>视频流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
