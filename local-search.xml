<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode-回溯算法解决排列组合问题</title>
    <link href="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="排列组合问题"><a href="#排列组合问题" class="headerlink" title="排列组合问题"></a>排列组合问题</h1><p><strong>子集、组合、排列</strong>问题就是从序列中以给定规则取若干元素构成集合的集合。本质上就是穷举所有解，而这些解呈现树形结构，因此合理使用回溯算法框架就可以一网打尽。</p><p>主要记住下面两棵<strong>回溯树</strong>，所有问题都是这两棵树的变种，关键在于剪枝的判断。</p><img src="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/%E7%BB%84%E5%90%88_%E5%AD%90%E9%9B%86%E6%A0%91.jpeg" class="" title="alt 组合_子集树"><img src="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/%E6%8E%92%E5%88%97%E6%A0%91.jpeg" class="" title="alt 排列树"><p><strong>回溯框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//前置处理，如排序、处理空集等</span><br><br>        backtrace(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span>(符合条件)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(不符合条件)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            cur.add(nums[i]);<br>            backtrace(nums, i + <span class="hljs-number">1</span>);<br>            cur.remove(cur.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第一类-元素无重，不可复选"><a href="#第一类-元素无重，不可复选" class="headerlink" title="第一类 - 元素无重，不可复选"></a>第一类 - 元素无重，不可复选</h1><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>无重复元素的数组，不可复选，求所有子集。<br><a href="https://leetcode.cn/problems/subsets/">Leetcode-78. 子集</a></p><p>套用框架，关键在于用start控制树枝的遍历，避免产生重复的子集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 前序位置，每个节点的值都是一个子集</span><br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 关键：通过 start 控制树枝遍历，避免产生重复子集</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>无重复元素的数组，不可复选，求指定元素个数的组合。<br><a href="https://leetcode.cn/problems/combinations/">Leetcode-77. 组合</a></p><p>所以本质上组合问题和子集问题是一样的，子集不要求元素的个数，组合指定了结果集的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>    <span class="hljs-comment">// 关键：达到指定个数加入结果集并返回</span><br>    <span class="hljs-keyword">if</span>(cur.size() == k)&#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cur));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n; i++) &#123;<br>        cur.add(i);<br>        backtrace(n, k, i + <span class="hljs-number">1</span>);<br>        cur.remove(cur.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>无重复元素的数组，不可复选，求全排列<br><a href="https://leetcode.cn/problems/permutations/">Leetcode-46. 全排列</a></p><p>排列问题不同于子集&#x2F;组合，任何元素顺序不一致都是不同的解，换句话说，任意位置都可以是任意未使用的元素，因此不能再用start控制元素遍历的顺序了。<br>但是要求元素不可复选，因此关键是要用 <strong>used[]</strong> 数组判断元素是否已经加入当前的排列结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 所有元素都已经加入排列，符合条件，加入结果集并返回</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 关键：已经加入当前排列结果，不可复选</span><br>        <span class="hljs-keyword">if</span> (used[i]) <br>            <span class="hljs-keyword">continue</span>;<br><br>        track.addLast(nums[i]);<br>        used[i] = <span class="hljs-literal">true</span>;<br>        backtrack(nums);<br>        used[i] = <span class="hljs-literal">false</span>;<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二类-元素可重，不可复选"><a href="#第二类-元素可重，不可复选" class="headerlink" title="第二类 - 元素可重，不可复选"></a>第二类 - 元素可重，不可复选</h1><h2 id="子集-1"><a href="#子集-1" class="headerlink" title="子集"></a>子集</h2><p>存在重复元素的数组，不可复选，求所有子集。结果中不能有重复的集合。<br><a href="https://leetcode.cn/problems/subsets-ii/">Leetcode-90.子集II</a></p><p>回溯树如下，由于相同的元素后续遍历的结果会产生重复，因此需要剪枝：</p><img src="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E5%AD%90%E9%9B%86.jpeg" class="" title="alt 元素可重子集"><p>实现上，就先要对数组进行排序让相同的元素挨在一起，方便回溯剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 前置操作：排序。方便回溯剪枝</span><br>    Arrays.sort(nums);<br>    backtrack(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//关键：相邻的等值元素产生重复，剪枝</span><br>        <span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br><br>        track.addLast(nums[i]);<br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a>组合</h2><p>存在重复元素的数组，不可复选，求和为target的组合。结果中不能有重复的集合。<br><a href="https://leetcode.cn/problems/combination-sum-ii/">Leetcode-40. 组合总和 II</a></p><p>组合本质上和可重不可复选子集问题是一样的，关键只要记录当前子集的和是否达到target，没达到继续遍历，达到了就加入结果集，超过了就剪枝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    Arrays.sort(candidates);<br>    backtrack(candidates, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// sum记录当前track集合总和</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 达到target加入结果集</span><br>    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 超过target剪枝</span><br>    <span class="hljs-keyword">if</span>(sum &gt; target)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 和子集一样，相邻的等值树枝会产生重复，剪枝</span><br>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <br>        track.addLast(nums[i]);<br>        backtrack(nums, i + <span class="hljs-number">1</span>, sum + nums[i], target);<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列-1"><a href="#排列-1" class="headerlink" title="排列"></a>排列</h2><p>存在重复元素的数组，不可复选，求所有不重复的全排列。<br><a href="https://leetcode.cn/problems/permutations-ii/">Leetcode-47. 全排列 II</a></p><p>解法1：记录前一条树枝的值，对值相同的树枝不遍历，避免产生相同的子树。</p><img src="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E6%8E%92%E5%88%97%E8%A7%A3%E6%B3%951.jpeg" class="" title="alt 元素可重排列解法1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.sort(nums);<br>    used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    backtrack(nums);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 解法1关键：记录上一个排列的值，下一个值如果相同则不遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastNum</span> <span class="hljs-operator">=</span> -<span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i] || nums[i] == lastNum)<br>            <span class="hljs-keyword">continue</span>;<br>        lastNum = nums[i];<br><br>        track.addLast(nums[i]);<br>        used[i] = <span class="hljs-literal">true</span>;<br>        backtrack(nums);<br>        used[i] = <span class="hljs-literal">false</span>;<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：控制相同元素的前后顺序。例如 <strong>[1,2,2]</strong> 看成 **[1,2,2’]**，我们要求2’必须出现在2之后，保证了无重复的排列结果。 (之所以出现重复，是因为把相同元素形成的排列视为了不同的序列，但实际上它们应该是相同的)</p><img src="/2022/12/31/LeetCode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E6%8E%92%E5%88%97%E8%A7%A3%E6%B3%952.jpeg" class="" title="alt 元素可重排列解法2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.sort(nums);<br>    used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>    backtrack(nums);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 所有元素都已经加入排列，符合条件，加入结果集并返回</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 解法2关键：控制相同元素的前后顺序</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br><br>        track.addLast(nums[i]);<br>        used[i] = <span class="hljs-literal">true</span>;<br>        backtrack(nums);<br>        used[i] = <span class="hljs-literal">false</span>;<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三类-元素无重，可复选"><a href="#第三类-元素无重，可复选" class="headerlink" title="第三类 - 元素无重，可复选"></a>第三类 - 元素无重，可复选</h1><h2 id="组合-2"><a href="#组合-2" class="headerlink" title="组合"></a>组合</h2><p>无重复元素的数组，可复选，求和为target的元素组合。<br><a href="https://leetcode.cn/problems/combination-sum/">Leetcode-39. 组合总和</a></p><p>标准的子集&#x2F;组合问题我们使用<strong>start + 1</strong>使得下一层递归时不可复选元素，现在可以复选了，那么去掉+1就可以了。无重可复选的子集问题也类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    Arrays.sort(candidates);<br>    backtrack(candidates, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sum == target)<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>    <span class="hljs-keyword">if</span>(sum &gt;= target)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 关键：下一层递归仍从i开始遍历，也即可复选元素</span><br>        backtrack(nums, i, sum + nums[i], target);<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列-2"><a href="#排列-2" class="headerlink" title="排列"></a>排列</h2><p>LeetCode没有这样的例题，但其实思路和上面的组合一样，现在元素可复选就更简单了，直接去掉used数组就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        track.add(nums[i]);<br>        backtrack(nums);<br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>子集和组合本质上一样，区别在于组合指定了集合大小<ul><li>无重不可复选通过<strong>start + 1</strong>控制元素不复选</li><li>有重不可复选通过判断 <strong>nums[i] &#x3D;&#x3D; nums[i - 1]</strong> 来避免相同元素产生重复集合</li><li>无重可复选只要去除 start 的 +1 操作，让元素可复选即可</li></ul></li><li>排列的重点在于任意位置放不同元素产生的序列是不一样的，因此需要 <strong>used[]</strong> 数组判断当前元素是否已经加入排列<ul><li>有重不可复选有两种特殊解法，一种是记录上一次加入排列的元素，另一种是控制相同元素在排列中的顺序</li><li>无重可复选只要去除used数组，让元素可复选即可</li></ul></li><li>元素可重问题通常都要先对数组排序，方便后续的回溯剪枝</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-笔记</title>
    <link href="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="MySQL-概述"><a href="#MySQL-概述" class="headerlink" title="MySQL 概述"></a>MySQL 概述</h2><table><thead><tr><th align="center">名称</th><th align="left">简介</th></tr></thead><tbody><tr><td align="center">DB</td><td align="left">存储数据的仓库，对数据进行有组织的存储</td></tr><tr><td align="center">DBMS</td><td align="left">操纵和管理数据库的大型软件</td></tr><tr><td align="center">SQL</td><td align="left">操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td></tr></tbody></table><ul><li>关系型数据库：建立在关系模型基础上，由多张相互连接的二维表，即由行和列组成的表，构成的数据库</li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" class="" title="alt 数据模型"><p>启动MySQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 启停MySQL服务<br>net <span class="hljs-keyword">start</span> mysql80<br>net stop mysql80<br><br># 连接MySQL<br>mysql [<span class="hljs-operator">-</span>h <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>] [<span class="hljs-operator">-</span>P <span class="hljs-number">3306</span>] <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br>参数：<br><span class="hljs-operator">-</span>h : MySQL服务所在的主机IP<br><span class="hljs-operator">-</span>P : MySQL服务端口号， 默认<span class="hljs-number">3306</span><br><span class="hljs-operator">-</span>u : MySQL数据库用户名<br><span class="hljs-operator">-</span>p ： MySQL数据库用户名对应的密码<br></code></pre></td></tr></table></figure><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th align="center">名称</th><th align="left">全称</th><th align="left">简介</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="left">Data Definition Language</td><td align="left">数据定义语言，用来定义数据库对象，如数据库、表、字段</td></tr><tr><td align="center">DML</td><td align="left">Data Manipulation Language</td><td align="left">数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="left">Data Query Language</td><td align="left">数据查询语言，用来查询数据库中表的记录</td></tr><tr><td align="center">DCL</td><td align="left">Data Control Language</td><td align="left">数据控制语言，用来创建数据库用户、控制数据库的控制权限</td></tr></tbody></table><h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL - 数据定义语言"></a>DDL - 数据定义语言</h3><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul><li>查询所有数据库:<br><code>show databases;</code></li><li>查询当前数据库：<br><code>select database();</code>  </li><li>创建数据库：<br><code>create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则]</code> </li><li>删除数据库:<br><code>drop database [if exists] 数据库名;</code>  </li><li>切换数据库：<br><code>use 数据库名;</code></li></ul><p>注：UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</p><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ul><li>查询当前数据库所有表：<br><code>show tables;</code>  </li><li>查询表结构：<br><code>desc 表名;</code>  </li><li>查询指定表的建表语句：<br><code>show create table 表名;</code>  </li><li>创建表：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [COMMENT 字段<span class="hljs-number">1</span>注释],<br>    字段<span class="hljs-number">2</span> 字段<span class="hljs-number">2</span>类型 [COMMENT 字段<span class="hljs-number">2</span>注释],<br>    字段<span class="hljs-number">3</span> 字段<span class="hljs-number">3</span>类型 [COMMENT 字段<span class="hljs-number">3</span>注释],<br>    ...<br>    字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure></li><li>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></li><li>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除表，并重新创建该表，相当于删除表中所有数据：<br><code>TRUNCATE TABLE 表名;</code></li></ul><h4 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h4><ul><li><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p></li><li><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p></li><li><p>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code>  </p></li><li><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p></li></ul><h3 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML - 数据操作语言"></a>DML - 数据操作语言</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code>  </p></li><li><p>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code>  </p></li><li><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p></li></ul><p>注：</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的</li><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE employee SET name = &#39;小昭&#39;, gender = &#39;女&#39; where id = 1;</code></p><p>注: 没有条件语句则会修改整张表的所有数据</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p><code>DELETE FROM 表名 [ WHERE 条件 ];</code><br>例：<br><code>delete from employee where gender = &#39;女&#39;;</code></p><p>注：</p><ul><li>没有条件语句则会删除整张表的所有数据</li><li>DELETE语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)</li></ul><h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL - 数据查询语言"></a>DQL - 数据查询语言</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>字段列表<br><span class="hljs-keyword">FROM</span><br>表名字段<br><span class="hljs-keyword">WHERE</span><br>条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>分组字段列表<br><span class="hljs-keyword">HAVING</span><br>分组后的条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><ul><li><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code><br>注：* 表示查询所有字段，不直观且影响效率</p></li><li><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], ... FROM 表名;</code>  </p></li><li><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li></ul><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code>  </p><p>条件:</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 没有身份证</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">or</span> idcard <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">-- 有身份证</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> idcard;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">-- 年龄在20到30之间</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span>;<br><span class="hljs-comment">-- 下面语句不报错，但查不到任何信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">-- 性别为女且年龄小于30</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;<br><span class="hljs-comment">-- 年龄等于25或30或35</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">35</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span> (<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>);<br><span class="hljs-comment">-- 姓名为两个字</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__&#x27;</span>;<br><span class="hljs-comment">-- 身份证最后为X</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%X&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="聚合查询（聚合函数）"><a href="#聚合查询（聚合函数）" class="headerlink" title="聚合查询（聚合函数）"></a>聚合查询（聚合函数）</h4><p>将一列数据作为一个整体，进行纵向计算。常见聚合函数有：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code><br>注：</p><ul><li>如果指定列，那么该列的NULL值不参与所有的聚合函数运算</li><li>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字&#x2F;字符串)的形式进行统计查询</li></ul><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code>  </p><p>注：</p><ul><li>where 和 having 的区别：<ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以</li></ul></li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li><li>执行顺序: where -&gt; 聚合函数 -&gt; having</li><li>支持多字段分组, 具体语法为 : group by columnA, columnB</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据性别分组，统计男性和女性数量</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br><span class="hljs-comment">-- 年龄小于45，并根据工作地址分组</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> workaddress;<br><span class="hljs-comment">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) address_count <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>注：</p><ul><li>排序方式：<ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul></li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 两字段排序，根据年龄升序排序，入职时间降序排序(如果年龄相同那么就按这个)</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, entrydate <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code>  </p><p>注：</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询第一页数据，展示10条</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee LIMIT <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 查询第二页</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee LIMIT <span class="hljs-number">10</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h4><p><strong>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</strong></p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/DQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="" title="alt DQL执行顺序"><h3 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL - 数据控制语言"></a>DCL - 数据控制语言</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><ul><li><p>查询用户：<br><code>SELECT * FROM mysql.user;</code></p></li><li><p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p></li><li><p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p></li><li><p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><p>注：</p><ul><li>在MySQL中需要通过<code>用户名@主机名</code>的方式，来唯一标识一个用户</li><li>主机名可以使用 % 通配</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-comment">-- 创建用户test，能在任意主机访问</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;test&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><ul><li><p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><p>注：</p><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是指一段可以直接被另外一段程序调用的程序或代码，主要分字符串函数、数值函数、日期函数、流程函数四类。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 拼接</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>);<br><span class="hljs-comment">-- 小写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><span class="hljs-comment">-- 大写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><span class="hljs-comment">-- 左填充</span><br><span class="hljs-keyword">SELECT</span> LPAD(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-comment">-- 右填充</span><br><span class="hljs-keyword">SELECT</span> RPAD(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-comment">-- 去除空格</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27; Hello World &#x27;</span>);<br><span class="hljs-comment">-- 切片（起始索引为1）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向上取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.1</span>);<br><span class="hljs-comment">-- 向下取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">1.9</span>);<br><span class="hljs-comment">-- 取模</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>);<br><span class="hljs-comment">-- rand</span><br><span class="hljs-keyword">select</span> rand();<br><span class="hljs-comment">-- round</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">2.344</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">-- 生成6位随机验证码</span><br><span class="hljs-keyword">select</span> lpad(round(rand() <span class="hljs-operator">*</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">0</span>), <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;0);</span><br></code></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- DATE_ADD</span><br><span class="hljs-keyword">SELECT</span> DATE_ADD(NOW(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">YEAR</span>);<br><span class="hljs-comment">-- 获取日期差</span><br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2022-10-01&#x27;</span>, <span class="hljs-string">&#x27;2022-12-01&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- if</span><br><span class="hljs-keyword">select</span> if(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;Ok&#x27;</span>, <span class="hljs-string">&#x27;Error&#x27;</span>);<br><span class="hljs-comment">-- ifnull</span><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;Ok&#x27;</span>, <span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-comment">-- case when then else end</span><br><span class="hljs-keyword">select</span> <br>    name, &#123; <span class="hljs-keyword">case</span> wordaddress <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;二线城市&#x27;</span> <span class="hljs-keyword">end</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span><br><span class="hljs-keyword">from</span> <br>    emp;<br></code></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>约束是用来作用于表中字段上的规则，用于限制存储在表中的数据。目的是为了保证数据库中的数据的正确性、有效性和完整性</p><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.16版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_user(<br>  id <span class="hljs-type">int</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY COMMENT <span class="hljs-string">&#x27;ID唯一标识&#x27;</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span> ,<br>  age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span>(age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span>) COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span> ,<br>  status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> COMMENT <span class="hljs-string">&#x27;状态&#x27;</span>,<br>  gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) COMMENT <span class="hljs-string">&#x27;性别&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><ul><li><p>添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时设置外键</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>  字段名 字段类型,<br>  ...<br>  [<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY(外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名)<br>);<br><br><span class="hljs-comment">-- 对已有的表添加外键</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名);<br><span class="hljs-comment">-- 示例</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key(dept_id) <span class="hljs-keyword">references</span> dept(id);  <br></code></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名;<br><span class="hljs-comment">-- 示例</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> key fk_emp_dept_id;<br></code></pre></td></tr></table></figure></li><li><p>删除&#x2F;更新行为<br>语法：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><p>其中，行为包括以下5种：</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><p>默认值是 <strong>No Action</strong></p></li></ul><h2 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多<ul><li>例如：一个部门对应多个员工</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>例如：一个学生可以选多门课程，一门课程也可以被多个学生选修  </li><li>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li><li>一对一<ul><li>例如：一个用户仅对应一个用户详情。常用于单表拆分，以提升操作效率</li><li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</li></ul></li></ul><h3 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h3><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况。在多表查询时，需要消除无效的笛卡尔积<br><code>select * from employee, dept where employee.dept = dept.id;</code></p></blockquote><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><ul><li>内连接查询的是两张表交集的部分</li><li>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code>   </li><li>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code>  </li><li>通常显式性能比隐式高</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工姓名，及关联的部门的名称</span><br><span class="hljs-comment">-- 隐式</span><br><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">as</span> e, dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">where</span> e.dept <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 显式</span><br><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">as</span> e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><ul><li><p>左外连接：  </p><ul><li>查询左表所有数据，以及两张表交集部分数据。相当于查询表1的所有数据，并包含表1和表2交集部分的数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code></li></ul></li><li><p>右外连接：  </p><ul><li>查询右表所有数据，以及两张表交集部分数据。相当于查询表2的所有数据，并包含表1和表2交集部分的数据。<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></li></ul></li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 两条语句效果一样。左外和右外可以互相转换</span><br><span class="hljs-comment">-- 左外 </span><br><span class="hljs-keyword">select</span> d.name, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> e.dept <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 右外</span><br><span class="hljs-keyword">select</span> d.name, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee e <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept <span class="hljs-operator">=</span> d.id;  <br></code></pre></td></tr></table></figure><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><ul><li>当前表与自身的连接查询，必须使用表别名</li><li>自连接查询，可以是内连接查询，也可以是外连接查询<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工及其所属领导的名字  </span><br><span class="hljs-keyword">select</span> a.name, b.name <span class="hljs-keyword">from</span> employee a, employee b <span class="hljs-keyword">where</span> a.manager <span class="hljs-operator">=</span> b.id;  <br><span class="hljs-comment">-- 没有领导的也查询出来  </span><br><span class="hljs-keyword">select</span> a.name, b.name <span class="hljs-keyword">from</span> employee a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> employee b <span class="hljs-keyword">on</span> a.manager <span class="hljs-operator">=</span> b.id;  <br></code></pre></td></tr></table></figure><h3 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 union, union all"></a>联合查询 union, union all</h3><ul><li>把多次查询的结果合并，形成一个新的查询结果</li><li>联合的多个查询结果的列数、字段类型必须保持一致</li><li>union all直接将结果合并，而union会自动去重</li><li>联合查询比使用or效率高，不会使索引失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A ...<br><span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B ...<br></code></pre></td></tr></table></figure></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</li><li>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</li></ul><ul><li>根据子查询结果可以分为：<ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul></li></ul><ul><li>根据子查询位置可分为：<ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul></li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><ul><li>子查询返回的结果是单个值，如数字、字符串、日期等。  </li><li>常用操作符：<code>= &lt;&gt; &gt; &gt;= &lt; &lt;=</code></li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询销售部所有员工</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>;<br><span class="hljs-comment">-- 根据销售部部门ID，查询员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-comment">-- 合并（子查询）</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><ul><li>返回的结果是一列（可以是多行）。  </li><li>常用操作符：  <table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table></li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>));<br><span class="hljs-comment">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><ul><li>返回的结果是一行（可以是多列）</li><li>常用操作符：<code>=, &lt;, &gt;, IN, NOT IN</code></li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与xxx的薪资及直属领导相同的员工信息  </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> (salary, manager) <span class="hljs-operator">=</span> (<span class="hljs-number">12500</span>, <span class="hljs-number">1</span>);  <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> (salary, manager) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, manager <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><ul><li>返回的结果是多行多列  </li><li>常用操作符：IN</li></ul><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> (job, salary) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx1&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx2&#x27;</span>);<br><span class="hljs-comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-keyword">as</span> e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.dept <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>MySQL的事务默认是自动提交的。开启事务后，只有手动提交才会改变数据库中的数据。</p></blockquote><h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><ul><li><p>控制事务方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看事务提交方式</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@AUTOCOMMIT</span>;<br><span class="hljs-comment">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@AUTOCOMMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure></li><li><p>控制事务方式二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启事务：</span><br><span class="hljs-keyword">START</span> TRANSACTION 或 <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-comment">-- DML</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 或回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性 ACID"></a>四大特性 ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="隔离级别："><a href="#隔离级别：" class="headerlink" title="隔离级别："></a>隔离级别：</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>√表示在当前隔离级别下该问题会出现。事务隔离级别越高，数据越安全，但是性能越低</p><ul><li>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code>  </li><li>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效。GLOBAL 表示对所有会话有效</li></ul><hr><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="alt MySQL架构图"><ul><li>连接层：<br>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li>服务层：<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li><li>引擎层：<br>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</li><li>存储层：<br>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</li></ul><blockquote><p>MySQL插件式的存储引擎架构，将查询处理和其它的系统任务以及数据的存储提取分离。<br>这种架构可以根据业务的需求和实际需要选择合适的存储引擎，可以在多种不同场景中应用并发挥良好作用。</p></blockquote><h3 id="MySQL三大存储引擎"><a href="#MySQL三大存储引擎" class="headerlink" title="MySQL三大存储引擎"></a>MySQL三大存储引擎</h3><blockquote><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。<br>存储引擎是基于表而不是基于库的，所以存储引擎也被称为表引擎。</p></blockquote><p>存储引擎相关语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询建表语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account;<br><span class="hljs-comment">-- 建表时指定存储引擎</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>...<br>) ENGINE<span class="hljs-operator">=</span>INNODB;<br><span class="hljs-comment">-- 查看当前数据库支持的存储引擎</span><br><span class="hljs-keyword">show</span> engines;<br></code></pre></td></tr></table></figure><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/MySQL%E5%BC%95%E6%93%8E%E5%88%97%E8%A1%A8.png" class="" title="alt MySQL引擎列表"><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><blockquote><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5之后，InnoDB是默认的MySQL引擎。  </p></blockquote><p>特点:</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（早期是frm、新版是sdi）、数据和索引。</li><li>innodb_file_per_table 参数决定多张表共享一个表空间还是每张表对应一个表空间<br><code>show variables like &#39;innodb_file_per_table&#39;;</code><br>从idb文件提取表结构数据的cmd命令：<br><code>ibd2sdi xxx.ibd</code></li></ul><p>InnoDB 逻辑存储结构：  </p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="" title="InnoDB逻辑存储结构"><ul><li><strong>表空间 - Tablespace</strong><br>InnoDB 存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</li><li><strong>段 - Segment</strong><br>表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个Extent区。</li><li><strong>区 - Extent</strong><br>区是表空间的单元结构，每个区的大小为1M。一个区包含多个Page页，InnoDB的页默认大小为16K，即一个区中有64个连续的页。</li><li><strong>页 - Page</strong><br>页是组成区的最小单元，页也是InnoDB磁盘管理的最小单元。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请 4-5 个区。</li><li><strong>行 - Row</strong><br>InnoDB 是面向行的，即数据是按行进行存放的。每一行除了表定义的字段外，还包含两个隐藏字段 Trx id 和 Roll pointer。</li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><blockquote><p>MyISAM 是 MySQL 早期的默认存储引擎。</p></blockquote><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><blockquote><p>Memory 引擎的表数据存储在内存中，受硬件、断电等问题的影响，因此只能将这些表作为临时表或缓存使用。缓存场景更多使用Redis。</p></blockquote><p>特点：</p><ul><li>存放在内存中，速度快</li><li>默认hash索引</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table><thead><tr><th align="center">特点</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">64TB</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">事务安全</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">锁机制</td><td align="center">行锁</td><td align="center">表锁</td><td align="center">表锁</td></tr><tr><td align="center">B+tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash索引</td><td align="center">-</td><td align="center">-</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持（5.6版本之后）</td><td align="center">支持</td><td align="center">-</td></tr><tr><td align="center">空间使用</td><td align="center">高</td><td align="center">低</td><td align="center">N&#x2F;A</td></tr><tr><td align="center">内存使用</td><td align="center">高</td><td align="center">低</td><td align="center">中等</td></tr><tr><td align="center">批量插入速度</td><td align="center">低</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">支持外键</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>总结InnoDB和MyISAM的区别：</p><ul><li>InnoDB支持事务, 而MyISAM不支持</li><li>InnoDB支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁</li><li>InnoDB支持外键, 而MyISAM不支持</li></ul><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><ul><li>InnoDB<br>如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM<br>如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的</li><li>Memory<br>将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><blockquote><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p></blockquote><h2 id="索引-⭐⭐⭐"><a href="#索引-⭐⭐⭐" class="headerlink" title="索引 ⭐⭐⭐"></a>索引 ⭐⭐⭐</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><blockquote><p>索引（index）是帮助 MySQL 高效获取数据的有序数据结构。<br>除了实际存储的数据，DBS 还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，可以借此实现高效的查找算法。<br>这种数据结构就是索引。</p></blockquote><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本  </li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列需要占用额外空间</li><li>索引大大提高了查询效率，但降低了更新的速度，如INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td><td align="center">不支持</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td><td align="center">5.6版本后支持</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><p>注：如果没有特别指明，一般指<strong>B+树</strong>结构组织的索引。</p><h4 id="普通索引结构"><a href="#普通索引结构" class="headerlink" title="普通索引结构"></a>普通索引结构</h4><ul><li><p>二叉树：</p><ul><li>根据值构造二叉排序树，树的形状依赖于插入顺序</li><li>顺序插入时会形成一个链表，大大降低查询性能</li><li>大数据量情况下，层级较深，检索速度慢</li></ul></li><li><p>红黑树：</p><ul><li>自平衡二叉树</li><li>仍然存在大数据量情况下，层级较深，检索速度慢的问题</li></ul></li></ul><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><ul><li>B树是一种<strong>多叉平衡查找树</strong>，相对于二叉树，B树每个节点可以有多个分支，即多叉。</li><li>如果一棵B树的最大度数为n (n阶)，则这棵B树每个节点最多存储 n-1 个key，以及 n 个指针</li><li>一旦节点存储的key数量到达n，就会裂变，中间元素向上分裂形成新的节点</li><li>B树中，非叶子节点和叶子节点都会存放实际数据</li><li>树的度数：一个节点的子节点个数，实现上即指针个数</li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/B-Tree.png" class="" title="alt B-Tree"><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><ul><li>B+Tree是B-Tree的变种</li><li>非叶子节点仅作为索引，不存储数据</li><li>叶子节点存储实际数据，且所有叶子节点形成一个单向链表</li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/B+Tree.png" class="" title="alt B+Tree"><ul><li>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的指针，所有叶子节点形成双向循环链表</li><li>这种B+Tree提高了区间访问的性能，利于排序</li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/MySQL_B+Tree.png" class="" title="alt MySQL_B+Tree"><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li>哈希索引就是采用一定的hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在Hash表中。</li><li>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了Hash冲突（也称为Hash碰撞），可以通过链表来解决。</li><li>特点：<ul><li>Hash索引只能用于对等比较<code>(=，in)</code>，不支持范围查询<code>(between，&gt;，&lt; ，...)</code></li><li>无法利用索引完成排序操作</li><li>查询效率高，通常 (不存在hash冲突的情况下) 只需要一次检索，效率通常高于B+Tree索引</li></ul></li><li>存储引擎支持：<ul><li>Memory存储引擎支持Hash索引</li><li>InnoDB具有自适应Hash功能，其索引根据B+Tree索引在指定条件下自动构建</li></ul></li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/Hash%E7%B4%A2%E5%BC%95.png" class="" title="alt Hash索引"><blockquote><p>综上，InnoDB选择B+Tree索引结构的原因有：</p><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>相对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，导致一页中存储的键值减少，指针也跟着减少，需要保存大量数据时，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul></blockquote><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>MySQL中，索引的具体类型主要分为以下几类：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td align="center">PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td align="center">UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td align="center"></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td align="center">FULLTEXT</td></tr></tbody></table><p>InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引 (Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引 (Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p><strong>聚集索引 选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><br><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" class="" title="alt 聚集索引和二级索引"><center>聚集索引和二级索引的具体结构</center><ul><li>聚集索引的叶子节点下挂的是这一行的数据</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值</li></ul><br><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" class="" title="alt 二级索引查找过程"><center>具体查找过程</center><p><strong>回表查询过程 (二级索引 -&gt; 主键值 -&gt; 聚集索引)：</strong></p><ul><li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询需要返回的数据是*，所以此时还需要根据主键值10，到聚集索引中查找10对应的完整记录，最终找到10对应的行row并返回。</li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ul><li><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果 CREATE 后面不加索引类型参数，则创建的是常规索引  </p></li><li><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code>  </p></li><li><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p></li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span><br><span class="hljs-keyword">create</span> index idx_user_name <span class="hljs-keyword">on</span> tb_user(name);<br><span class="hljs-comment">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone <span class="hljs-keyword">on</span> tb_user (phone);<br><span class="hljs-comment">-- 为profession, age, status创建联合索引</span><br><span class="hljs-keyword">create</span> index idx_user_pro_age_stat <span class="hljs-keyword">on</span> tb_user(profession, age, status);<br><br><span class="hljs-comment">-- 删除索引</span><br><span class="hljs-keyword">drop</span> index idx_user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><ul><li><p><strong>执行频率</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- session 是查看当前会话</span><br><span class="hljs-comment">-- global  是查询全局数据</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>慢查询日志</strong><br>指定SQL语句执行时间超过某个时间，就被视为慢查询，并记录下日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启MySQL慢日志查询开关</span><br>slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-comment">-- 设置超时时间为2秒</span><br>long_query_time<span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>profile</strong><br>在SQL优化时分析具体的时间开销</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- have_profiling参数查看当前MySQL是否支持profile操作</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have</span>_profiling;<br><span class="hljs-comment">-- 开启profiling</span><br><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况</span><br><span class="hljs-keyword">show</span> profiles;<br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br><span class="hljs-comment">-- 查看指定query_id的SQL语句的CPU使用情况</span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure></li><li><p><strong>explain</strong><br>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 直接在select语句之前加上关键字 explain / desc</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><p>explain执行计划中各个字段的含义：</p><table><thead><tr><th align="left">字段</th><th>含义</th></tr></thead><tbody><tr><td align="left">id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td align="left">select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td></tr><tr><td align="left">type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all</td></tr><tr><td align="left">possible_key</td><td>显示可能应用在这张表上的索引，一个或多个</td></tr><tr><td align="left">key</td><td>实际使用的索引，如果为NULL，则没有使用索引</td></tr><tr><td align="left">ken_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</td></tr><tr><td align="left">rows</td><td>MySQL认为必须要执行查询的行数。在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</td></tr><tr><td align="left">filtered</td><td>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</td></tr></tbody></table></li></ul><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><ul><li>单列索引：即一个索引只包含单个列</li><li>联合索引：即一个索引关联多个列</li></ul><blockquote><p>在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引。<br>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，选择该索引完成本次查询。</p></blockquote><p>联合索引结构图：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" class="" title="alt 联合索引结构"><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><ul><li>联合索引遵守最左前缀法则，即查询从索引的最左列开始，并且不跳过索引中的列。  </li><li>如果跳跃某一列，后面字段的排序就无法保证，因此后面字段的索引将失效。</li><li>最左前缀法则在select的时候，和字段书写的位置没有关系。</li><li>联合索引中，如果出现范围查询（&lt;, &gt;），其后的列索引将失效。可以用 &gt;&#x3D; 或者 &lt;&#x3D; 来规避索引失效问题。</li></ul><p>例如，一个联合索引的顺序是 profession -&gt; age -&gt; status (创建索引时定义的顺序), 只要select没有选中某一列，那么其后的索引都将失效，即查询时不会使用该列之后的字段索引。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li><p>在索引列上进行运算操作，索引将失效<br>如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></p></li><li><p>字符串类型不加引号，索引将失效<br>如：<code>explain select * from tb_user where phone = 17799990015;</code> </p></li><li><p>模糊查询中对头部模糊匹配，索引将失效<br>如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，<br>对前后都模糊匹配也会失效：<code>explain select * from tb_user where profession like &#39;%工%&#39;;</code><br>仅对尾部模糊匹配不会失效：<code>explain select * from tb_user where profession like &#39;软件%&#39;;</code></p></li><li><p>用 or 连接的条件，左右两侧字段都有索引时，索引才会生效<br>因为只要有一个没有索引，另一个用不用索引没有意义，仍要进行全表扫描，所以无需用索引。</p></li><li><p>数据分布的影响<br>如果 MySQL 评估使用索引比全表更慢，则不使用索引。因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p></li></ol><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>优化数据库的一个重要手段，在SQL语句中加入一些手动提示，优化MySQL的索引使用策略，以提升性能</p><ul><li>建议使用索引 - use index<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></li><li>忽略索引 - ignore index<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></li><li>强制使用索引 - force index<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><blockquote><p>应尽量使用覆盖索引，减少 <code>select *</code><br>即需要查询的数据在单个索引结构中能够全部获取到，避免回表查询</p></blockquote><p>explain 执行计划中 extra 字段含义：</p><ul><li><code>using index condition</code>：查找使用了索引，但是需要回表查询数据</li><li><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，不需要回表查询。因此性能更高</li></ul><p>非覆盖索引查询示意：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E9%9D%9E%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2.png" class="" title="alt 非覆盖索引查询"><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只对字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p><strong>语法：</strong><br><code>create index idx_xxxx on table_name(columnn(n));</code></p><p><strong>前缀长度：</strong><br>可以根据索引的选择性来决定。选择性指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>求选择性公式： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 全长度索引选择性</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br><span class="hljs-comment">-- 前缀索引选择性</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><p><strong>前缀索引查询示意：</strong></p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2.png" class="" title="alt 前缀索引查询"><ul><li>索引具体结构和索引创建时的字段声明顺序有关</li><li>前缀索引中有可能碰到相同索引的情况，因此拿到一个叶子节点(lvbu6)获取id后，需要回表查询row是否与where条件一致</li><li>回表查询结束后，还要对该叶子节点的后续节点(xiaoy)查询是否符合where条件，不符合则结束查询</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对数据量较大，且查询比较频繁的表建立索引</li><li>针对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引。查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="insert-优化"><a href="#insert-优化" class="headerlink" title="insert 优化"></a>insert 优化</h3><ul><li>批量插入数据，一次插入的数据不建议超过1000条，500 - 1000 为宜</li><li>手动控制事务</li><li>主键顺序插入，性能要高于乱序插入</li><li>大批量插入数据，如几百万条记录，使用insert性能较低。建议使用load指令将数据文件加载到数据表中<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile</span><br>mysql –<span class="hljs-operator">-</span><span class="hljs-keyword">local</span><span class="hljs-operator">-</span>infile <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@local</span>_infile;<br><br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中。字段间用逗号分割，行末添加换行</span><br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql.dat&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure></li></ul><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在InnoDB存储引擎中，表数据都是根据主键按序组织存放的，这种存储方式的表称为索引组织表（Index Organized Table - IOT）。</p><p>行数据存储在聚集索引的叶子节点上，记录在逻辑结构Page页中，每个页的大小是有限的，因此如果插入的数据行row在该页存储不下，将会存储到下一页中，页与页之间通过指针连接。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8.png" class="" title="alt 索引组织表"><p>但是如果主键是乱序插入的话，就会导致需要插入的位置为一页中间的位置，可能需要进行页分裂。</p><ul><li><p>页分裂：相邻页的空间都写满后，如果需要在中间插入一个新的数据行，必须对页进行分裂操作。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E9%A1%B5%E5%88%86%E8%A3%821.png" class="" title="alt 页分裂1"><center> 插入新row </center><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E9%A1%B5%E5%88%86%E8%A3%822.png" class="" title="alt 页分裂2"><center> 页分裂后 </center></li><li><p>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是被标记为删除，并且它的空间允许被其他记录使用。当页中删除的记录达到 MERGE_THRESHOLD（默认50%，可指定），InnoDB会开始寻找邻近页，看是否可以将多个页合并以优化空间使用。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E9%A1%B5%E5%90%88%E5%B9%B61.png" class="" title="alt 页合并1"><center> 删除达到MERGE_THRESHOLD </center><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E9%A1%B5%E5%90%88%E5%B9%B62.png" class="" title="alt 页合并2"><center> 页合并后 </center></li></ul><p><strong>主键设计原则：</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。二级索引的叶子节点保存的就是主键，所以主键小占用的空间也就会少。</li><li>插入数据时，尽量选择顺序插入，尽量使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号，占用空间大。</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h3><ul><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作。所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序，性能较低。</li><li>Using index：通过有序索引顺序扫描直接返回有序数据。借助已经有序的索引，不需要额外排序，因此性能高。</li></ul><blockquote><p>如果order by的字段存在索引，符合索引的排序顺序，且遵守最左前缀法则，则会直接using index，否则using filesort。</p></blockquote><p><strong>准则：</strong></p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h3><ul><li>在分组操作时，可以通过索引来提高效率，尽量规避 using temporary 的分组</li><li>分组操作时，索引的使用也满足最左前缀法则</li></ul><h3 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化方案：一般分页查询时，通过创建覆盖索引能够提高性能，可以通过覆盖索引加子查询的形式进行优化</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 此语句耗时很长</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 下面的语句会报错，因为 MySQL 不支持 in 子句里面使用 limit</span><br><span class="hljs-comment">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span><br><span class="hljs-comment">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">as</span> s, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> a <span class="hljs-keyword">where</span> s.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure><h3 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h3><p>如果数据量很大，执行count操作是非常耗时的。不同存储引擎的 count 实现机制不同：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（不使用带条件的count）</li><li>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者用redis  </p><p><strong>count的用法：</strong><br>对于一个row，如果count函数的参数对应的字段不是NULL，累计值就加一，最后返回累计值。</p><table><thead><tr><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>count(主键)</td><td>InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键自然不可能为null）</td></tr><tr><td>count(字段)</td><td>没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</td></tr><tr><td>count(1)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</td></tr><tr><td>count(*)</td><td>InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</td></tr></tbody></table><p>由于主键必然非空，因此count(主键) &#x3D; count(*) &#x3D; count(1)，而 count(null) 返回0<br>性能排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="update-优化"><a href="#update-优化" class="headerlink" title="update 优化"></a>update 优化</h3><p>执行删、改操作会对数据进行加锁，且行锁的性能高于表锁。InnoDB 的行锁是针对索引加锁，不是针对记录加锁，并且该索引不能失效，否则会从行锁升级为表锁。因此建议尽量使用覆盖索引。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code> 此SQL由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code> 此SQL由于name没有索引，所以会把整张表都锁住进行数据更新。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不实际存储在数据库中，数据来自定义视图的查询中使用的表(称为基表)，并且在使用视图时动态生成。通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以在创建视图时，主要工作落在创建SQL查询语句上。  </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>创建视图<br><code>CREATE [ OR REPLACE ] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code><br>如：<code>create or replace view stu_wll as select id, name from student where id &lt;= 10;</code></p></li><li><p>查看创建视图语句<br><code>SHOW CREATE VIEW 视图名称;</code></p></li><li><p>查看视图数据<br><code>SELECT * FROM 视图名称;</code></p></li><li><p>修改视图</p><ul><li><code>CREATE[OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></li><li><code>ALTER VIEW 视图名称 [(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code><br>如：<code>alter view stu_v_1 as select id, name from student where id &lt;= 10;</code></li></ul></li><li><p>删除视图<br><code>DROP VIEW [IF EXISTS] 视图名称 [, 视图名称 ... ]</code></p></li></ul><h3 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h3><p>MySQL允许一个视图依赖另一个视图，无论是否使用<code>WITH CHECK OPTION</code>，都会向下查询所依赖视图中的规则以保持一致性。<br>如果使用<code>WITH CHECK OPTION</code>创建视图，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。CASCADED (默认) 和 LOCAL 限定了检查的范围。</p><ul><li><p>CASCADED - 级联<br>自该视图起，向下所依赖视图的规则都将进行检查。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。  </span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> stu_V_l <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">20</span>;<br><span class="hljs-comment">-- 再创建 stu_v_2 视图，20 &gt;= id &gt;=10。  </span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> stu_v_2 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> stu_v_1 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span><span class="hljs-number">10</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">cascaded</span> <span class="hljs-keyword">check</span> option;<br><span class="hljs-comment">-- 再创建 stu_v_3 视图。     </span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> stu_v_3 <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> stu_v_2 <span class="hljs-keyword">where</span> id<span class="hljs-operator">&lt;=</span><span class="hljs-number">15</span>; <br><span class="hljs-comment">-- 这条数据能够成功，stu_v_3 没有开检查选项所以不会判断 id 是否小于等于15。但是stu_v_2的check option是级联的，因此会检查 stu_v_2 以及 stu_v_1 的条件。  </span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> stu_v_3 <span class="hljs-keyword">values</span>(<span class="hljs-number">17</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/cascade_cp.png" class="" title="alt cascade_cp"></li><li><p>LOCAL - 本地<br>仍会向下查询依赖视图的规则，但具体是否检查看各自视图的定义。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/local_cp.png" class="" title="alt local_cp"></li></ul><h3 id="更新条件"><a href="#更新条件" class="headerlink" title="更新条件"></a>更新条件</h3><p>要使视图可更新，视图中的行与基表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ul><li>聚合函数或窗口函数 (SUM()、MIN()、MAX()、COUNT() 等)</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>简单<br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 </li><li>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图可以让用户只能查询和修改他们所能见到的数据  </li><li>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul><blockquote><p>总而言之，视图类似于给表加上一个外壳，用户通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</p></blockquote><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，即语言层面的代码封装与重用。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，提高数据处理的效率。</p><p><strong>特点:</strong></p><ul><li>封装</li><li>复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，提升效率</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称( [参数列表] ) <br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">SQL</span> 语句 <br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>注: 在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter更换SQL语句的结束符。默认是分号作为结束符。</p></li><li><p>调用<br><code>CALL 名称 ([参数]);</code></p></li><li><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询指定数据库的存储过程及状态信息</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="hljs-keyword">WHERE</span> ROUTINE_SCHEMA <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-comment">-- 查询某个存储过程的定义</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称;<br></code></pre></td></tr></table></figure></li><li><p>删除<br><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称;</code></p></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>  由MySQL服务器提供，分全局Global变量、会话Session变量</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看所有系统变量</span><br><span class="hljs-keyword">SHOW</span> [ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ] VARIABLES;<br><span class="hljs-comment">-- 可以通过LIKE模糊匹配方式查找变量</span><br><span class="hljs-keyword">SHOW</span> [ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ] VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;......&#x27;</span>; <br><span class="hljs-comment">-- 查看指定变量的值</span><br><span class="hljs-keyword">SELECT</span> @@[SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>].系统变量名;<br><br><span class="hljs-comment">-- 设置系统变量，默认作用域 session</span><br><span class="hljs-comment">-- MySQL服务重启后全局参数会复原。如要永久修改参数，需要修改MySQL的配置文件</span><br><span class="hljs-keyword">SET</span> [ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ] 系统变量名 <span class="hljs-operator">=</span> 值 ;<br><span class="hljs-keyword">SET</span> @@[ SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span> ].系统变量名 <span class="hljs-operator">=</span> 值 ;<br></code></pre></td></tr></table></figure><h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>  用户根据需要自己定义的变量，不需要提前声明，用的时候直接用<code>@变量名</code>即可。未声明或者未初始化则默认为null。作用域为当前会话。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 赋值1</span><br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var</span>_name <span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var</span>_name <span class="hljs-operator">=</span> expr] ... ;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var</span>_name :<span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var</span>_name :<span class="hljs-operator">=</span> expr] ... ;<br><br><span class="hljs-comment">-- 赋值2</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var</span>_name :<span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var</span>_name :<span class="hljs-operator">=</span> expr] ... ;<br><br><span class="hljs-comment">-- 赋值3</span><br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@var</span>_name <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>  根据需要定义在局部块的变量，访问之前需要DECLARE声明。可用作存储过程的局部变量和输入参数。作用范围是声明所在的BEGIN…END块中</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 声明</span><br><span class="hljs-keyword">DECLARE</span> 变量名 变量类型 [<span class="hljs-keyword">DEFAULT</span> ... ] ;<br><br><span class="hljs-comment">-- 赋值</span><br><span class="hljs-keyword">SET</span> 变量名 <span class="hljs-operator">=</span> 值 ;<br><span class="hljs-keyword">SET</span> 变量名 :<span class="hljs-operator">=</span> 值 ;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> 变量名 <span class="hljs-keyword">FROM</span> 表名 ... ;<br></code></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">IF 条件<span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br>  .....<br>ELSEIF 条件<span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span>   <span class="hljs-comment">-- 可选</span><br>  .....<br><span class="hljs-keyword">ELSE</span> <span class="hljs-comment">-- 可选</span><br>  .....<br><span class="hljs-keyword">END</span> IF;<br></code></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，调用时需要传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，作为调用的返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>  示例：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p4(<span class="hljs-keyword">in</span> score <span class="hljs-type">int</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">begin</span><br>  if score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">85</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;优秀&#x27;</span>;<br>  elseif score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;及格&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> :<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;不及格&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">call</span> p4(<span class="hljs-number">18</span>, <span class="hljs-variable">@result</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@result</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p5(<span class="hljs-keyword">inout</span> score <span class="hljs-keyword">double</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">set</span> score :<span class="hljs-operator">=</span> score <span class="hljs-operator">*</span> <span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@score</span> <span class="hljs-operator">=</span> <span class="hljs-number">198</span>;<br><span class="hljs-keyword">call</span> p5(<span class="hljs-variable">@score</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@score</span>;<br></code></pre></td></tr></table></figure></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法1 - 值判断</span><br><span class="hljs-keyword">CASE</span> case_value<br>  <span class="hljs-keyword">WHEN</span> when_value1 <span class="hljs-keyword">THEN</span> statement_list1<br>  [ <span class="hljs-keyword">WHEN</span> when_value2 <span class="hljs-keyword">THEN</span> statement_list2] ...<br>  [ <span class="hljs-keyword">ELSE</span> statement_list ]<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br><span class="hljs-comment">-- 语法2 - 逻辑判断</span><br><span class="hljs-keyword">CASE</span><br>  <span class="hljs-keyword">WHEN</span> search_condition1 <span class="hljs-keyword">THEN</span> statement_list1<br>  [<span class="hljs-keyword">WHEN</span> search_condition2 <span class="hljs-keyword">THEN</span> statement_list2] ...<br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br><span class="hljs-comment">-- 注：如果判定条件有多个，多个条件之间可以使用 and 或 or 进行连接。</span><br></code></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- while - 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br>WHILE 条件 DO<br>  <span class="hljs-keyword">SQL</span>逻辑...<br><span class="hljs-keyword">END</span> WHILE;<br><br><span class="hljs-comment">-- repeat - 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br>REPEAT<br>  <span class="hljs-keyword">SQL</span>逻辑...<br>  UNTIL 条件<br><span class="hljs-keyword">END</span> REPEAT;<br><br><span class="hljs-comment">-- loop - 配合leave, iterate使用</span><br>[label:] LOOP<br>  <span class="hljs-keyword">SQL</span>逻辑...<br><br>  <span class="hljs-comment">-- 退出指定标记的循环体</span><br>  leave lable;<br>  <span class="hljs-comment">-- 直接进入下一次循环</span><br>  iterate lable;<br><span class="hljs-keyword">END</span> LOOP [label];<br></code></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。</p><ul><li><p>声明游标：<br><code>DECLARE 游标名称 CURSOR FOR 查询语句</code></p></li><li><p>打开游标：<br><code>OPEN 游标名称</code></p></li><li><p>获取游标记录：<br><code>FETCH 游标名称 INTO 变量 [ ,变量 ]</code></p></li><li><p>关闭游标<br><code> CLOSE 游标名称</code></p></li></ul><p><strong>条件处理程序：</strong><br>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。<br>具体语法为：<br><code>DECLARE handler_action HANDLER FOR condition_value [, condition value] ... statement</code><br>其中，handler_action 的取值有：</p><ul><li>CONTINUE：继续执行当前程序</li><li>EXIT：终止执行当前程序</li></ul><p>condition_value 的取值有:</p><ul><li><code>SQLSTATE sqlstate_value</code>：指定状态码，如02000</li><li><code>SQLWARNING</code>：所有以01开头的SQLSTATE代码的简写</li><li><code>NOT FOUND</code>：所有以02开头的SQLSTATE代码的简写</li><li><code>SQLEXCEPTION</code>：所有没被 SQLWARNING 或 NOT FOUND 捕获的SQLSTATE代码的简写</li></ul><p>示例：<br>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> p1l(<span class="hljs-keyword">in</span> uage <span class="hljs-type">int</span>)<br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">-- 注：必须先声明普通变量，再声明游标</span><br>    <span class="hljs-keyword">declare</span> uname <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>); <br>    <span class="hljs-keyword">decLare</span> upro <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">-- 声明游标</span><br>    <span class="hljs-keyword">declare</span> u_cursor <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">select</span> name,profession <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> uage; <br><br>    <span class="hljs-comment">-- 当条件处理程序的处理的状态码为02000的时候，就会退出。</span><br>    <span class="hljs-keyword">declare</span> exit handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">SQLSTATE</span> <span class="hljs-string">&#x27;02000&#x27;</span> <span class="hljs-keyword">close</span> u_cursor;<br><br>    <span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_user_pro; <br>    <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> tb_user_pro(<br>      id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment, <br>      name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>), <br>      profession <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>    );<br>    <span class="hljs-comment">-- 开启游标</span><br>    <span class="hljs-keyword">open</span> u_cursor;<br>    <br>    while <span class="hljs-literal">true</span> do<br>      <span class="hljs-comment">-- 获取游标中的记录</span><br>      <span class="hljs-keyword">fetch</span> u_cursor <span class="hljs-keyword">into</span> uname,Upro;<br>      <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_user_pro <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, uname, upro); <br>    <span class="hljs-keyword">end</span> while;<br><br>    <span class="hljs-keyword">close</span> u_cursor;<br>  <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型。但一般都可以用存储过程替换。</p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 存储函数名称 ([ 参数列表 ])<br><span class="hljs-keyword">RETURNS</span> type [characteristic ...]<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- SQL语句</span><br>  <span class="hljs-keyword">RETURN</span> ...;<br><span class="hljs-keyword">END</span> ;<br></code></pre></td></tr></table></figure><p>其中，characteristic可选值有：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。   </p><p>触发器使用别名OLD和NEW来引用触发器中发生变化的记录内容。目前MySQL触发器只支持行级触发，不支持语句级触发，即变化的行数就是触发器执行的次数。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE</td><td>OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td></tr><tr><td>DELETE</td><td>OLD表示将要或者已经删除的数据</td></tr></tbody></table><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>BEFORE<span class="hljs-operator">/</span>AFTER <span class="hljs-keyword">INSERT</span><span class="hljs-operator">/</span><span class="hljs-keyword">UPDATE</span><span class="hljs-operator">/</span><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> tbl_name <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-comment">-- 行级触发器</span><br><span class="hljs-keyword">BEGIN</span><br>  trigger_stmt;<br><span class="hljs-keyword">END</span>;<br><br><span class="hljs-comment">-- 查看</span><br><span class="hljs-keyword">SHOW</span> TRIGGERS;<br><br><span class="hljs-comment">-- 删除</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> [schema_name.]trigger_name;<br></code></pre></td></tr></table></figure><h2 id="锁-⭐⭐⭐"><a href="#锁-⭐⭐⭐" class="headerlink" title="锁 ⭐⭐⭐"></a>锁 ⭐⭐⭐</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote><p>全局锁就是对整个数据库实例加锁，是一个重操作，加锁后整个实例就处于只读状态，后续的DML写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞。全局锁典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。  </p></blockquote><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加全局锁</span><br>flush tables <span class="hljs-keyword">with</span> read lock;<br><span class="hljs-comment">-- 数据备份</span><br>mysqldump <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> db_name <span class="hljs-operator">&gt;</span> backup_path<br><span class="hljs-comment">-- 释放锁</span><br>unlock tables;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），导致主从延迟。</li><li>InnoDB引擎中，可以在备份时加上<code>--single-transaction</code>参数完成不加锁的一致性数据备份</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><blockquote><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。表级锁主要分为<strong>表锁、元数据锁、意向锁</strong>三类。</p></blockquote><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p><strong>分类：</strong></p><ul><li>表共享读锁（read lock）: 所有事务（包括当前加锁的客户端）都只能读，不能写 </li><li>表独占写锁（write lock）: 当前加锁的客户端可读可写，其他客户端不可读也不可写。</li></ul><p><strong>语法：</strong></p><ul><li>加锁：<code>lock tables tb_name... read/write</code></li><li>解锁: <code>unlock tables</code> 或 断开客户端连接</li></ul><h4 id="元数据锁（Meta-Data-Lock，MDL）"><a href="#元数据锁（Meta-Data-Lock，MDL）" class="headerlink" title="元数据锁（Meta Data Lock，MDL）"></a>元数据锁（Meta Data Lock，MDL）</h4><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的一致性，避免DML与DDL冲突，保证读写的正确性。也就是说表上有活动事务的时候，不可以对元数据进行写入操作。</p><p>当对一张表进行增删改查的时候，加元数据共享锁;当对表结构进行变更操作的时候，加元数据排他锁。具体SQL语句的加锁如下：</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read &#x2F;write</td><td>SHARED_READ_ONLY &#x2F;SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select, select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>查看当前数据库中的加锁情况：<br><code>select object_type, object_schema, object_name,lock_type, lock_duration from performance_schema.metadata_locks;</code></p><h4 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h4><p>为了避免DML在执行时，加的行锁与表锁冲突造成性能降低，InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。  </p><p>引入意向锁后，如果一个客户端对某一行加上了行锁，那么系统会自动对其加上意向锁，当别的客户端试图对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。  </p><p><strong>意向锁兼容性：</strong></p><ul><li>意向共享锁（IS）：与表锁的共享读锁兼容，与表锁独占写锁互斥。由<code>select ... lock in share mode;</code>添加</li><li>意向排他锁（lX）：与表锁的共享读锁及独占写锁都互斥。由<code>insert, update, delete, select ... for update</code>添加</li></ul><p>注：意向锁之间不会互斥。一旦事务提交，IS、IX 都会自动释放。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><blockquote><p>每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。InnoDB数据基于索引组织，行级锁通过对索引上的索引项进行加锁实现，而不是对记录加锁。行级锁主要分为<strong>行锁、间隙锁、临键锁</strong>三类。</p></blockquote><h4 id="行锁（Record-Lock）"><a href="#行锁（Record-Lock）" class="headerlink" title="行锁（Record Lock）"></a>行锁（Record Lock）</h4><p>锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC（read commit ）、RR（repeatable read）隔离级别下都支持。</p><p><strong>分类：</strong></p><ul><li>共享锁S：允许获取共享锁的事务读行记录，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁X：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>即共享锁和共享锁之间相互兼容，排他锁和其它任何锁都冲突。</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加锁</td><td></td></tr><tr><td>select … lock in share mode</td><td>共享锁</td><td>需手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … for update</td><td>排他锁</td><td>需手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>注：</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li></ul><h4 id="间隙锁（Gap-Lock）-amp-临键锁（Next-Key-Lock）："><a href="#间隙锁（Gap-Lock）-amp-临键锁（Next-Key-Lock）：" class="headerlink" title="间隙锁（Gap Lock）&amp; 临键锁（Next-Key Lock）："></a>间隙锁（Gap Lock）&amp; 临键锁（Next-Key Lock）：</h4><p>间隙锁对索引记录间隙（不含该记录）加锁，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。例如两个临近叶子节点为15和23，那么间隙就是指开区间(15 , 23)，锁的就是这个间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><p>而临键锁是行锁和间隙锁的组合，同时锁住数据和数据前面的间隙Gap。在RR隔离级别下支持。默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用临键锁进行搜索和索引扫描，以防止幻读。</p><p>注：</p><ul><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，临键锁退化为间隙锁。</li><li>索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止。</li></ul><h2 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="" title="alt"><ul><li><p>表空间<br>表空间是InnoDB逻辑结构的最高层，如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启)，则每张表都会有一个表空间（xxx.ibd文件）。一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p></li><li><p>段<br>分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）。InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即B+树的非叶子节点。段用来管理多个Extent（区）。</p></li><li><p>区<br>表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p></li><li><p>页<br>是InnoDB磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB引擎每次从磁盘申请4-5个区。一页包含若干行。</p></li><li><p>行<br>InnoDB存储引擎按行存放数据。行中有两个隐藏字段 Trx_id（最近一次行更新对应的事务id）, Roll_pointer（找到该记录修改前的信息）</p></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><strong>InnoDB整体业务逻辑：</strong><br>  当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/InnoDB%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png" class="" title="alt InnoDB存储架构"><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" class="" title="alt 内存结构"><ul><li><p><strong>Buffer Pool</strong><br>缓冲池是主内存中的一个区域，可以缓存磁盘上经常操作的数据。在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘I0，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用</li><li>clean page：被使用的page，数据没有被修改过</li><li>dirty page：脏页，被使用过，且数据被修改过，即内存数据和磁盘数据不一致</li></ul></li><li><p><strong>Change Buffer</strong><br>更改缓冲区，针对非唯一二级索引页。在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更记录在 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer 之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p></li><li><p><strong>Adaptive Hash Index</strong><br>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了自适应hash索引。hash索引在进行等值匹配时，一般性能是要高于B+树的，但是hash索引不适合做范围查询、模糊匹配等。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p>InnoDB的自适应哈希索引，无需人工干预，由系统根据情况自动完成。</p></li><li><p><strong>Log Buffer</strong><br>日志缓冲区，用于保存要写入到磁盘中的log日志数据（redo log 、undo log）。默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>涉及参数：</p><ul><li>innodb_log_buffer_size 缓冲区大小</li><li>innodb_flush_log_at_trx_commit 日志刷新到磁盘时机，取值有三个：<ul><li>0：每秒将日志写入并刷新到磁盘一次</li><li>1：默认值，日志在每次事务提交时写入并刷新到磁盘</li><li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul></li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/InnoDB%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png" class="" title="alt 磁盘结构"><ul><li><p>System Tablespace<br>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。参数 innodb_data_file_path，默认文件为ibdata1。</p></li><li><p>File-Per-Table Tablespaces<br>如果开启了innodb_file_per_table开关，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p></li><li><p>General Tablespaces<br>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表空间</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>SPACE ts_name <span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;file_name&#x27;</span> ENGINE <span class="hljs-operator">=</span> engine_name;<br><span class="hljs-comment">-- 创建表时指定表空间</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> xxx ... TABLESPACE ts_name;<br></code></pre></td></tr></table></figure></li><li><p>Undo Tablespaces<br>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p></li><li><p>Temporary Tablespaces<br>InnoDB 使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据。</p></li><li><p>Doublewrite Buffer Files<br>双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p></li><li><p>Redo Log<br>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息存到该日志中, 用于在刷新脏页到磁盘发生错误时, 进行数据恢复。</p></li></ul><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><ul><li><p>Master Thread<br>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p></li><li><p>IO Thread<br>在InnoDB存储引擎中大量使用了AIO(异步IO)来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。可以通过<code>show engine innodb status;</code> 查询当前后台线程的状态。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read Thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write Thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log Thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert Buffer Thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table></li><li><p>Purge Thread<br>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p></li><li><p>Page Cleaner Thread<br>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p></li></ul><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>事务的四大特征ACID：</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。依赖于undo log。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。依赖于undo log + redo log。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。依赖于锁机制 + MVCC。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。依赖于redo log。</li></ul><p>其中，原子性，一致性，持久性这三大特性由 redo log 和 undo log 两份日志来保证。而隔离性由锁机制和MVCC保证。</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。<br>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘发生错误时，进行数据恢复使用。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/redo_log.png" class="" title="alt redo_log"><blockquote><ol><li>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。</li><li>事物每次提交的时候都会将数据刷到redo log中而不是直接将buffer pool中的数据直接刷到磁盘中（ibd文件中），是因为redo log 是顺序写，性能处理的够快，直接刷到ibd中，是随机写，性能慢。所以脏页是在下一次读的时候，或者后台线程采用一定的机制进行刷盘到ibd中。<br>这种先写日志的方式，称为 WAL(Write-Ahead Logging)</li></ol></blockquote><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息，作用包括提供回滚（提供事务原子性）和MVCC（多版本并发控制）。</p><p>undo log不同于redo log记录物理日志，它是逻辑日志。可以认为当delete一条记录，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。  </p><blockquote><ol><li>undo log 销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>undo log 存储：undo log采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment。</li></ol></blockquote><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><p>当前读<br>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><ul><li>select…lock in share mode（共享锁）。</li><li>select..…for update、update、insert、delete（排他锁）<br>都是一种当前读。</li></ul></li><li><p>快照读<br>简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul></li></ul><p>MVCC 全称 Multi-Version Concurrency Control 多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的<strong>三个隐式字段、undo log、readview</strong>。</p><ul><li><p><strong>三个隐式字段</strong></p><table><thead><tr><th>隐式字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>其中，前两个字段必然会添加的，是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p></li><li><p><strong>undo log</strong></p><ul><li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li></ul><p>版本链：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/undo_log_%E7%89%88%E6%9C%AC%E9%93%BE.png" class="" title="alt undo_log_版本链"><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></li><li><p><strong>readview</strong><br>读视图是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的未提交事务id。</p><p>四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>版本链数据的访问规则：</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id &#x3D;&#x3D; creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事务更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在ReadView生成后才开启</td></tr><tr><td>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>成立，说明数据已经提交</td></tr></tbody></table><blockquote><p>Read Commited 隔离级别下，在事务中每一次执行快照读时生成ReadView。<br>Repeatable Read 隔离级别下，在事务中第一次执行快照读时生成ReadView，后续会复用。</p></blockquote></li></ul><h2 id="MySQL-管理"><a href="#MySQL-管理" class="headerlink" title="MySQL 管理"></a>MySQL 管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ul><li><p>mysql<br>mysql客户端工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法 ：<br>  mysql [options] [database]<br>选项 ：<br>  -u, --user=name       <span class="hljs-comment">#指定用户名</span><br>  -p, --password[=name] <span class="hljs-comment">#指定密码</span><br>  -h, --host=name       <span class="hljs-comment">#指定服务器IP或域名</span><br>  -P, --port=port       <span class="hljs-comment">#指定连接端口</span><br>  -e, --execute=name    <span class="hljs-comment">#执行SQL语句并退出。方便执行批处理脚本</span><br>示例：<br>  mysql -uroot –p123456 study -e <span class="hljs-string">&quot;select * from tb_sku&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>mysqladmin<br>执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<br>  mysqladmin [options] <span class="hljs-built_in">command</span> ...<br>选项:<br>  -u, --user=name       <span class="hljs-comment">#指定用户名</span><br>  -p, --password[=name] <span class="hljs-comment">#指定密码</span><br>  -h, --host=name       <span class="hljs-comment">#指定服务器IP或域名</span><br>  -P, --port=port       <span class="hljs-comment">#指定连接端口</span><br>示例：<br>  mysqladmin -uroot –p1234 drop <span class="hljs-string">&#x27;test01&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>mysqlbinlog<br>服务器生成的日志文件以二进制格式保存，需用mysqlbinlog查看这些文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法 ：<br>  mysqlbinlog [options] log-files1 log-files2 ...<br>选项 ：<br>  -d, --database=name   <span class="hljs-comment">#指定数据库名称，只列出指定的数据库相关操作。</span><br>  -o, --offset=n        <span class="hljs-comment">#忽略掉日志中的前n行命令。</span><br>  -r,--result-file=name <span class="hljs-comment">#将输出的文本格式日志输出到指定文件。</span><br>  -s, --short-form      <span class="hljs-comment">#显示简单格式， 省略掉一些信息。</span><br>  --start-datatime=date1 --stop-datetime=date2  <span class="hljs-comment">#指定日期间隔内的所有日志。</span><br>  --start-position=pos1 --stop-position=pos2    <span class="hljs-comment">#指定位置间隔内的所有日志。</span><br>示例：<br>  mysqlbinlog -s binlog.00008<br></code></pre></td></tr></table></figure></li><li><p>mysqlshow<br>客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法 ：<br>  mysqlshow [options] [db_name [table_name [col_name]]]<br>选项 ：<br>  --count   <span class="hljs-comment">#显示数据库及表的统计信息（数据库，表 均可以不指定）</span><br>  -i        <span class="hljs-comment">#显示指定数据库或者指定表的状态信息</span><br>示例：<br>  <span class="hljs-comment">#查询test库中book表的详细情况</span><br>  mysqlshow -uroot -p2143 <span class="hljs-built_in">test</span> book --count<br></code></pre></td></tr></table></figure></li><li><p>mysqldump<br>用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法 ：<br>  mysqldump [options] db_name [tables]<br>  mysqldump [options] --database/-B db1 [db2 db3...]<br>  mysqldump [options] --all-databases/-A<br>连接选项 ：<br>  -u, --user=name         <span class="hljs-comment">#指定用户名</span><br>  -p, --password[=name]   <span class="hljs-comment">#指定密码</span><br>  -h, --host=name         <span class="hljs-comment">#指定服务器ip或域名</span><br>  -P, --port=p            <span class="hljs-comment">#指定连接端口</span><br>输出选项：<br>  --add-drop-database     <span class="hljs-comment">#在每个数据库创建语句前加上 drop database 语句</span><br>  --add-drop-table        <span class="hljs-comment">#在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br>  -n, --no-create-db      <span class="hljs-comment">#不包含数据库的创建语句</span><br>  -t, --no-create-info    <span class="hljs-comment">#不包含数据表的创建语句</span><br>  -d, --no-data           <span class="hljs-comment">#不包含数据</span><br>  -T, --tab=name          <span class="hljs-comment">#自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span><br>示例：<br>  mysqldump -uroot -p1234 -T D:/ db01 tb_score<br></code></pre></td></tr></table></figure></li><li><p>mysqlimport &#x2F; source<br>客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。如果需要导入sql文件,可以使用mysql中的source 指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法：<br>  mysqlimport [options] db_name textfile1 [textfile2...]<br>  <span class="hljs-built_in">source</span> /root/xxxxx.sql<br>示例：<br>  mysqlimport -uroot -p2143 <span class="hljs-built_in">test</span> /tmp/city.txt<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p><p>查看错误日志位置：<br><code>show variables like &#39;%log_error%&#39;;</code></p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。默认开启。</p><p><strong>作用：</strong></p><ul><li>灾难时的数据恢复</li><li>MySQL的主从复制</li></ul><p><strong>查看参数：</strong><br>  <code>show variables like &#39;%log_bin%&#39;;</code><br>查询结果中：</p><ul><li>log_bin_basename：当前数据库服务器的binlog日志的前缀，具体文件名需要再加上编号(从000001开始)</li><li>log_bin_index：binlog的索引文件，记录了当前服务器关联的binlog文件有哪些</li></ul><p><strong>日志格式：</strong></p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td></tr></tbody></table><p>通过<code>show variables like &#39;%binlog_format%;</code>查看</p><p><strong>日志查看：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqlbinlog [ 参数选项 ] logfilename<br><br>参数选项：<br>  -d    <span class="hljs-comment">#指定数据库名称，只列出指定的数据库相关操作。</span><br>  -o    <span class="hljs-comment">#忽略掉日志中的前n行命令。</span><br>  -v    <span class="hljs-comment">#将行事件(数据变更)重构为SQL语句</span><br>  -vv   <span class="hljs-comment">#将行事件(数据变更)重构为SQL语句，并输出注释信息</span><br></code></pre></td></tr></table></figure><p><strong>清理日志：</strong></p><ul><li><code>reset master</code><br>删除全部 binlog 日志。删除之后，日志编号将从000001重新开始</li><li><code>purge master logs to &#39;binlog.*&#39;</code><br>删除 * 编号之前的所有日志</li><li><code>purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code><br>删除”yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志</li></ul><p>也可以在mysql的配置文件中配置二进制日志的过期时间，日志过期会自动删除:<br>  <code>show variables like &#39;%binlog_expire_logs_seconds%&#39;;</code></p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。<br>查询日志默认未开启，如需开启修改配置文件。开启查询日志后，所有客户端的增删改查操作都会记录在该日志文件中，长时间运行该日志文件将会非常大。</p><p>查看参数：<br>  <code>show variables like &#39;%general%&#39;;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数<code>long_query_time</code>设置值并且扫描记录数不小于<code>min_examined_row_limit</code>的所有的SQL语句的日志，<code>long_query_time</code>默认为10秒，最小为0，精度可以到微秒。且默认情况下不会记录管理语句，也不会记录不使用索引进行查找的查询。<br>慢查询日志默认未开启，如需开启修改配置文件。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>主从复制是指将主数据库 Master 的 DDL 和 DML 操作通过二进制日志传到从库服务器 Slave 中，然后在从库上对这些日志重新执行（重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p><p><strong>作用：</strong></p><ul><li>主库出现问题，可以快速切换到从库提供服务</li><li>实现读写分离，降低主库的访问压力</li><li>可以在从库中执行备份，以避免备份期间影响主库服务</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心是二进制日志，过程如图：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" class="" title="alt 主从复制"><p>具体分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 binlog 中。</li><li>从库读取主库的二进制日志文件 binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><ol><li>准备两个MySQL服务</li><li>配置主库<br><code>show master status</code> 查看二进制坐标</li><li>配置从库<br><code>change master to master_host=*, master_user=*,master_password=*, master_log_file=*, master_log_pos=*;</code><table><thead><tr><th>参数名</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog 日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog 日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table></li><li>开启同步<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 8.0.22之后：</span><br><span class="hljs-keyword">start</span> replica;<br><span class="hljs-comment">-- 8.0.22之前：</span><br><span class="hljs-keyword">start</span> slave;<br></code></pre></td></tr></table></figure></li><li>查看主从同步状态<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 8.0.22之后：</span><br><span class="hljs-keyword">start</span> replica status;<br><span class="hljs-comment">-- 8.0.22之前：</span><br><span class="hljs-keyword">start</span> slave status;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ul><li>IO瓶颈<br>热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈。</li><li>CPU瓶颈<br>排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</li></ul><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="alt 分库分表示意图"><p>为了解决上述问题，需要对数据库进行分库分表处理。其中心思想是将数据分散存储，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能瓶颈问题，从而达到提升数据库性能的效果。</p><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>按形式分为垂直拆分、水平拆分。按粒度分为分库和分表，因此共四种拆分策略。<br>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5.png" class="" title="alt 拆分策略"><ul><li><p>垂直分库<br>以表为依据，根据业务将不同表拆分到不同库中。<br>特点：</p><ul><li>每个库的表结构都不一样</li><li>每个库的数据也不一样</li><li>所有库的并集是全量数据</li></ul></li><li><p>垂直分表<br>以字段为依据，根据字段属性将不同字段拆分到不同表中。<br>特点：</p><ul><li>每个表的结构都不一样</li><li>每个表的数据也不一样，一般通过主键&#x2F;外键关联</li><li>所有表的并集是全量数据</li></ul></li><li><p>水平分库<br>以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。<br>特点：</p><ul><li>每个库的表结构都一样</li><li>每个库的数据都不一样</li><li>所有库的并集是全量数据</li></ul></li><li><p>水平分表<br>以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。<br>特点：</p><ul><li>每个库的表结构都一样</li><li>每个库的数据都不一样</li><li>所有库的并集是全量数据</li></ul></li></ul><h3 id="实现技术-MyCat"><a href="#实现技术-MyCat" class="headerlink" title="实现技术 - MyCat"></a>实现技术 - MyCat</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li></ul><p>以下介绍以MyCat为例。</p><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在，开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>优势：</p><ul><li>性能可靠稳定</li><li>强大的技术团队</li><li>体系完善</li><li>社区活跃</li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/MyCat%E6%A6%82%E5%BF%B5%E5%9B%BE.png" class="" title="alt MyCat概念图"><p>MyCat的逻辑结构主要包括逻辑库、逻辑表、分片规则、分片节点。而具体的数据存储还是在物理结构，也就是数据库服务器中存储的。</p><h4 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h4><ul><li>范围分片：根据指定的字段及其配置的范围与数据节点的对应情况来决定数据属于哪一个分片</li><li>取模分片：根据指定的字段值与节点数量进行求模运算，根据运算结果决定该数据属于哪一个分片</li><li>一致性Hash分片：相同的哈希因子计算值总是被划分到相同的分区表中</li><li>枚举分片：通过在配置文件中配置可能的枚举值, 指定数据分布到不同数据节点上。适用于按照省份、性别、状态拆分数据等业务</li><li>应用指定算法：运行阶段由应用自主决定路由到哪个分片，直接根据字符子串（必须是数字）计算分片号</li><li>固定分片Hash算法：指定二进制位进行与运算</li><li>字符串Hash解析算法：截取字符串中的指定位置的子字符串，进行hash算法，算出分片</li><li>按天分片算法：按照日期及对应的时间周期分片</li><li>自然月分片：按照月份来分片，每个自然月为一个分片</li></ul><h4 id="管理与监控"><a href="#管理与监控" class="headerlink" title="管理与监控"></a>管理与监控</h4><ul><li>执行原理：<img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/MyCat%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" class="" title="alt MyCat执行原理"></li><li>Mycat-web（Mycat-eye）是 Mycat 可视化运维的管理和监控平台，引入ZooKeeper作为配置中心，可以管理多个节点</li><li>Mycat-web 管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等，为优化 SQL 提供依据</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>例如用MyCat实现的一主一从读写分离示意图：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="alt 主从分离示意图"><p>将写操作分配到 Master 上，读操作分配到 Slave 上，实现负载均衡。但这种方案如果 Master 宕机，那么业务系统就只能读不能写了，因此可以引入双主双从：</p><img src="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="alt 双主双从示意图"><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。</p><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度字符串</td><td>M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>VARCHAR(M)</td><td>变长字符串</td><td>L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td>TINYTEXT</td><td>短文本字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>长文本字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等长度文本数据</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>极大文本数据</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><p>一般定长的效率要高于变长字符串</p><h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)&#x2F;8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</td><td>4 个字节</td></tr></tbody></table><h2 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h2><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Grant Table Column</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td align="left">Synonym for “all privileges”</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td align="left"><code>Alter_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td align="left"><code>Alter_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td align="left"><code>Create_priv</code></td><td align="left">Databases, tables, or indexes</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td align="left"><code>Create_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td align="left"><code>Create_routine_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td align="left"><code>Create_tablespace_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td align="left"><code>Create_tmp_table_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td align="left"><code>Create_user_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td align="left"><code>Create_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td align="left"><code>Delete_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td align="left"><code>Drop_priv</code></td><td align="left">Databases, tables, or views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td align="left"><code>Drop_role_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td align="left"><code>Event_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td align="left"><code>Execute_priv</code></td><td align="left">Stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td align="left"><code>File_priv</code></td><td align="left">File access on server host</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td align="left"><code>Grant_priv</code></td><td align="left">Databases, tables, or stored routines</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td align="left"><code>Index_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td align="left"><code>Insert_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td align="left"><code>Lock_tables_priv</code></td><td align="left">Databases</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td align="left"><code>Process_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td align="left">See <code>proxies_priv</code> table</td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td align="left"><code>References_priv</code></td><td align="left">Databases or tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td align="left"><code>Reload_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td align="left"><code>Repl_client_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td align="left"><code>Repl_slave_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td align="left"><code>Select_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td align="left"><code>Show_db_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td align="left"><code>Show_view_priv</code></td><td align="left">Views</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td align="left"><code>Shutdown_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td align="left"><code>Super_priv</code></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td align="left"><code>Trigger_priv</code></td><td align="left">Tables</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td align="left"><code>Update_priv</code></td><td align="left">Tables or columns</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td align="left">Synonym for “no privileges”</td><td align="left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th align="left">Privilege</th><th align="left">Context</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td align="left">Dual password administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td align="left">Allow queries blocked by audit log filter</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td align="left">Audit log administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td align="left">Backup administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td align="left">Backup and Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td align="left">Clone administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td align="left">Firewall administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td align="left">Redo log archiving administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td align="left">NDB Cluster</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td align="left">Authentication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td align="left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td align="left">Replication administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td align="left">Resource group administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td align="left">Server administration</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td align="left">Server administration</td></tr></tbody></table><h2 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h2><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><blockquote><p>[1] <a href="https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868">https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868</a><br>[2] <a href="https://github.com/Buildings-Lei/mysql_note/blob/main/README.md">https://github.com/Buildings-Lei/mysql_note/blob/main/README.md</a><br>[3] <a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?share_source=copy_web">https://www.bilibili.com/video/BV1Kr4y1i7ru?share_source=copy_web</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-并发</title>
    <link href="/2022/11/20/Java-%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/11/20/Java-%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>《实战Java高并发程序设计》学习笔记</p><h1 id="第-1-章-走入并行世界"><a href="#第-1-章-走入并行世界" class="headerlink" title="第 1 章 - 走入并行世界"></a>第 1 章 - 走入并行世界</h1><h2 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h2><ul><li>同步：一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li><li>异步：一旦开始，调用就会立即返回，调用者可以继续后续的操作</li></ul><ul><li>并发：多个任务交替执行</li><li>并行：多个任务同时执行</li></ul><ul><li>临界区：表示一种公共资源或共享数据，可以被多个线程使用，但同一时间只能有一个线程使用。一旦临界区资源被占用，其它线程想要使用就必须等待</li></ul><ul><li>阻塞：一个线程占用了临界区资源，其它线程必须等待，导致线程挂起，就是阻塞</li><li>非阻塞：没有一个线程可以防碍其他线程执行，所有线程都会尝试不断前进</li></ul><p>多线程的活跃性问题：</p><ul><li>死锁：多个线程都占有其它线程需要的资源，且都不释放，从而没有一个线程可以同时拿到所有资源，造成所有线程都进入等待</li><li>饥饿：某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行</li><li>活锁：多个线程在竞争资源时，都主动释放给其它线程使用，导致资源不断在两个线程间跳动，从而没有一个线程可以同时拿到所有资源</li></ul><h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><ul><li>阻塞：其它线程释放资源之前，当前线程无法继续执行（悲观）</li><li>无饥饿：对于公平锁，所有线程遵守先进先出的原则，就不会产生饥饿</li><li>无障碍：任何线程都可以进入临界区，但是一旦检测到冲突就需要回滚（乐观）</li><li>无锁：无锁并行都是无障碍的，任何线程都可以进入临界区，且必然有一个线程可以在有限步内完成操作并离开。通常包含一个无限循环尝试竞争</li><li>无等待：要求所有线程在有限步内完成操作，分为有界无等待和与线程数无关的无等待。典型的如RCU（Read Copy Update），对读不加控制，修改只针对副本，并在合适的时机写回</li></ul><h2 id="并行加速定律"><a href="#并行加速定律" class="headerlink" title="并行加速定律"></a>并行加速定律</h2><pre><code class="hljs">加速比 = 优化前耗时 / 优化后耗时</code></pre><ol><li>Amdahl 定律<br>并行优化的效果取决于CPU数量，以及系统中的串行化代码的比例。CPU数量越多，串行化比例越低，优化效果越好。仅增加CPU数量而不降低串行化比例，无法提高系统性能。</li><li>Gustafson 定律<br>只要增加处理器，就能获得更快的速度。如果可被并行化的代码所占比例足够大，那么加速比就能随着处理器数量线性增长。</li></ol><h2 id="JMM-并发原则"><a href="#JMM-并发原则" class="headerlink" title="JMM 并发原则"></a>JMM 并发原则</h2><ul><li>原子性：<ul><li>一个操作不可中断</li><li>对于32位JVM，long和double两个64位数据的读写是不保证原子性的</li></ul></li><li>可见性：<ul><li>一个线程修改了某个共享变量，其它线程是否能够立即得知这个修改。</li><li>原因在于缓存优化、硬件优化、指令重排、编辑器的优化等</li><li>在一个线程中观察另一个线程的变量，它们的值是否能观察到、何时能观察到是没有保证的</li></ul></li><li>有序性：<ul><li>程序在执行时可能会进行指令重排，于原指令的顺序未必一致</li><li>原因在于一条指令的执行，对于CPU来说需要分为多个步骤依次执行，为了提高CPU效率，使用了流水线技术。这样就可能某个步骤需要等另一指令的某个步骤先完成，从而产生中断。为了尽可能减少流水线的中断，因此需要做指令重排</li><li>不能重排的指令：Happen-Before规则 保证指令重排不会破坏原有的语义<ul><li>程序顺序原则：在一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写先于读发生，保证了volatile变量的可见性</li><li>锁规则：unlock必然发生在随后的lock前</li><li>传递性：A先于B，B先于C，则A必先于C</li><li>线程<code>start()</code>方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结<code>Thread.join()</code></li><li>线程的中断<code>interrupt()</code>先于被中断线程的代码</li><li>对象构造函数的执行、结束先于<code>finalize()</code></li></ul></li></ul></li></ul><hr><h1 id="第-2-章-并行程序基础"><a href="#第-2-章-并行程序基础" class="headerlink" title="第 2 章 - 并行程序基础"></a>第 2 章 - 并行程序基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>进程是程序的基本执行实体，是线程的容器</li><li>线程是轻量级进程，是程序执行的最小单位</li><li>线程的切换和调度的成本远远小于进程</li><li>线程的状态：<ul><li>NEW：刚刚创建，线程还没开始执行</li><li>RUNNABLE：线程正在执行，拥有所需的一切资源</li><li>BLOCKED：遇到sychronized同步块暂停执行，进入同步队列(尝试获取锁但失败的线程)，直到获得请求的锁</li><li>WAITING：无限等待，等待一些特殊事件，如notify(), join()</li><li>TIMED_WAITING：有限等待</li><li>TERMINATED：线程执行完毕</li></ul></li></ul><pre><code class=" mermaid">stateDiagram  NEW --&gt; RUNNABLE: 启动  RUNNABLE --&gt; BLOCKED: synchronized  BLOCKED --&gt; RUNNABLE: synchronized  RUNNABLE --&gt; WAITING: wait()  WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TIMED_WAITING: wait()  TIMED_WAITING --&gt; RUNNABLE: notify()  RUNNABLE --&gt; TERMINATED: 结束</code></pre><h2 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h2><ul><li><p>新建线程：</p><ul><li>extends Thread()::run()</li><li>implements Runnable::run()</li><li>new Thread(Runnable)::start()</li></ul></li><li><p>终止线程：</p><ul><li>Thread::stop(), 不推荐使用。因为会立即终止线程，并释放持有的锁，可能破坏对象一致性</li></ul></li><li><p>线程中断：</p><ul><li>Thread::interrupt() 中断线程</li><li>Thread::isInterrupted() 判断是否中断</li><li>static boolean Thread.interrupted() 判断是否中断，并清除当前中断状态</li><li>Thread::sleep()方法由于中断抛出异常时，会清除中断标志位</li></ul></li><li><p>线程等待</p><ul><li>Object::wait() 对象所在线程停止运行，释放CPU和锁资源，进入等待队列</li><li>Object::notify() 随机唤醒一个等待队列中的线程进入同步队列</li><li>Object::notifyAll() 唤醒等待队列中的的所有线程进入同步队列</li><li>工作原理：<ul><li>每个Object拥有一个等待该对象锁的<code>等待队列</code>，和一个尝试获取锁但失败的线程<code>同步队列</code></li><li>wait()和notify()执行前会先获取Object对象的监视器，执行后释放监视器。因此调用必须包含在对应的synchronized块中</li><li>wait()会主动释放目标对象锁，而sleep()不会释放锁资源，仅让出CPU，且不能被唤醒</li><li>notify()不会立即释放CPU和锁资源，而是等同步代码执行完毕才释放</li></ul></li></ul></li><li><p>线程挂起和恢复 – deprecated</p><ul><li>Thread::suspend() 挂起线程且不释放任何锁资源。挂起的线程竟然属于Runnable状态</li><li>Thread::resume()</li></ul></li><li><p>等待线程结束和谦让</p><ul><li>Thread::join( [millis] ) 无限&#x2F;有限等待，直到目标线程，也就是调用的对象线程执行完毕</li><li>Thread::yield() 让出当前CPU</li><li>join()方法底层是通过wait()实现的，调用的线程执行完毕后会执行notifyAll()唤醒所有等待队列的线程进入同步队列</li></ul></li></ul><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul><li>volatile关键字告诉JVM,该变量极有可能会被某些程序或者线程修改</li><li>volatile有助于操作的原子性,可见性,有序性</li><li>但volatile不能代替锁，不保证一些复合操作的原子性</li></ul><h2 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">tg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>( <span class="hljs-string">&quot;PrintGroup&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T2&quot;</span>);<br>t1.start();<br>t2.start();<br>System.out.println(tg.activeCount()); <span class="hljs-comment">// 获得活动线程总数</span><br>tg.list();  <span class="hljs-comment">//打印线程组中所有线程</span><br></code></pre></td></tr></table></figure><h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><ul><li>完成一些系统性服务，例如GC线程、JIT线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonT</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 必须在守护线程开始之前设置，否则当作普通的用户线程执行</span><br>t.start();  <span class="hljs-comment">// 只要主线程结束，整个程序就会结束，不管守护线程是否结束</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>Java的线程优先级从低到高为1-10</li><li>Thread::setPriority(int)</li><li>优先级的后果不可预测，无法精确控制。因此如果要求严格，仍需要自己在应用层解决线程调度问题</li></ul><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ul><li>对同步的代码加锁，使得每次只有一个线程进入同步块，从而保证现成的安全性</li><li>如果指定加锁对象，则进入同步代码前要先获得指定对象的锁</li><li>如果作用于实例方法，相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>如果作用于静态方法，相当于对当前类加锁，进入同步代码前要获得当前类的锁</li><li>synchronized还可以保证线程间的可见性和有序性（使多线程串行执行）</li></ul><h2 id="并发下的隐蔽错误"><a href="#并发下的隐蔽错误" class="headerlink" title="并发下的隐蔽错误"></a>并发下的隐蔽错误</h2><ul><li>如非线程安全的ArrayList, HashMap, Integer等等</li><li>jps查看系统运行的Java程序，jstack pid 打印指定java进程的内部线程及其堆栈</li></ul><hr><h1 id="第-3-章-JDK并发包"><a href="#第-3-章-JDK并发包" class="headerlink" title="第 3 章 - JDK并发包"></a>第 3 章 - JDK并发包</h1><h2 id="同步控制工具"><a href="#同步控制工具" class="headerlink" title="同步控制工具"></a>同步控制工具</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote><p>可重入锁，性能和synchronized相当，但使用更灵活，提供额外的高级功能</p></blockquote><ul><li>ReentrantLock::lock() 获得锁，如果锁已经被占用，则等待</li><li>ReentrantLock::lock(boolean fair) 公平锁，维护一个等待队列，先来后到</li><li>ReentrantLock::lockInterruptibly() 获得锁，但优先响应中断</li><li>ReentrantLock::tryLock() 尝试获得锁，不等待直接返回。如果成功返回true，失败返回false。</li><li>ReentrantLock::tryLock(time, TimeUnit) 在给定时间内尝试获取锁</li><li>ReentrantLock::unlock 释放锁</li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><blockquote><p>与重入锁关联的wait &#x2F; notify机制</p></blockquote><ul><li>Lock::newCondition()</li><li>Condition::await() 使当前线程进入等待队列，同时释放当前锁。要求先获得相关锁</li><li>Condition::awaitUninterruptibly() 使当前线程进入等待队列，但等待时不响应中断。要求先获得相关锁</li><li>Condition::signal() &#x2F; signalAll() 唤醒一个&#x2F;所有等待队列中的线程。要求先获得相关锁</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote><ol><li>基于许可的多线程控制<br>  为每个访问共享区间的线程派发一个许可，拿到许可的线程才能进入共享区间活动。完成任务离开共享区间时，必须归还许可，以确保后续的线程可以正常取得许可。如果许可用完，则线程必须先等待。</li><li>排他锁和共享锁<br>  排他模式下，只有一个线程可以访问共享变量。而共享模式下，则允许多个线程同时访问共享变量。例如，重入锁是排他的，信号量是共享的。</li></ol></blockquote><p>信号量是对锁的扩展，允许多个线程同时访问共享资源</p><ul><li>Semaphore(int permits, [boolean fair]) 构造信号量，指定准入数，可选是否公平</li><li>Semaphore::acquire(), Semaphore::acquireUninterruptibly()</li><li>Semaphore::tryAcquire(), Semaphore::tryAcquire(timeout, TimeUnit)</li><li>Semaphore::release()</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><blockquote><p>JDK5提供的读写分离锁，可以有效地减少锁竞争，提升系统性能。</p></blockquote><ul><li>读写锁的访问约束：<ul><li>读与读不互斥</li><li>读与写互斥</li><li>写与写互斥</li></ul></li><li>API:<ul><li>实现类：ReentrantReadWriteLock()</li><li>ReadWriteLock::readLock(), ReadWriteLock::writeLock()</li><li>锁操作和ReentrantLock基本一致</li></ul></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote><p>倒计数器，Latch：门闩。通常用来控制线程等待，让某一个线程等倒计数结束再开始执行</p></blockquote><ul><li>CountDownLatch(int count) 指定数量的线程完成任务后，等待在Latch上的线程才能继续执行</li><li>CountDownLatch::countDown() 通知Latch一个线程已经完成了任务，计数器减一</li><li>CountDownLatch::await() 设置Latch阻止线程继续执行，直到指定数量的线程执行至此</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote><p>循环栅栏，每若干个线程任务执行完，调用一次指定的动作</p></blockquote><ul><li>CyclicBarrier(int parties, Runnable barrierAction) 每若干个任务完成，执行一次barrierAction</li><li>CyclicBarrier::await() 设置Barrier阻止线程继续执行，直到指定数量的线程执行至此</li><li>BrokenBarrierException 表示当前Barrier已经破损，可能无法等待所有线程到齐。例如一个线程被中断，其它线程就会收到该异常</li></ul><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote><p>线程阻塞工具，可以在线程内任意位置让线程阻塞，不需要先获得对象锁，也不抛出InterruptedException，弥补了suspend&#x2F;resume导致线程无法继续执行的情况</p></blockquote><ul><li>static LockSupport::park(), parkNanos(), parkUntil() (有限)阻塞当前线程。支持中断响应，通过Thread.interrupted()获得中断标记</li><li>static LockSupport::unpark(thread) 类似信号量机制给予线程继续执行的许可，但许可数量仅为1</li></ul><h3 id="深度理解-AbstractQueuedSynchronizer"><a href="#深度理解-AbstractQueuedSynchronizer" class="headerlink" title="深度理解 AbstractQueuedSynchronizer"></a>深度理解 AbstractQueuedSynchronizer</h3><blockquote><p>重入锁、信号量内部各有一个AbstractQueuedSynchronizer的子类Sync。<br>Sync内部维护了一个同步等待队列，保存等待在这个锁上的线程，如lock()引起的等待。<br>还维护了一个条件变量等待队列，保存等待在条件变量上的等待变量，如Condition.await()引起阻塞的线程。<br>一个重入锁可以生成多个条件变量，因此可能有多个条件变量等待队列<br>AbstractQueuedSynchronizer是重入锁、信号量、读写锁等并发工具的核心</p></blockquote><h3 id="Guava-和-RateLimiter"><a href="#Guava-和-RateLimiter" class="headerlink" title="Guava 和 RateLimiter"></a>Guava 和 RateLimiter</h3><blockquote><p>Guava是Google的一个核心库，常用作项目的基础工具库。RateLimiter是其中的一个限流工具库<br>为了维持服务器的负载平稳，需要进行限流措施。普通的平均限流过于简单粗暴。经典的两种限流算法：</p><ul><li>漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先保存在缓存区内，然后再以固定的流速流出缓存区并加以处理。特点是无论外部请求压力如何，总是以固定的流速处理数据。漏桶容积和流出速率是该算法的两个重要参数。</li><li>令牌桶算法：桶中存放令牌，程序只有拿到令牌才能对请求进行处理。没有令牌则要么丢弃请求，要么等待可用令牌。该算法在单位时间产生一定量的令牌存入桶中，桶的容量有限，且令牌数不会超过桶的容量。</li></ul><p>Guava中的RateLimiter采用了令牌桶算法</p></blockquote><h2 id="线程复用-ThreadPool"><a href="#线程复用-ThreadPool" class="headerlink" title="线程复用 - ThreadPool"></a>线程复用 - ThreadPool</h2><blockquote><p>虽然与进程相比，线程是一种轻量级的工具，但其创建和销毁依然需要花费时间，线程过多容易导致创建和销毁的开销大于真实工作的时间，同时大量线程会抢占宝贵的内存资源，导致OOM，给GC带来压力。因此，对线程的使用需要掌握一个度。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为了避免系统频繁的创建和销毁线程，利用线程池技术对线程进行复用<br>线程池负责对线程进行控制和管理。其中有活跃线程，需要时直接拿来用，完成工作后不关闭，返回线程池，方便其它任务执行。</p><h3 id="JDK-Executor框架"><a href="#JDK-Executor框架" class="headerlink" title="JDK - Executor框架"></a>JDK - Executor框架</h3><ul><li>Executors 线程池工厂，返回ExecutorService (ThreadPoolExecutor) 对象，表示一个线程池<ul><li><code>newFixedThreadPool</code>: 返回一个固定线程数量的线程池。新任务提交时，若有空闲线程立即执行，否则暂存在任务队列中</li><li><code>newSingleThreadExecutor</code>: 返回只有一个线程的线程池</li><li><code>newCachedThreadPool</code>: 返回一个可调整线程数量的线程池。新任务提交时，优先使用可复用线程，否则创建新线程处理任务。所有线程完成后返回线程池，空闲线程有存活时间</li><li><code>newSingleThreadScheduledExecutor</code>: 返回一个ScheduledExecutorService对象，线程数量为1。用于实现延时、周期任务。如果中途任务出现异常，后续执行都会被中断。<ul><li>schedule(Runnable, delay, TimeUnit) 延迟执行任务</li><li>scheduleAtFixedRate(Runnable, initialDelay, period, TimeUnit) 固定速率循环执行任务。但必须等上一个任务执行完才会开始下一个</li><li>scheduleWithFixedDelay(Runnable, initialDelay, delay, TimeUnit) 上一个任务执行完间隔delay后开始下一个</li></ul></li><li><code>newScheduledThreadPool</code>: 返回一个ScheduledExecutorService对象，线程数量可指定</li></ul></li></ul><pre><code class=" mermaid">classDiagram  Executor &lt;|-- ExecutorService  &lt;&lt;interface&gt;&gt; Executor  Executor: + execute(Runnable)  &lt;&lt;interface&gt;&gt; ExecutorService  ExecutorService: + shutdown()  ExecutorService: + isTerminated()  ExecutorService: + submit()  ExecutorService: + ......()  AbstractExecutorService ..|&gt; ExecutorService  AbstractExecutorService &lt;|-- ThreadPoolExecutor  ThreadPoolExecutor: +ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</code></pre><h3 id="线程池内部实现-ThreadPoolExecutor"><a href="#线程池内部实现-ThreadPoolExecutor" class="headerlink" title="线程池内部实现 - ThreadPoolExecutor"></a>线程池内部实现 - ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,      <span class="hljs-comment">// 指定常驻线程数量</span><br>                   <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">// 指定允许的最大线程数量</span><br>                   <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">// 当线程数量超过corePoolSize后，多余的空闲线程的存活时间</span><br>                   TimeUnit unit,         <span class="hljs-comment">// keepAliveTime单位</span><br>                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">// 任务队列，保存被提交但尚未被执行的任务</span><br>                   ThreadFactory threadFactory,       <span class="hljs-comment">// 线程工厂，用于创建线程</span><br>                   RejectedExecutionHandler handler   <span class="hljs-comment">// 任务过多时的拒绝策略</span><br>                   )<br></code></pre></td></tr></table></figure><h4 id="任务队列-BlockingQueue"><a href="#任务队列-BlockingQueue" class="headerlink" title="任务队列 - BlockingQueue"></a>任务队列 - BlockingQueue</h4><p>指被提交但未执行的任务队列，一个BlockingQueue接口的对象，仅用于存放Runnable对象。常用的队列实现有：</p><ul><li><code>SynchronousQueue</code>: 直接提交的队列，没有容量，来一个任务执行一个，没有多余线程则执行拒绝策略</li><li><code>ArrayBlockingQueue</code>: 有界任务队列，构造时指定容量</li><li><code>LinkedBlockingQueue</code>: 无界任务队列，任务繁忙时会一直创建线程执行，直至资源耗尽</li><li><code>PriorityBlockingQueue</code>: 带有执行优先级的无界队列</li></ul><p>使用自定义线程池时，需要根据应用的具体情况，选择合适的并发队列为任务做缓冲。当线程资源紧张时，不同的并发队列对系统行为和性能的影响均不同。</p><pre><code class=" mermaid">graph LR  任务提交 -- 小于corePoolSize --&gt; end1(分配线程执行)  任务提交 -- 大于corePoolSize --&gt; 提交到等待队列 -- 成功 --&gt;等待执行  提交到等待队列 -- 失败 --&gt; 提交线程池 -- 已达到最大线程数 --&gt; 拒绝执行  提交线程池 -- 未达到最大线程数 --&gt; end2(分配线程执行)</code></pre><h4 id="拒绝策略-RejectedExecutionHandler"><a href="#拒绝策略-RejectedExecutionHandler" class="headerlink" title="拒绝策略 - RejectedExecutionHandler"></a>拒绝策略 - RejectedExecutionHandler</h4><p>指定当任务数量超过系统实际承载能力时的策略，通常是线程池中的线程已经用完，达到了最大线程数，排队队列也已满的情况。ThreadPoolExecutor提供了以下策略：</p><ul><li><code>AbortPolicy</code>: 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>CallersRunsPolicy</code>: 绕过线程池，由主线程直接调用任务的run()方法执行</li><li><code>DiscardOldestPolicy</code>: 抛弃队列中等待最久的任务，然后尝试再次提交当前任务</li><li><code>DiscardPolicy</code>: 丢弃且不抛异常</li></ul><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 - ThreadFactory"></a>线程工厂 - ThreadFactory</h4><p>ThreadFactory接口用来创建线程，其中仅有一个方法<code>Thread newThread(Runnable r);</code><br>通常使用<code>Executors.defaultThreadFactory()</code>即可</p><h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>通过重写ThreadPoolExecutor中提供的接口对线程池进行控制</p><ul><li>ThreadPoolExecutor::beforeExecute(Thread t, Runnable r) 线程执行前</li><li>ThreadPoolExecutor::afterExecute(Runnable r, Throwable t) 线程执行后</li><li>ThreadPoolExecutor::terminated() 线程池销毁后</li></ul><h4 id="获取线程池的堆栈信息"><a href="#获取线程池的堆栈信息" class="headerlink" title="获取线程池的堆栈信息"></a>获取线程池的堆栈信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(...);<br><br><span class="hljs-comment">// 1. 用execute()替代submit()</span><br>pools.execute(task)<br><br><span class="hljs-comment">// 2. 使用Future (第五章)</span><br><span class="hljs-type">Future</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pools.submit(task)<br>result.get();<br><br><span class="hljs-comment">// 3. 扩展ThreadPoolExecutor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h3><blockquote><p>Java Concurrency in Practice 一书给出了估算线程池大小的公式：<br>$$<br>N_{threads} &#x3D; N_{cpu} \times U_{cpu} \times (1 + \frac{W}{C}<br>$$<br>其中，<br>$ N_{cpu} &#x3D; CPU的数量 $<br>$ U_{cpu} &#x3D; 目标CPU的使用率0-1之间 $<br>$ \frac{W}{C} &#x3D; 等待时间与计算时间的比率 $</p></blockquote><h3 id="Fork-x2F-Join-框架"><a href="#Fork-x2F-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><blockquote><p>Fork: 创建子线程，使得系统进程可以多一个执行分支<br>Join: 等待分支执行结束，获得最终结果<br>ForkJoinPool 可以优化多分支任务的执行，提高效率。例如多线程的负载均衡。但如果任务的划分层次很多且一直得不到返回值，可能出现性能严重下降，或导致栈溢出，引发异常。</p></blockquote><ul><li>ForkJoinPool::submit(ForkJoinTask&lt;T&gt;)  向ForkJoinPool线程池提交一个ForkJoinTask (支持 fork() &#x2F; join() 的任务)</li><li>ForkJoinTask两个子类：RecursiveAction 和 RecursiveTask, 前者没有返回值，后者可以携带返回值</li></ul><h3 id="Guava-线程池"><a href="#Guava-线程池" class="headerlink" title="Guava 线程池"></a>Guava 线程池</h3><ul><li>MoreExecutors::DirectExecutor 提供了一个简单的线程池实现。该线程池不创建额外线程，总是在当前线程中执行任务。便于使用统一的编码风格处理同步和异步调用，简化设计。</li><li>MoreExecutors::getExitingExecutorService() 将普通线程转为Daemon线程池，从而可以在程序执行外后，即便有线程池存在，也能结束线程</li><li>MoreExecutors还提供了对Future模式的扩展，见第5章</li></ul><h2 id="JDK-并发容器"><a href="#JDK-并发容器" class="headerlink" title="JDK 并发容器"></a>JDK 并发容器</h2><p>大部分容器都在java.util.concurrent包中，Collections工具类可以将任意集合包装成线程安全的集合。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Collections::synchronizedMap(map)方法可以将普通map包装成线程安全的map，但是内部频繁使用mutex互斥锁，性能较低。更好的选择是juc下的ConcurrentHashMap，专门为并发进行了性能优化，更适合多线程的场合。</p><ul><li>内部数据结构<ul><li><code>int SizeCtl</code> 记录参与Map扩展的线程数量，或新table的扩容阈值</li><li><code>CounterCell[]</code> 记录元素的个数</li><li><code>Node&lt;K, V&gt;[] table</code> 实际存放Map内容的地方</li><li><code>Node&lt;K, V&gt;[] nextTable</code> 当Table需要扩容时，会把新数据填充到nextTable中</li></ul></li><li>节点类型<ul><li><code>Node</code>: 若干链表构成的数组，每个元素是链表的表头</li><li><code>TreeBin</code>: 当链表长度大于等于8时，会将链表树状化，变成一棵红黑树</li><li><code>ForwardingNode</code>: 当数组容量达到75%时，数组将进行扩容。扩容过程中已经完成复制的老数组元素用ForwardingNode对象替代，表示当前槽位数据已经处理过了，避免竞争</li></ul></li></ul><pre><code class=" mermaid">classDiagram  Node &lt;|-- TreeNode  Node &lt;|-- ForwardingNode  Node &lt;|-- TreeBin  TreeNode *-- TreeBin  class Node &#123;    + hash: int    + key: K    + val: V    + next: Node  &#125;   class TreeNode &#123;    + parent: TreeNode    + left: TreeNode    + right: TreeNode    + prev: TreeNode    +red: boolean  &#125;    class ForwardingNode&#123;    + nextTable: Node&lt;K, V&gt;  &#125;  class TreeBin &#123;    + root: TreeNode    + first: TreeNode    + waiter: Thread    + prev: TreeNode    + red: boolean  &#125;</code></pre><ul><li>put()方法实现步骤<ul><li>尝试初始化数组</li><li>可能参与帮助扩容 - helpTransfer()</li><li>根据对应槽位是链表还是红黑树，放入给定的key、value</li><li>统计元素总数 - CounterCell()</li><li>根据是否达到负载因子，默认0.75，触发扩容操作。扩容会将一半的元素移到新空间，且相对位置不变</li></ul></li><li>get()方法实现步骤<ul><li>根据hash值得到对应槽位</li><li>若槽位第一个元素key和请求的一样，直接返回</li><li>否则调用对应的find()进行查找<ul><li>链表：顺序查找</li><li>ForwardingNode::find()</li><li>TreeBin::find()</li></ul></li></ul></li></ul><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>可以通过Collections.synchronizedList(new LinkedList&lt;String&gt;())得到线程安全的LinkedList。对于队列，更推荐使用ConcurrentLinkedQueue。</p><ul><li>ConcurrentLinkedQueue 使用无锁CAS保证并发安全，需要处理可能存在的不一致问题，增加了设计和实现难度，但极大提升了性能</li><li>head, tail分别表示链表的头、尾。但tail的更新并不是及时的，可能产生拖延，每次更新会跳跃两个元素</li></ul><blockquote><p>TODO: 第4章 - 无锁并发</p></blockquote><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>对于CopyOnWriteArrayList，不仅读完全不用加锁，写操作也不会阻塞读操作。只有写操作之间需要进行同步等待。</p><ul><li>所谓CopyOnWrite，就是在写入时，进行一次自我复制，修改时对副本进行操作，写完后再替换原本的数据，这样就保证写操作不影响读操作</li></ul><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>一种实现数据共享通道的接口。主要实现有ArrayBlockingQueue(有界), LinkedBlockingQueue(无界), PriorityBlockingQueue(优先级)…<br>BlockingQueue让服务线程在队列为空时进行等待，有新消息进入队列后，自动将线程唤醒</p><p>以ArrayBlokcingQueue为例：</p><ul><li>压入元素：offer()和put()，队满时offer()立即返回false，而put()会一直等待，直到有空闲位置</li><li>弹出元素：poll()和take()，队空时poll()返回null，而take()会一直等待，直到有可用元素</li><li>物理上是一个数组，逻辑上是一个环形结构，每次入队和出队都会调整队头和队尾两个索引的位置</li></ul><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><ul><li>跳表是一种快速查找数据的数据结构，类似平衡树。但在高并发下，平衡树调整平衡需要一个全局锁，而跳表只需要对局部加锁，因此性能更高。</li><li>跳表分层维护多个链表，每个链表都是有序的，且上层链表都是下层链表元素的子集。不同于哈希map，跳表在插入时随机插入，但会维护有序性</li><li>跳表是一种使用空间换时间的算法，查询的时间复杂度为$O(logn)$</li><li>ConcurrentSkipListMap使用CAS对Node操作，保证并发安全</li></ul><h2 id="JMH-性能测试"><a href="#JMH-性能测试" class="headerlink" title="JMH 性能测试"></a>JMH 性能测试</h2><p>一个专门用于性能测试的框架，基本概念：</p><ol><li>模式 Mode<ul><li>Throughput: 整体吞吐量，1s内可执行调用次数</li><li>AverageTime: 调用的平均时间</li><li>SampleTime: 随机取样，最后输出取样结果的分布</li><li>SingleShotTime: 运行一次时间，通常测试冷启动时的性能</li></ul></li><li>迭代 Iteration<ul><li>JMH一次测量单位，通常为1s</li></ul></li><li>预热 Warmup<ul><li>由于JVM的JIT机制，编译前后的效率不同，通常只考虑JIT编译后的性能</li></ul></li><li>状态 State<ul><li>指定对象作用范围</li><li>Scope.Thread 一个对象仅被一个线程访问</li><li>Scope.Benchmark 多个线程共享一个实例</li></ul></li><li>配置类 Options&#x2F;OptionsBuilder<ul><li>对测试进行配置，指定一些参数，如测试类、进程个数、预热迭代次数</li></ul></li></ol><hr><h1 id="第-4-章-锁优化"><a href="#第-4-章-锁优化" class="headerlink" title="第 4 章 - 锁优化"></a>第 4 章 - 锁优化</h1><p>锁是最常用的同步方法之一，对于多核CPU实现多线程可以明显提高系统的性能，但也会增加额外的开销，高并发环境下，激烈的锁竞争会导致程序的性能下降。因此，必须合理设计并发。</p><h2 id="提高锁性能"><a href="#提高锁性能" class="headerlink" title="提高锁性能"></a>提高锁性能</h2><ul><li>减少锁持有时间：只在必要时进行同步，有助于降低锁冲突的可能性，进而提高系统吞吐量</li><li>减小锁粒度：通过分割数据结构，缩小锁定对象的范围，降低锁冲突的可能性</li><li>用读写分离锁替换独占锁：在读多写少的场合可以有效提升系统并发能力</li><li>锁分离：读写锁的进一步延申，分割系统功能点，实现不同功能的可并发</li><li>锁粗话：对于一连串的锁请求和锁释放，尽量整合成单次锁请求，尤其是循环内的锁请求</li></ul><h2 id="JVM-的锁优化"><a href="#JVM-的锁优化" class="headerlink" title="JVM 的锁优化"></a>JVM 的锁优化</h2><ul><li>锁偏向：<ul><li>如果一个线程获得了锁，锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作</li><li>适合几乎没有锁竞争的场合，节省了大量有关锁请求的操作，提高程序性能</li><li>但如果锁竞争激烈，每次都是不同线程请求锁，偏向模式就会失效，性能反而会下降</li></ul></li><li>轻量级锁：<ul><li>如果锁偏向失效，JVM并不会立即挂起线程。，而是使用轻量级锁</li><li>即简单地将对象头部作为指针指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁</li><li>线程若成功获得轻量级锁，则顺利进入临界区。反之，当前线程就会膨胀为重量级锁</li></ul></li><li>自旋锁：<ul><li>锁膨胀后，为了避免真的挂起线程，JVM尝试让当前线程做几个空循环</li><li>若干循环后，如果可以得到锁，则进入临界区，节省了线程挂起的巨大开销</li><li>如果还是不能获得锁，就真的将线程在OS层面挂起</li></ul></li><li>锁消除：<ul><li>JVM在JIT编译时，基于逃逸分析，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁</li></ul></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul><li>为每一个线程分配一个独立的线程局部对象，只有当前线程可访问。因此自然是线程安全的</li><li>ThreadLocal::set(), ThreadLocal::get()</li><li>实现上，Thread::ThreadLocal::ThreadLocalMap使用弱引用保存各个线程的局部变量，key是ThreadLocal对象，value是局部变量</li><li>如果共享对象对于竞争的处理容易引起性能损失，就应该考虑使用ThreadLocal为每个线程分配单独的对象</li><li>ThreadLocalRandom继承自Random，使用Unsafe，让每个线程维护自己的种子变量，不存在竞争，优化了高并发环境中随机数的产生效率</li></ul><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><blockquote><p>锁是一种悲观的策略，它总是假设每一次的临界区操作都会产生冲突，因此会阻塞线程，牺牲性能。<br>而无锁是一种乐观的策略，它假设对资源的访问是没有冲突的，所有线程都可以在不停顿的状态下持续执行。</p></blockquote><h3 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h3><p>CAS比较交换是无锁策略的一种典型实现方式，更新规则如下：<br>$$ CAS(V, E, N)，其中V：要更新的变量， E：预期值， N：新值$$</p><ul><li>仅当V值等于E值时，才会更新V为N，否则说明已经有其它线程更新了V</li><li>CAS返回当前V的真实值</li><li>CAS无锁方式，对死锁天然免疫，没有锁竞争带来的开销，也没有线程间频繁调度的开销，因此比基于锁的方式拥有更优越的性能</li></ul><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><ul><li>JUC下的atomic包中，实现了一些直接使用CAS的线程安全的类型，如AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference…</li><li><code>AtomicInteger::getAndSet(newVal), AtomicInteger::getAndIncrement(), AtomicInteger::addAndGet(delta)...</code></li><li>内部使用UnSafe类实现更新</li></ul><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ul><li><p>封装了一些类似指针的操作，例如根据偏移量获得&#x2F;设置对应位置上的数据</p><pre><code class="hljs">public final native boolean compareAndSetInt(Object o, long offset, int expected, int x)- offset是对象内的偏移量，即一个字段到对象头部的偏移</code></pre></li><li><p><code>UnSafe::objectFieldOffset(Field f)</code> 获取指定字段相对于对象内存地址的偏移量valueOffset</p></li><li><p><code>Unsafe::putIntVolatile(object, offset, x)...</code></p></li><li><p>UnSafe仅可由JDK内部 (Bootstrap Class Loader) 使用，App Loader无法加载</p></li></ul><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><blockquote><p>ABA问题：CAS操作存在的一个问题，如果在A线程修改对象之前，B线程连续修改了两次对象，且修改后仍是原值，那么A线程就无法知道这是已经被修改过的对象。对于一些需要过程状态信息的对象，就可能产生异常。</p></blockquote><ul><li>AtomicReference无法解决ABA问题，根本原因在于对象值本身与状态画上了等号，对象在修改过程中丢失了状态信息</li><li>AtomicStampedReference通过在内部额外维护一个时间戳来表示状态值，解决ABA问题。当设置对象值时，仅当对象值和时间戳都满足期望值才会写入</li><li><code>AtomicStampedReference::compareAndSet(expectedReference, newReference, exptectedStamp, newStamp)</code></li><li><code>AtomicStampedReference::getReference(), AtomicStampedReference::getStamp()</code></li></ul><h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><ul><li>对数组的原子性操作封装，使用Unsafe类通过CAS方式保障int[]在多线程下的安全性</li><li>除AtomicIntegerArray外，还有AtomicLongArray, AtomicReferenceArray, 共三个</li><li><code>AtomicIntegerArray::compareAndSet(int i, int expect, int update)</code> 其中i是数组下标</li></ul><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><ul><li>可以在几乎不改动原有代码的基础上，让普通的变量具有线程安全性</li><li>除AtomicIntegerFieldUpdater外，还有AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, 共三个</li><li><code>AtomicIntegerFieldUpdater::newUpdater(Class, fieldName)</code></li><li>注意事项：<ul><li>Updater使用反射，只能修改它可见范围内的变量</li><li>变量必须用volatile修饰</li><li>由于CAS通过Unsafe::objectFieldOffset()得到对象中的偏向量直接赋值，因此不支持static字段</li></ul></li></ul><h3 id="SychronousQueue的实现"><a href="#SychronousQueue的实现" class="headerlink" title="SychronousQueue的实现"></a>SychronousQueue的实现</h3><ul><li>内部维护一个线程等待队列，对SychronousQueue的任何一次读操作都需要等待一个写操作，反之亦然。因此更像是一个数据交换通道</li><li>内部将put(), take()两种功能抽象为一个共同的方法Transfer::transfer(Object e, timed, nanos)<ul><li>对象e非空时，表示当前操作传递给一个消费者，为空则表示当前操作需要请求一个数据。</li><li>返回值非空表示数据已经被接收或正常提供，否则表示失败，出现超时或中断</li></ul></li></ul><h2 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h2><blockquote><p>死锁就是两个或者多个线程互相占用对方需要的资源，导致彼此之间互相等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在。</p></blockquote><ul><li>经典问题 – 哲学家就餐问题</li><li>要避免死锁，除了使用无锁函数外，可以利用重入锁的中断或限时等待</li></ul><hr><h1 id="第-5-章-并行模式与算法"><a href="#第-5-章-并行模式与算法" class="headerlink" title="第 5 章 - 并行模式与算法"></a>第 5 章 - 并行模式与算法</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>一种对象创建模式，用于产生一个对象的具体实例，可以确保系统中一个类只产生一个实例</li><li>好处：<ul><li>省略new操作花费的时间</li><li>减轻GC压力，缩短GC停顿时间</li></ul></li><li>实现：<ol><li><p>饿汉方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Singleton is create&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 私有且静态。类初始化时即创建</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;LazySingleton is create&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">lazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 第一次调用时才初始化instance</span><br>  <span class="hljs-comment">// 为了防止对象被多次创建，必须用synchronized进行同步</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sychronized LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结合方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticSingleton</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">StaticSingleton</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;StaticSingleton is create&quot;</span>);<br><br>    <span class="hljs-comment">// 巧妙使用内部类和类的初始化机制</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StaticSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticSingleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><ul><li>使用不可改变的对象，可以确保其在没有同步操作的多线程环境中依然保持内部状态的一致性和正确性。因此可以去除同步操作，提高并行性能</li><li>主要使用场景：<ul><li>对象创建后，其内部状态和数据不再发生任何变化</li><li>对象需要被共享，被多线程频繁访问</li></ul></li><li>Java实现不变模式：<ul><li>去除setter()方法及修改自身属性的方法</li><li>所有属性设为私有，并用final标记，确保其不可修改</li><li>确保没有子类可以重载修改它的行为</li><li>有一个可以创建完整对象的构造函数</li></ul></li><li>JDK 中不变模式应用非常广泛，例如String, Boolean, Byte, Long…等等元数据类、包装类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不变模式实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;  <span class="hljs-comment">// 确保无子类</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String no;    <span class="hljs-comment">// 私有，final</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> price;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Product</span><span class="hljs-params">(String no, String name, <span class="hljs-type">double</span> price)</span>&#123; <span class="hljs-comment">// 创建对象时必须指定数据</span><br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.no = no;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.price = price;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> no;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者 - 消费者模式"></a>生产者 - 消费者模式</h2><ul><li>经典的多线程设计模式，为多线程间的协作提供了良好的解决方案</li><li>两类线程，若干生产者线程负责提交用户请求，若干消费者线程负责具体处理生产者提交的任务。</li><li>生产者和消费者之间通过内存缓冲区进行通信，缓解性能差</li><li>无锁CAS的实现框架 - Disruptor<ul><li>使用环形队列，快速定位元素位置，充分复用内存</li><li>监控策略：Blocking, Sleeping, Yielding, BusySpin</li><li>CPU Cache 优化，解决缓存行伪共享</li></ul></li></ul><h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式是多线程开发中非常常见的一种设计模式，核心思想是异步调用。Future模式让被调用者立即返回，并在后台处理请求，对于调用者可以先处理其它任务，在真正需要数据的场合再尝试获得需要的数据。</p><ul><li>JUC 提供了Future模式的封装。<ul><li>FutureTask(Callable) 用Callable接口的对象构造FutureTask</li><li>FutureTask::get() 获取call()方法的结果，如果call()尚未完成则等待</li><li>FutureTask::cancel(), FutureTask::isDone(), FutureTask::get(timeout, timeunit)…</li></ul></li><li>Guava库对Future增加了通知功能以及异常处理，能够在任务完成&#x2F;失败时自动回调，从而不阻塞主线程</li></ul><h2 id="并行流水线"><a href="#并行流水线" class="headerlink" title="并行流水线"></a>并行流水线</h2><blockquote><p>执行过程中有数据相关性的运算都是无法完美并行的，但是可以借用流水线的思想，拆分步骤，将有依赖关系的操作分配在不同的线程中进行计算，尽可能利用多核的优势。通常需要一个中间消息传递队列，例如BlockingQueue</p></blockquote><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><blockquote><p>将原始数据集合按照期望的线程数进行分割，每个线程各自独立搜索，当其中一个线程找到数据后，立即返回结果即可</p></blockquote><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><blockquote><p>奇偶交换排序：分两阶段，奇交换总是比较奇数索引及其相邻的后续元素，偶交换总是比较偶数索引及其相邻的后续元素。且奇交换和偶交换成对出现，保证比较涉及每一个元素。可以利用多线程对每一次元素比较和交换进行操作。</p><p>希尔排序：将整个数组根据间隔h分割为若干个子数组，利用多线程分别对每一个子数组进行排序，每一组排序完成后递减h的值，进行下一轮更加精细的排序，直到h为1。</p></blockquote><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><blockquote><p>利用矩阵分割+多线程实现矩阵乘法的并行化</p></blockquote><h2 id="网络-NIO"><a href="#网络-NIO" class="headerlink" title="网络 NIO"></a>网络 NIO</h2><blockquote><p>Java NIO 涉及通道Channel、缓冲区Buffer、文件IO、网络IO等。NIO可以将网络IO等待时间从线程中抽离，主要涉及Selector, SocketChannel等API。</p></blockquote><h2 id="异步-AIO"><a href="#异步-AIO" class="headerlink" title="异步 AIO"></a>异步 AIO</h2><blockquote><p>NIO在网络操作中提供了非阻塞的方法，但IO行为还是同步的。而AIO不是在IO准备好时再通知线程，而是在IO操作完成后，再给线程发出通知，因此AIO完全不会阻塞。主要涉及AsynchronousServerSocketChannel, CompletionHandler等API。</p></blockquote><hr><h1 id="第-6-章-Java-8-x2F-9-x2F-10-与并发"><a href="#第-6-章-Java-8-x2F-9-x2F-10-与并发" class="headerlink" title="第 6 章 - Java 8&#x2F;9&#x2F;10 与并发"></a>第 6 章 - Java 8&#x2F;9&#x2F;10 与并发</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>特征：<ul><li>可以将函数作为参数传递给另一个函数</li><li>一个函数可以作为另一个函数的返回值</li><li>限制函数副作用 (不修改全局变量&#x2F;外部状态)<ul><li>显式函数：函数与外界交换数据的唯一渠道就是参数和返回值，不会读取或修改外部状态。利于调试和排错</li><li>隐式函数：与之相反。不利于调试和跟踪</li></ul></li><li>声明式，不需要再提供明确的指令操作</li><li>几乎所有对象都是不变的</li><li>易于并行，提高性能</li><li>代码量精简</li></ul></li><li>FunctionalInterface 注释<ul><li>只定义了单一抽象方法的接口 (Object实现的方法除外)</li><li>可以存在实例方法&#x2F;默认方法</li></ul></li><li>Lambda 表达式<ul><li>匿名函数，没有函数名的函数体</li><li>可以直接作为参数传递给相关的调用者</li></ul></li><li>方法引用<ul><li>精简Lambda表达式的手段，通过类名&#x2F;实例名，以及方法名定位一个静态&#x2F;实例方法</li><li><code>ClassName::method, instance::method, Class::new, TypeName[]::new</code>等等</li><li>Java会自动识别流中元素是作为调用目标还是调用方法的参数</li></ul></li></ul><h2 id="并行流与并行排序"><a href="#并行流与并行排序" class="headerlink" title="并行流与并行排序"></a>并行流与并行排序</h2><ul><li>stream.parallel()</li><li>list.parallelStream()</li><li>Arrays.parallelSort(arr)</li><li>Arrays.parallelSetAll(arr, generator)</li><li>……</li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul><li>继承自CompletionStage接口，实现了40多种方法，用于函数式编程的流式调用</li><li><code>CompletableFuture::complete()</code> 告知完成状态</li><li><code>CompletableFuture::get()</code> 获取执行结果，未完成则阻塞。可用于阻止主线程直接退出</li><li><code>CompletableFuture::supplyAync(supplier, [executor])</code> 异步调用，可指定线程池，默认在ForkJoinPool.common线程池中作为Daemon线程执行</li><li><code>CompletableFuture::runAync(runnable, [executor])</code> 同上，但不需要返回值</li><li><code>CompletableFuture::thenApply(function)</code> 转换结果</li><li><code>CompletableFuture::thenAccept(consumer)</code> 消费结果</li><li><code>CompletableFuture::thenRun(Runnable)</code> 任务完成后的回调</li><li><code>CompletableFuture::thenCompose(function)</code> 组合多个CompletableFuture</li><li><code>CompletableFuture::thenCombine(completionStage)</code> 组合多个CompletableFuture，并将执行结果传递给一个BiFunction</li><li><code>CompletableFuture::orTimeout(time, TimeUnit)</code> </li><li><code>CompletableFuture::exceptionally(function)</code> 异常处理</li></ul><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><ul><li>读写锁的改进版本，提供了一种乐观的读策略，增加了系统的并行度</li><li>内部实现基于CLH，一种自旋锁，维护一个等待线程队列，每个节点保存一个标记位用于判断当前线程是否已经释放锁。保证没有饥饿，以及FIFO的服务顺序。</li><li>小陷阱：实现上使用Unsafe.park()挂起线程，因此在遇到线程中断时会重新进入循环，导致疯狂CPU占用</li></ul><h2 id="原子类增强"><a href="#原子类增强" class="headerlink" title="原子类增强"></a>原子类增强</h2><ul><li>LongAdder<ul><li>将核心value数据分离成一个数组cells，减小锁粒度，降低多线程竞争。最终的计数结果为这个数组的求和累加</li></ul></li><li>LongAccumulator<ul><li>在LongAdder基础上，可以实现任意函数操作</li></ul></li></ul><h2 id="ConcurrentHashMap-增强"><a href="#ConcurrentHashMap-增强" class="headerlink" title="ConcurrentHashMap 增强"></a>ConcurrentHashMap 增强</h2><ul><li>foreach</li><li>reduce</li><li>computeIfAbsent 条件插入</li><li>search</li><li>mappingCount 以long型返回map条目数，并发情况下不准确</li><li>newKeySet 返回一个线程安全的Set (JDK中Set的实现依赖于Map)</li></ul><h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><blockquote><p>反应式编程用于处理异步流中的数据。核心组件包括发布者、订阅者。<br>发布者将数据发布到流中，订阅者则负责处理这些数据。<br>涉及API：JUC.Flow.Subscriber, JUC.Flow.Subscription, JUC.SubmissionPublisher;</p></blockquote><h1 id="第-7-章-Akka构建高并发程序"><a href="#第-7-章-Akka构建高并发程序" class="headerlink" title="第 7 章 - Akka构建高并发程序"></a>第 7 章 - Akka构建高并发程序</h1><blockquote><p>Akka提供了一种名为Actor的并发模型，其粒度比线程小，因此可以在系统中启用大量的Actor<br>Akka提供了一套容错机制，允许在Actor出现异常时进行一些恢复或者重复操作<br>Akka不仅可以在单机上构架高并发程序，也可以在网络中构建分布式程序，并提供位置透明的Actor定位服务</p><p>粒子群算法：一种进化算法，用于求解优化问题，通常可以得到一个局部最优解。<br>背景：鸟类觅食表现出群体特性，鸟群往往会聚集在一堆食物旁觅食。如果其中一只鸟发现另外一堆更丰盛的食物，就很可能会离群飞向更丰盛的食物，而这有可能带动整个鸟群一起飞向新的地点。这个迁移过程中会存在于一些小鸟叛逆，不跟着种群走，可能会发现更丰盛的食物堆。这样反复迭代，最终将找到一个相当丰盛的食物堆。</p></blockquote><h1 id="第-8-章-并行调试"><a href="#第-8-章-并行调试" class="headerlink" title="第 8 章 - 并行调试"></a>第 8 章 - 并行调试</h1><blockquote><p>null</p></blockquote><h1 id="第-9-章-Jetty代码分析"><a href="#第-9-章-Jetty代码分析" class="headerlink" title="第 9 章 - Jetty代码分析"></a>第 9 章 - Jetty代码分析</h1><blockquote><p>Jetty是一个基于Java实现的免费HTTP服务器和Servlet容器，成为与Tomcat齐名的、使用最广泛的Java Web容器之一。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法刷题模板</title>
    <link href="/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class=" mermaid">stateDiagram    java.util.Collection&amp;nbsp[I] --&gt; java.util.List&amp;nbsp[I]    java.util.List&amp;nbsp[I] --&gt; java.util.ArrayList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.LinkedList&amp;nbsp[C]    java.util.List&amp;nbsp[I] --&gt; java.util.Vector&amp;nbsp[C]    java.util.Vector&amp;nbsp[C] --&gt; java.util.Stack&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Set&amp;nbsp[I]    java.util.Set&amp;nbsp[I] --&gt; java.util.HashSet&amp;nbsp[C]       java.util.Set&amp;nbsp[I] --&gt; java.util.SortedSet&amp;nbsp[I]    java.util.SortedSet&amp;nbsp[I] --&gt; java.util.TreeSet&amp;nbsp[C]    java.util.Collection&amp;nbsp[I] --&gt; java.util.Queue&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.Deque&amp;nbsp[I]    java.util.Queue&amp;nbsp[I] --&gt; java.util.PriorityQueue&amp;nbsp[C]</code></pre><pre><code class=" mermaid">stateDiagram    java.util.Map&amp;nbsp[I] --&gt; java.util.SortedMap&amp;nbsp[I]    java.util.SortedMap&amp;nbsp[I] --&gt; java.util.TreeMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.Hashtable&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.HashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.LinkedHashMap&amp;nbsp[C]    java.util.Map&amp;nbsp[I] --&gt; java.util.WeakHashMap&amp;nbspC]</code></pre><p>[I]: 接口<br>[C]: 类<br>其中，Vector、Stack、HashTable线程安全，但已经基本不用了。</p><h3 id="数组-Array或ArrayList"><a href="#数组-Array或ArrayList" class="headerlink" title="数组 - Array或ArrayList"></a>数组 - Array或ArrayList</h3><ul><li>get和set操作时间上都是O(1)</li><li>add和remove都是O(N)</li><li>ArrayList添加元素不必考虑越界，超出容量时自动扩张</li><li>Vector相比于ArrayList，实现了线程安全，但效率较低</li></ul><h3 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 - LinkedList"></a>链表 - LinkedList</h3><ul><li>get和set操作时间上都是O(N)</li><li>add和remove都是O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;addd&quot;</span>);<span class="hljs-comment">//add</span><br>linkedList.set(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;s&quot;</span>); <span class="hljs-comment">//set，必须先保证 linkedList中已经有第0个元素</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span>  linkedList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//get</span><br>linkedList.contains(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//查找</span><br>linkedList.remove(<span class="hljs-string">&quot;s&quot;</span>);<span class="hljs-comment">//删除</span><br><span class="hljs-comment">// 以上方法也适用于ArrayList</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="栈-ArrayDeque"><a href="#栈-ArrayDeque" class="headerlink" title="栈 - ArrayDeque"></a>栈 - ArrayDeque</h3><ul><li>Stack实现了后进先出，但继承自Vector，线程安全但效率低，因此不推荐使用</li><li>ArrayDeque实现了Deque，可以作为栈（但仍可以违反栈的单端操作规则）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>stack.push(<span class="hljs-number">12</span>);<span class="hljs-comment">//尾部入栈</span><br>stack.push(<span class="hljs-number">16</span>);<span class="hljs-comment">//尾部入栈</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> stack.pop();<span class="hljs-comment">//尾部出栈，并删除该元素</span><br>tail = stack.peek();<span class="hljs-comment">//尾部出栈，不删除该元素</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="队列-LinkedList"><a href="#队列-LinkedList" class="headerlink" title="队列 - LinkedList"></a>队列 - LinkedList</h3><ul><li>LinkedList实现了Deque，可以作为双向&#x2F;单向队列</li><li>PriorityQueue实现了带优先级的队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 尾部入队，区别在于如果失败了，add方法会抛出一个IllegalStateException异常，而offer方法返回false</span><br>deque.offer(<span class="hljs-number">122</span>);<br>deque.add(<span class="hljs-number">122</span>);<br><span class="hljs-comment">// 头部出队，区别在于如果失败了，remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span><br><span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> deque.poll();<span class="hljs-comment">//删除第一个元素并返回</span><br>head = deque.remove();  <span class="hljs-comment">//删除第一个元素并返回</span><br><span class="hljs-comment">// 头部出队，区别在于如果失败了，element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span><br>head = deque.peek();    <span class="hljs-comment">//返回第一个元素，不删除</span><br>head = deque.element(); <span class="hljs-comment">//返回第一个元素，不删除</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 - Deque"></a>双端队列 - Deque</h3><ul><li>ArrayDeque基于数组实现了双端队列</li><li>LinkedList基于双向链表实现了双端队列</li><li>另有两个线程安全的实现类：ConcurrentLinkedDeque, LinkedBlockingDeque<pre><code class=" mermaid">classDiagram    Queue &lt;|-- Deque    Deque ..|&gt; ArrayDeque    Deque ..|&gt; LinkedList    &lt;&lt;interface&gt;&gt; Queue    &lt;&lt;interface&gt;&gt; Deque</code></pre></li><li>Deque和Queue提供了两套API，一种抛出异常，另一种返回特殊值</li><li>Deque中add(), offer()都是队尾加入元素，而push()队头加入元素。</li><li>Deque中的peek(), element(), poll(), remove(), pop()都是从队头取元素。尽量不混用</li><li>Deque额外提供了First、Last后缀的方法。<table><thead><tr><th align="center">操作类型</th><th align="center">抛出异常</th><th align="center">返回特殊值</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td></tr><tr><td align="center">拾取</td><td align="center">element()</td><td align="center">peek()</td></tr></tbody></table></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建next数组</span><br><span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];<br>next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; p.length - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || p[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>        next[i] = j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br>i = <span class="hljs-number">0</span>;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s[i] == p[j]) &#123;<br>        ++i;<br>        ++j;<br>    &#125; <span class="hljs-keyword">else</span><br>        j = next[j];<br>&#125;<br><br><span class="hljs-keyword">if</span> (j == p.length)<br>    <span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最长上升子序列-DP"><a href="#最长上升子序列-DP" class="headerlink" title="最长上升子序列 - DP"></a>最长上升子序列 - DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 以nums[i]结尾的最长上升子序列长度</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) <br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br><br>        ans = Math.max(ans,dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列-贪心-二分"><a href="#最长上升子序列-贪心-二分" class="headerlink" title="最长上升子序列 - 贪心+二分"></a>最长上升子序列 - 贪心+二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 长度为k的最长上升子序列末尾元素的值,同等长度下应尽可能小</span><br>    <span class="hljs-type">int</span>[] tails = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = len;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(tails[mid] &lt; num)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid;<br>        &#125;<br>        tails[left] = num;<br>        <span class="hljs-keyword">if</span>(len == right)<br>            len++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通二分</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 搜索左边界</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">left_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 此时 target 比所有数都大，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 搜索右边界</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">right_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 此时 left - 1 索引越界</span><br>    <span class="hljs-keyword">if</span> (left - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left - <span class="hljs-number">1</span>] == target ? (left - <span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的解题模式分两类：1.遍历一遍二叉树；2.定义递归分解问题。两类思想又分别对应回溯算法和动态规划。</p><p>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。三种遍历中，前序位置的代码只能从函数参数中获取父节点传递来的参数，而后序遍历代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。因此，对于涉及子树的问题，大概率要给函数设置合理的定义和返回值，在后序位置写巧妙的代码。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 访问两个相邻节点：左子节点、右子节点</span><br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格DFS"><a href="#网格DFS" class="headerlink" title="网格DFS"></a>网格DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case</span><br>    <span class="hljs-comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span><br>    <span class="hljs-keyword">if</span> (!inArea(grid, r, c))<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 访问的格子不符合要求，直接返回</span><br>    <span class="hljs-keyword">if</span> (grid[r][c] != <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">return</span>;<br>    <br>    grid[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 将格子标记为「已遍历过」</span><br>    <br>    <span class="hljs-comment">// 访问上、下、左、右四个相邻结点</span><br>    dfs(grid, r - <span class="hljs-number">1</span>, c);<br>    dfs(grid, r + <span class="hljs-number">1</span>, c);<br>    dfs(grid, r, c - <span class="hljs-number">1</span>);<br>    dfs(grid, r, c + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 判断坐标 (r, c) 是否在网格中</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; grid.length &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].length;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) <br>            queue.add(node.left);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) <br>            queue.add(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分层BFS-x2F-多源BFS"><a href="#分层BFS-x2F-多源BFS" class="headerlink" title="分层BFS &#x2F; 多源BFS"></a>分层BFS &#x2F; 多源BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-comment">// 关键：队列长度即当前层结点个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">// 将符合条件的扩展结点加入队列</span><br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.left);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>                queue.offer(cur.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>定义depth层数，并在<strong>入队前</strong>标记已访问，即可用于图BFS&#x2F;多源BFS求最短路问题 (root即超级源点)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-虚拟机</title>
    <link href="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>《深入理解Java虚拟机》 学习笔记</p><span id="more"></span><p>参考：</p><ul><li><a href="https://github.com/fenixsoft/jvm_book">https://github.com/fenixsoft/jvm_book</a></li><li><a href="https://github.com/TangBean/understanding-the-jvm">https://github.com/TangBean/understanding-the-jvm</a></li><li><a href="https://github.com/starjuly/UnderstandingTheJVM">https://github.com/starjuly/UnderstandingTheJVM</a></li></ul><h1 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 - Java内存区域与内存溢出异常"></a>第二章 - Java内存区域与内存溢出异常</h1><h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.svg" class="" title="图2-1 Java虚拟机运行时数据区"><h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><ul><li>当前线程所执行的字节码的行号指示器</li><li>字节码解释器通过改变该计数器的值来选取吓一跳需要执行的字节码指令</li><li>线程私有，各线程之间计数器互不影响，独立存储</li><li>不会产生 <code>OutOfMemoryError</code></li></ul><h3 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2 虚拟机栈"></a>2.2.2 虚拟机栈</h3><ul><li>每执行一个方法，虚拟机同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li><li>一个方法的执行到结束，对应着一个栈帧在虚拟机中从入栈到出栈的过程</li><li>局部变量表<ul><li>存放编译期可知的基本数据类型、对象引用、returnAddress</li><li>所需空间在编译期间完成分配</li><li>以局部变量槽Slot来表示</li></ul></li><li>线程私有，生命周期与线程相同</li><li><code>StackOverflowError</code> (栈深度溢出) &#x2F; <code>OutOfMemoryError</code> (内存请求失败)</li></ul><h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h3><ul><li>类似虚拟机栈，不过是为虚拟机使用到的Native方法服务(如C, Cpp)</li><li><code>StackOverflowError</code> &#x2F; <code>OutOfMemoryError</code></li></ul><h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><ul><li>虚拟机管理的最大内存区，负责存放对象实例</li><li>由垃圾收集器GC管理</li><li>线程共享 (可以划分线程私有的分配缓冲区TLAB)</li><li><code>OutOfMemoryError</code></li></ul><h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><ul><li>存储已被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据</li><li>类信息：<ul><li>即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li></ul></li><li>运行时常量池<ul><li>存放编译期生成的各种字面量(<code>static final</code>)与符号引用</li></ul></li><li>线程共享</li><li><code>OutOfMemoryError</code></li></ul><h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><ul><li>不属于JVM运行时数据区</li><li>如使用Native函数库直接分配堆外内存(JDK1.4-NIO)</li><li><code>OutOfMemoryError</code></li></ul><h2 id="2-3-HotSpot虚拟机对象"><a href="#2-3-HotSpot虚拟机对象" class="headerlink" title="2.3 HotSpot虚拟机对象"></a>2.3 HotSpot虚拟机对象</h2><h3 id="2-3-1-对象创建"><a href="#2-3-1-对象创建" class="headerlink" title="2.3.1 对象创建"></a>2.3.1 对象创建</h3><ul><li>步骤：<ul><li>遇到new指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已被加载、加载、解析和初始化，如果没有必须先执行相应类的加载过程</li><li>加载检查通过后，为新生对象分配内存</li><li>内存分配完成后，JVM将该内存空间初始化为0</li><li>JVM对对象进行必要设置，例如元类型信息、HashCode、GC分代年龄等(存储在对象头中)</li><li>JVM对象已产生，接着开始执行对象的构造方法 &lt;init&gt;()</li><li>这样一个真正可用的对象被完全构造出来</li></ul></li><li>分配内存方法：<ul><li>碰撞指针: 使用过的内存放一边，空闲的放另一边，中间用指针分隔。分配内存就是移动指针。内存分配规整</li><li>空闲列表：维护可用内存块的记录表，分配内存时修改记录。内存分配不规整</li></ul></li><li>解决并发：<ul><li><code>CAS</code> 同步：Compare And Swap 保证更新的原子性 </li><li><code>TLAB</code> 本地线程分配缓冲：线程私有的分配缓冲区</li></ul></li></ul><h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h3><ul><li>对象头<ul><li><code>Mark Word</code>: 存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态、偏向信息等</li><li><code>kClass Pointer</code>: 类型指针，对象指向它的类型元数据的指针</li></ul></li><li>实例数据：对象真正存储的有效信息<ul><li>默认分配顺序：longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops(Ordinary Object Pointers)</li><li>相同宽度的字段会被分配在一起，除了oops，其他的长度由长到短</li><li>满足上述条件下，父类定义变量在子类变量之前</li><li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li><li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li></ul></li><li>对齐填充：8Byte整数倍</li></ul><h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h3><ul><li><p>Java通过栈上的reference来操作堆上的具体对象，实现方式主要以下两种</p></li><li><p>句柄访问</p><ul><li>Java堆中划分一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体地址</li><li>好处：reference存储的是稳定句柄，移动对象时不需要改变reference<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" class="" title="对象的访问定位_直接指针访问.png"></li></ul></li><li><p>直接指针</p><ul><li>reference直接存储对象地址，但需要考虑如何存放类型数据的相关信息</li><li>好处：速度快，减少一次指针定位的时间开销<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" class="" title="对象的访问定位_直接指针访问.png"></li></ul></li></ul><h2 id="2-4-实战内存区异常"><a href="#2-4-实战内存区异常" class="headerlink" title="2.4 实战内存区异常"></a>2.4 实战内存区异常</h2><ul><li>VMArgs: <ul><li><code>-Xms20m</code> 最小堆大小</li><li><code>-Xmx20m</code> 最大堆大小</li><li><code>-Xss128k</code> 栈内存大小</li><li><code>-XX:MaxDirectMemorySize=10M</code> 直接内存大小</li><li><code>-XX:+/-UseTLAB</code> 是否使用TLAB</li><li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li><li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code> 内存溢出异常时Dump出当前内存堆转储快照</li></ul></li></ul><h3 id="2-4-1"><a href="#2-4-1" class="headerlink" title="2.4.1"></a>2.4.1</h3><pre><code class="hljs">Java堆溢出：不断new新对象</code></pre><h3 id="2-4-2"><a href="#2-4-2" class="headerlink" title="2.4.2"></a>2.4.2</h3><pre><code class="hljs">虚拟机栈溢出：无限方法递归</code></pre><h3 id="2-4-3"><a href="#2-4-3" class="headerlink" title="2.4.3"></a>2.4.3</h3><pre><code class="hljs">运行时常量池溢出：String::intern 不断向常量池添加字符串方法区溢出：CGLib代理生成大量的类</code></pre><h3 id="2-4-4"><a href="#2-4-4" class="headerlink" title="2.4.4"></a>2.4.4</h3><pre><code class="hljs">直接内存溢出：Unsafe类分配内存</code></pre><h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 - 垃圾收集器与内存分配策略"></a>第三章 - 垃圾收集器与内存分配策略</h1><h2 id="3-2-对象存活判断"><a href="#3-2-对象存活判断" class="headerlink" title="3.2 对象存活判断"></a>3.2 对象存活判断</h2><h3 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h3><ul><li>在对象中添加一个引用计数器</li><li>每当有一个地方引用它，计数器值+1</li><li>当引用失效时，计数器值-1</li><li>任何时刻计数器为0的对象就是不可能再被使用的</li></ul><p>缺陷：</p><ul><li>难以解决对象间相互循环引用的问题，因此现在基本很少使用</li></ul><h3 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h3><ul><li>从根节点<code>GC Roots</code>出发, 根据引用关系向下搜索，搜索过程称为引用链</li><li>如果某个对象到<code>GC Roots</code>间没有任何引用链相连，则此对象不可达，即可回收</li></ul><p><strong>GC Roots</strong>对象：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈JNI引用的对象</li><li>JVM内部的引用</li><li>所有被同步锁<code>synchronized</code>持有的对象</li><li>反映JVM内部情况的<code>JMXBean</code>、<code>JVMTI</code>等等</li></ul><h3 id="3-3-3-引用分类"><a href="#3-3-3-引用分类" class="headerlink" title="3.3.3 引用分类"></a>3.3.3 引用分类</h3><ul><li>强引用<code>Strongly Reference</code>：任何情况下，强引用关系存在，就不会回收此对象，如引用赋值</li><li>软引用<code>Soft Reference</code>：描述有用但非必须的对象。系统在发生内存溢出异常前，会二次回收这些对象</li><li>弱引用<code>Weak Reference</code>：描述非必须对象，弱于软引用。对象只能生存到下一次垃圾收集发生为止</li><li>虚引用<code>PhantomReference</code>：也叫幻影引用。为一个对象设置虚引用关联的唯一目的是为了在这个对象被回收时收到一个系统通知</li></ul><h3 id="3-2-4-是否finalize"><a href="#3-2-4-是否finalize" class="headerlink" title="3.2.4 是否finalize()"></a>3.2.4 是否finalize()</h3><ul><li>回收对象需要经历两次标记过程</li><li>首先进行可达性分析，判断是否与<code>GC Roots</code>存在相连接的引用链</li><li>接着筛选是否需要执行<code>finalize()</code>，如果对象没有覆盖<code>finalize()</code>或者已被JVM调用过，则不需回收</li><li>任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次</li></ul><h3 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h3><ul><li>方法区垃圾收集的”性价比”通常较低</li><li>主要回收废弃的常量和不再使用的类型，条件包括：<ul><li>该类的所有实例都已经被回收</li><li>加载该类的类加载器已被回收</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</li></ul></li></ul><h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h2><h3 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h3><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul><p>因此，JVM GC的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(熬过垃圾收集过程的次数)分配到不同的区域之中存储。</p><ul><li>新生代：每次垃圾收集都会有大批对象死去</li><li>老年代：新生代中每次回收后存活的少量对象，将会逐步晋升到老年代</li><li>跨代引用假说：新生代对象可能被老年代所引用。跨代引用相对于同代引用仅占极少数</li></ul><p>垃圾收集分类: </p><ul><li>部分收集 <code>Partial GC</code><ul><li>新生代收集 <code>Minor GC</code></li><li>老年代收集 <code>Major GC</code></li><li>混合收集 <code>Mixed GC</code></li></ul></li><li>整堆收集 <code>Full GC</code></li></ul><h3 id="3-3-2-标记——清除算法-Mark-Sweep"><a href="#3-3-2-标记——清除算法-Mark-Sweep" class="headerlink" title="3.3.2 标记——清除算法 Mark-Sweep"></a>3.3.2 标记——清除算法 Mark-Sweep</h3><ul><li>过程：<ul><li>标记：首先标记出需要回收的对象</li><li>清除：标记完成后，统一回收被标记的对象</li></ul></li><li>缺点：<ul><li>两个过程的执行效率都随对象数量增长而降低</li><li>内存空间的碎片化问题<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" class="" title="alt 标记清除算法"></li></ul></li></ul><h3 id="3-3-3-标记-整理算法-Mark-Copy"><a href="#3-3-3-标记-整理算法-Mark-Copy" class="headerlink" title="3.3.3 标记-整理算法 Mark-Copy"></a>3.3.3 标记-整理算法 Mark-Copy</h3><ul><li><p>半区复制 Semispace Copying</p><ul><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li><li>当一块内存用完，就将还存活的对象复制到另一块上面，然后把已使用的内存块一次清理掉</li></ul></li><li><p>缺点：</p><ul><li>将可用内存缩小为原来的一半<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" class="" title="alt 标记复制算法"></li></ul></li><li><p>改进 —— Appel式回收</p><ul><li>新生代划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配只是用<code>Eden</code>和其中一块<code>Survivor</code></li><li>GC时，将<code>Eden</code>和<code>Survivor</code>中存活对象一次性复制到另一块<code>Survivor</code>，然后清理<code>Eden</code>和原先的<code>Survivor</code></li><li>HotSpot中<code>Eden</code>与<code>Survivor</code>默认大小比例是8:1</li><li>逃生门设计：当<code>Survivor</code>不足以容纳一次GC的存活对象时，需要依赖其它内存区域(如老年代)进行分配担保</li></ul></li></ul><h3 id="3-3-4-标记-整理算法-Mark-Compact"><a href="#3-3-4-标记-整理算法-Mark-Compact" class="headerlink" title="3.3.4 标记-整理算法 Mark-Compact"></a>3.3.4 标记-整理算法 Mark-Compact</h3><ul><li>主要针对老年区，是一种移动式算法</li><li>过程<ul><li>标记：首先标记出需要回收的对象</li><li>整理：让所有存活对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</li></ul></li><li>缺点：<ul><li><code>Stop The World</code>：移动对象必须暂停用户线程<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" class="" title="alt 标记整理算法"></li></ul></li></ul><h2 id="3-4-HotSpot的算法细节"><a href="#3-4-HotSpot的算法细节" class="headerlink" title="3.4 HotSpot的算法细节"></a>3.4 HotSpot的算法细节</h2><h3 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h3><ul><li>通过 <code>OopMap</code> 数据结构来记录对象引用</li></ul><h3 id="3-4-2-安全点-Safepoint"><a href="#3-4-2-安全点-Safepoint" class="headerlink" title="3.4.2 安全点 Safepoint"></a>3.4.2 安全点 Safepoint</h3><ul><li>记录OopMap的地方</li><li>选取标准：<ul><li>不能太少，让GC等待时间过长</li><li>不能太多，增大运行时的内存负荷</li><li>以”是否具有让程序长时间执行的特征”为标准，如方法调用、循环跳转、异常跳转等</li></ul></li><li>中断方案：<ul><li>抢先式中断：GC时，系统先把所有用户线程中断，如果中断位置不在安全点上，就恢复线程，直到到达安全点。如今几乎没有JVM使用。</li><li>主动式中断：GC设置标记位，各个线程轮询标记，发现标记为真则主动在最近的安全点中断挂起。HotSpot使用内存保护陷阱实现。</li></ul></li></ul><h3 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h3><ul><li>指能够确保在某一段代码片段之中，引用关系不会发生变化</li><li>因此，在这个区域中任何地方开始垃圾收集都是安全的</li></ul><h3 id="3-4-4-记忆集和卡表"><a href="#3-4-4-记忆集和卡表" class="headerlink" title="3.4.4 记忆集和卡表"></a>3.4.4 记忆集和卡表</h3><ul><li>记忆集<ul><li>一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li><li>记录精度：<ul><li>字长精度：记录精确到一个机器字长 32&#x2F;64，该字还有跨代指针</li><li>对象精度：精确到一个对象，该对象里有字段含有跨代指针</li><li>卡精度：精确到一块内存区域，该区域内有对象含有跨代指针</li></ul></li></ul></li><li>卡表<ul><li>记忆集的一种实现方式</li><li>对应卡精度</li></ul></li></ul><h3 id="3-4-5-写屏障-Write-Barrier"><a href="#3-4-5-写屏障-Write-Barrier" class="headerlink" title="3.4.5 写屏障 Write Barrier"></a>3.4.5 写屏障 Write Barrier</h3><ul><li>HotSpot通过写屏障技术维护卡表状态</li><li>是对引用类型赋值操作的AOP切面，并产生一个环绕通知</li><li>赋值前的是写前屏障</li><li>赋值后的是写后屏障</li></ul><h3 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h3><ul><li>三色标记<ul><li>白色：表示对象尚未被GC访问过</li><li>黑色：表示对象以及被GC访问过，且该对象的所有引用都已经扫描过</li><li>灰色：表示对象已经被GC访问过，但该对象上至少存在一个引用还没有被扫描过</li></ul></li><li>并发扫描的”对象消失”问题<ul><li>满足两个条件：<ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li><li>赋值器删除了全部从灰色对象到白色对象的直接或间接引用</li></ul></li><li>解决方案：<ul><li>增量更新：破坏条件1。当黑色对象插入新的指向白色对象的引用关系时，记录下新的引用关系，等并发扫描结束，将这些记录的黑色对象为根，重新扫描一次。</li><li>原始快照SATB：破坏条件2。当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用关系记录下来，等并发扫描结束，再将这些记录过的引用关系中的灰色对象为根重新扫描一次。</li></ul></li></ul></li></ul><h2 id="3-5-经典垃圾收集器"><a href="#3-5-经典垃圾收集器" class="headerlink" title="3.5 经典垃圾收集器"></a>3.5 经典垃圾收集器</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt 经典垃圾收集器"><h3 id="3-5-1-Serial-收集器"><a href="#3-5-1-Serial-收集器" class="headerlink" title="3.5.1 Serial 收集器"></a>3.5.1 Serial 收集器</h3><ul><li>新生代GC</li><li>单线程，标记-复制算法</li><li>GC时必须暂停其它所有工作线程，直到它收集结束</li><li>虽然鸡肋，但迄今为止，依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt Serial收集器"><center>Serial/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-2-ParNew-收集器"><a href="#3-5-2-ParNew-收集器" class="headerlink" title="3.5.2 ParNew 收集器"></a>3.5.2 ParNew 收集器</h3><ul><li>新生代GC</li><li><code>ParNew</code>实质上是<code>Serial</code>的多线程并发版本，使用标记-复制算法</li><li>除<code>Serial</code>外，只有<code>ParNew</code>可以和<code>CMS</code>配合使用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt ParNew收集器"><center>ParNew/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-3-Parallel-Scavenge-收集器"><a href="#3-5-3-Parallel-Scavenge-收集器" class="headerlink" title="3.5.3 Parallel Scavenge 收集器"></a>3.5.3 Parallel Scavenge 收集器</h3><ul><li>新生代GC</li><li>与<code>ParNew</code>类似，并行收集，使用标记-复制算法</li><li>目标是达到一个可控制的吞吐量, 因此也称作吞吐量优先收集器<br>$$ 吞吐量 &#x3D; \frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间} $$</li></ul><h3 id="3-5-4-Serial-Old-收集器"><a href="#3-5-4-Serial-Old-收集器" class="headerlink" title="3.5.4 Serial Old 收集器"></a>3.5.4 Serial Old 收集器</h3><ul><li><code>Serial</code>的老年代版本</li><li>单线程，标记-整理算法</li><li><code>CMS</code>发生<code>Concurrent Mode Failure</code>失败时的后备预案<center>Serial/SerialOld 收集器运行示意图</center></li></ul><h3 id="3-5-5-Parallel-Old-收集器"><a href="#3-5-5-Parallel-Old-收集器" class="headerlink" title="3.5.5 Parallel Old 收集器"></a>3.5.5 Parallel Old 收集器</h3><ul><li><code>Parallel Scavenge</code>的老年代版本</li><li>多线程并发，标记-整理</li><li>注重吞吐量或者处理器资源较为稀缺的场合，优先考虑<code>Parallel Scavenge</code> + <code>Parallel Old</code><center>Parallel Scavenge/Parallel Old 收集器运行示意图</center></li></ul><h3 id="3-5-6-CMS-Concurrent-Mark-Sweep-收集器"><a href="#3-5-6-CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="3.5.6 CMS (Concurrent Mark Sweep) 收集器"></a>3.5.6 CMS (Concurrent Mark Sweep) 收集器</h3><ul><li>老年代GC</li><li>基于标记-清除算法</li><li>四个步骤：<ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。</li><li>重新标记：修正并发标记阶段产生的标记变动(因用户线程的并发执行)。暂停用户线程。</li><li>并发清除：清理标记死亡的对象。与用户线程并发。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt CMS 收集器"></li></ul></li><li>特点：并发收集，低停顿。因此也称”并发低停顿收集器”。</li><li>缺点：<ul><li>对处理器资源非常敏感</li><li>无法处理”浮动垃圾”,可能出现<code>Concurrent Mode Failure</code>进而导致需要一次<code>Full GC</code>(临时启用<code>Serial Old</code>)</li><li>容易产生大量内存碎片空间</li></ul></li></ul><h3 id="3-5-7-Garbage-First-G1-收集器"><a href="#3-5-7-Garbage-First-G1-收集器" class="headerlink" title="3.5.7 Garbage First (G1) 收集器"></a>3.5.7 Garbage First (G1) 收集器</h3><ul><li>开创面向局部收集的设计思路和基于Region内存布局</li><li>Region：<ul><li>连续的Java堆划分为多个大小相等的独立Region，每个Region根据需要扮演Eden&#x2F;Survivor&#x2F;老年代</li><li>Humongous区域专门存储大对象</li><li>G1跟踪各个Region里面的垃圾堆积的”价值”大小。价值即回收所获得的空间大小以及回收所需时间的经验值，后台维护一个优先级列表。</li></ul></li><li>目的：延迟可控的情况下，获得尽可能高的吞吐量。</li><li>四个步骤：<ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象，并修改TAMS指针以便正确分配对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。(用SATB原始快照处理引用变化)</li><li>最终标记：处理并发阶段结束后遗留的少量SATB记录。暂停用户线程。</li><li>筛选回收：更新Region的统计数据，根据优先级选择Region回收集，移动存活对象并清理旧Region的全部空间。暂停用户线程。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt G1 收集器"></li></ul></li></ul><h2 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h2><ul><li>垃圾收集器的衡量指标：<ul><li>内存占用 <code>Footprint</code></li><li>吞吐量 <code>Throughput</code></li><li>延迟 <code>Latency</code></li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%90%84%E6%AC%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5.png" class="" title="alt 各款收集器的并发情况"><center>各款收集器的并发情况</center><h3 id="3-6-1-Shenandoah-收集器"><a href="#3-6-1-Shenandoah-收集器" class="headerlink" title="3.6.1 Shenandoah 收集器"></a>3.6.1 Shenandoah 收集器</h3><ul><li><p>类似G1，基于Region，按照优先级回收</p></li><li><p>特点</p><ul><li>支持并发的整理算法</li><li>默认不使用分代收集</li><li>改用<code>Connection Matrix</code>全局数据结构来记录跨Region的引用关系</li></ul></li><li><p>九个步骤：</p><ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。(时间取决于堆中存活对象的数量和对象图的复杂程度)</li><li>最终标记：处理剩余的SATB扫描，并统计回收价值最高的Region构成回收集。短暂停顿</li><li>并发清理：清理没有存活对象的Region</li><li>并发回收：核心特点。借助<code>读屏障</code>、<code>Brooks Pointers</code>把回收集里的存活对象复制到未被使用的Region</li><li>初始引用更新：把堆中所有指向旧对象的引用修正到复制后的新地址(引用更新)。短暂停顿。</li><li>并发引用更新：真正开始引用更新。与用户线程并发。时间取决于涉及的引用数量。</li><li>最终引用更新：修正存在于GC Roots中的引用。短暂停顿。</li><li>并发清理：回收剩余的回收集中的Region，供以后对象分配使用。<center>Shenandoah 收集器工作流程</center></li></ul></li><li><p>Brooks Pointer</p><ul><li>以前的方案：在被移动对象原有的内存上设置保护陷阱，一旦访问旧对象内存空间产生自陷中断进入预设好的异常处理器中，把访问转发到复制后的对象上</li><li><code>Brooks Pointer</code>在原有对象布局结构的最前面统一增加一个新的引用字段<ul><li>正常情况下，该引用指向对象自己</li><li>移动对象时只需修改该指针即可</li></ul></li><li>缺点：<ul><li>需要额外的间接访问开销</li><li>多线程竞争问题，Shenandoah通过CAS操作保证并发访问正确性</li></ul></li></ul></li></ul><h3 id="3-6-2-ZGC-收集器"><a href="#3-6-2-ZGC-收集器" class="headerlink" title="3.6.2 ZGC 收集器"></a>3.6.2 ZGC 收集器</h3><ul><li>基于Region内存布局，分大、中、小三类容量</li><li>不设分代</li><li>使用读屏障、染色指针、内存多重映射等技术</li><li>可并发，基于标记-整理算法</li><li>以低延迟为首要目标</li></ul><p>染色指针：</p><ul><li><p>直接把少量额外的信息存储在指针上的技术(指针的高位没有用来寻址，需要底层支持)</p></li><li><p>x86-64架构下需要多重映射的支持：将多个不同的虚拟内存地址映射到同一个物理内存地址上(多对一)</p></li><li><p>优势：</p><ul><li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉</li><li>大幅减少垃圾收集过程中内存屏障的使用数量</li><li>可以作为一种可扩展的存储结构用来记录更多数据</li></ul></li><li><p>四个过程</p><ul><li>并发标记：遍历对象图做可达性分析，特殊点在于标记是在指针上而不是在对象上。需短暂停顿。</li><li>并发预备重分配：根据特定查询条件确定回收集</li><li>并发重分配：核心。把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系(用于指针自愈)。</li><li>并发重映射：修正整个堆中指向重分配集中旧对象的所有引用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ZGC%E6%94%B6%E9%9B%86%E5%99%A8.png" class="" title="alt ZGC 收集器"></li></ul></li></ul><h1 id="第四章-虚拟机性能监控、故障处理工具"><a href="#第四章-虚拟机性能监控、故障处理工具" class="headerlink" title="第四章 - 虚拟机性能监控、故障处理工具"></a>第四章 - 虚拟机性能监控、故障处理工具</h1><h2 id="4-2-基础故障处理工具"><a href="#4-2-基础故障处理工具" class="headerlink" title="4.2 基础故障处理工具"></a>4.2 基础故障处理工具</h2><ul><li>根据软件可用性和授权的不同，分以下三类：<ul><li>商业授权工具：如JMC(Java Mission Control), JFR(Java Flight Recorder) 等</li><li>正式支持工具：LTS</li><li>试验性工具：Unsupported and Experimental</li></ul></li><li>这些工具JDK9之前在jdk\lib\tools目录下，经过模块化改造后现在在jdk\jmods目录下</li><li>工具本身用Java语言实现</li></ul><h3 id="4-2-1-amp-nbsp-jps-虚拟机进程状况工具"><a href="#4-2-1-amp-nbsp-jps-虚拟机进程状况工具" class="headerlink" title="4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具"></a>4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具</h3><ul><li>JVM Process Status Tool</li><li>列出正在运行的虚拟机进程，并显示虚拟机执行主类，名称，以及这些进程的本地虚拟机唯一ID  (<code>LVMID - Local Virtual Machine Identifier</code>)</li><li>命令格式：<code>jps [options] [hostid]</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E6%A0%B7%E4%BE%8B.png" class="" title="alt jps样例"></li><li>选项参数<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E5%8F%82%E6%95%B0.png" class="" title="alt jps参数"></li></ul><h3 id="4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具"><a href="#4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具" class="headerlink" title="4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具"></a>4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具</h3><ul><li>JVM Statistics Monitoring Tool</li><li>监视虚拟机各种运行状态信息</li><li>命令格式：<code>jstat [ option vmid [interval [s|ms] [count]] ]</code><ul><li>若是本地虚拟机，则VMID与LVMID一致</li><li>若是远程虚拟机，则<code>VMID = [protocol:][//]lvmid[@hostname[:port]/servername]</code></li><li>interval: 查询间隔</li><li>count: 查询次数</li><li>option: 希望查询的虚拟机信息，分三类<ul><li>类加载</li><li>垃圾收集</li><li>运行期编译状况<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E9%80%89%E9%A1%B9.png" class="" title="alt jstat选项"></li></ul></li></ul></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E6%A0%B7%E4%BE%8B.png" class="" title="alt jstat样例"></li></ul><h3 id="4-2-3-amp-nbsp-jinfo-Java配置信息工具"><a href="#4-2-3-amp-nbsp-jinfo-Java配置信息工具" class="headerlink" title="4.2.3 &amp;nbsp; jinfo - Java配置信息工具"></a>4.2.3 &amp;nbsp; jinfo - Java配置信息工具</h3><ul><li>Configuration Info for Java</li><li>实时查看和调整虚拟机各项参数</li><li>命令格式：<code>jinfo [option] pid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jinfo%E6%A0%B7%E4%BE%8B.png" class="" title="alt jinfo样例"></li></ul><h3 id="4-2-4-amp-nbsp-jmap-Java内存映像工具"><a href="#4-2-4-amp-nbsp-jmap-Java内存映像工具" class="headerlink" title="4.2.4 &amp;nbsp; jmap - Java内存映像工具"></a>4.2.4 &amp;nbsp; jmap - Java内存映像工具</h3><ul><li>Memory Map for Java</li><li>生成堆转储快照 (heapdump &#x2F; dump),查询finalize执行队列、Java堆和方法区的详细信息等</li><li>命令格式：<code>jmap [option] vmid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E6%A0%B7%E4%BE%8B.png" class="" title="alt jmap样例"></li><li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E9%80%89%E9%A1%B9.png" class="" title="alt jmap选项"></li></ul><h3 id="4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具"><a href="#4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具"></a>4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具</h3><ul><li>JVM Heap Analysis Tool</li><li>与jmap搭配使用，分析jmap生成的堆转储快照</li><li>比较鸡肋，有更好的Analyzer可以替代</li><li>分析内存泄露问题需要<code>OQL (Object Query Language)</code></li></ul><h3 id="4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具"><a href="#4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具" class="headerlink" title="4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具"></a>4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具</h3><ul><li>Stack Trace for Java</li><li>生成虚拟机当前时刻的线程快照 (threaddump &#x2F; javacore)</li><li>线程快照：当前虚拟机内每条线程正在执行的方法堆栈集合。可以分析线程停顿原因</li><li>JDK5开始，<code>java.lang.Thread</code>类新增<code>getAllStackTraces()</code>方法也可以获取所有线程堆栈</li><li>命令格式：<code>jstack [option] vmid</code></li><li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E6%A0%B7%E4%BE%8B.png" class="" title="alt jstack样例"></li><li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E9%80%89%E9%A1%B9.png" class="" title="alt jstack选项"></li></ul><h3 id="4-2-7-基础工具总结"><a href="#4-2-7-基础工具总结" class="headerlink" title="4.2.7 基础工具总结"></a>4.2.7 基础工具总结</h3><ul><li><p>基础工具：用于支持基本的程序创建和运行</p><ul><li>如<code>jar, java, javac, javadoc, javap, jdb...</code></li></ul></li><li><p>性能监控和故障处理：监控Java虚拟机运行信息，排查问题</p><ul><li>如<code>jps, jstat, jinfo, jmap, jhat...</code></li></ul></li><li><p>安全：用于程序签名，设置安全测试等</p><ul><li>如<code>keytool, jarsigner, policytool</code></li></ul></li><li><p>国际化：用于创建本地语言文件</p><ul><li>如<code>native2ascii</code></li></ul></li><li><p>远程方法调用: 用于跨Web或网络的服务交互</p><ul><li>如<code>rmic, rmiregistry, rmid, serialver</code></li></ul></li><li><p>部署工具：用于程序打包、发布和部署</p><ul><li>如<code>javapackager, pack200, unpack200</code></li></ul></li><li><p>REPL (Read-Eval-Print Loop)和脚本工具：<code>jshell, jjs, jrunscript</code></p></li><li><p>Java IDL 与 RMI-IIOP: 与JDK11的CORBA一起废弃</p></li><li><p>WebService工具：与JDK11的CORBA一起废弃</p></li><li><p>Java Web Start: javaws, jdk11移除</p></li></ul><h2 id="4-3-可视化故障处理工具"><a href="#4-3-可视化故障处理工具" class="headerlink" title="4.3 可视化故障处理工具"></a>4.3 可视化故障处理工具</h2><p><code>JConsole, JHSDB, VisualVM, JMC</code></p><h3 id="4-3-1-JHSDB-基于服务性代理的调试工具"><a href="#4-3-1-JHSDB-基于服务性代理的调试工具" class="headerlink" title="4.3.1 JHSDB: 基于服务性代理的调试工具"></a>4.3.1 JHSDB: 基于服务性代理的调试工具</h3><ul><li>服务性代理<ul><li>一组用于映射Java虚拟机运行信息的，主要基于Java语言实现的API集合</li><li>可以在一个独立的Java虚拟机进程中分析其它HotSpot虚拟机的内存数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节</li></ul></li><li>步骤：<ul><li><code>jps -l</code> 查找对应进程的pid</li><li><code>jhsdb hsdb --pid 3224</code> 进入JHSDB图形化界面</li><li><code>revptrs 0x......</code> 内存块对应的引用指针位置</li></ul></li></ul><h3 id="4-3-2-JConsole-Java监视与管理控制台"><a href="#4-3-2-JConsole-Java监视与管理控制台" class="headerlink" title="4.3.2 JConsole: Java监视与管理控制台"></a>4.3.2 JConsole: Java监视与管理控制台</h3><ul><li>基于<code>JMX(Java Management Extensions)</code>的可视化监视、管理工具</li><li>通过JMX的MBean对系统进行信息收集和参数动态调整</li><li><code>内存</code>页签 - 相当于jstat命令, 监视被收集器直接管理的Java堆和被间接管理的方法区</li><li><code>线程</code>页签 - 相当于jstack命令，分析线程状况、死锁等</li><li>其它还有<code>类、VM摘要、MBean</code>等页签</li></ul><h3 id="4-3-3-VisualVM-多合一故障处理工具"><a href="#4-3-3-VisualVM-多合一故障处理工具" class="headerlink" title="4.3.3 VisualVM: 多合一故障处理工具"></a>4.3.3 VisualVM: 多合一故障处理工具</h3><ul><li>支持插件扩展</li><li>生成、浏览堆转储快照</li><li>分析程序性能</li><li>BTrace动态日志追踪</li></ul><h3 id="4-3-4-Java-Mission-Control-可持续在线的监控工具"><a href="#4-3-4-Java-Mission-Control-可持续在线的监控工具" class="headerlink" title="4.3.4 Java Mission Control: 可持续在线的监控工具"></a>4.3.4 Java Mission Control: 可持续在线的监控工具</h3><ul><li>JMC与虚拟机之间采取JMX协议进行通信</li><li>JMC一方面作为JMX的控制台，显示来自JVM MBean提供的数据，另一方面作为JFR的分析工具，展示来自JFR的数据</li><li><code>JFR(Java Flight Recorder)</code>是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜索框架，用于持续收集数据</li><li>JFR监控对应用完全透明，不需要对程序源码做任何修改或基于特定的代理运行</li></ul><h2 id="4-4-HotSpot虚拟机插件及工具"><a href="#4-4-HotSpot虚拟机插件及工具" class="headerlink" title="4.4 HotSpot虚拟机插件及工具"></a>4.4 HotSpot虚拟机插件及工具</h2><ul><li><code>Ideal Graph Visualizer</code>: 可视化展示C2即时编译器转换字节码</li><li><code>Client Compiler Visualizer</code>: 查看C1即时编译器生成高级中间表示，转换成低级中间表示和做物理寄存器分配的过程</li><li><code>MakeDeps</code>: 帮助处理HotSpot的编译依赖的工具</li><li><code>Project Creator</code>: 帮助生成Visual Studio的.project文件工具</li><li><code>LogCompiler</code>: 整理输出日志</li><li><code>HSDIS</code>: 即时编译器的反汇编插件</li></ul><h3 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h3><ul><li>让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出，并产生有价值的注释</li><li>日志输出量巨大，需配合<code>JITWatch</code>可视化工具使用</li></ul><h1 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 - 调优案例分析与实战"></a>第五章 - 调优案例分析与实战</h1><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><h3 id="5-2-1-大内存硬件上的程序部署策略"><a href="#5-2-1-大内存硬件上的程序部署策略" class="headerlink" title="5.2.1 大内存硬件上的程序部署策略"></a>5.2.1 大内存硬件上的程序部署策略</h3><ul><li><p>单体应用在较大内存的硬件上主要的部署方式分两种</p><ul><li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存</li><li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源</li></ul></li><li><p>对于用户交互性强，对停顿时间敏感，内存又较大的系统，必须控制Full GC频率，关键是老年代的稳定，主要取决于应用中大部分对象是否满足”朝生夕灭”的原则</p></li><li><p>使用单个JVM管理大内存可能面临的问题：</p><ul><li>回收大块堆内存而导致的长时间停顿</li><li>大内存必须有64位虚拟机支持，但64位虚拟机性能普遍略低于32位(指针压缩、处理器缓存行容量等)</li><li>必须保证应用程序的足够稳定</li><li>相同程序在64位下需要比32位消耗更多的内存(指针膨胀、数据类型对齐补白等)</li></ul></li><li><p>逻辑集群方式可能面临的问题：</p><ul><li>节点竞争全局资源，例如磁盘竞争</li><li>很难高效利用某些资源池</li><li>32位系统的节点受到内存限制</li><li>大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费</li></ul></li></ul><h3 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h3><ul><li>集群共享的数据要使用非集中式的集群缓存来同步的话，可以运行读操作频繁，但不应当有过于频繁的写操作</li></ul><h3 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h3><ul><li>在处理小内存或者32位的应用问题时，除了Java堆和方法区之外，还有以下区域会占用较多内存<ul><li>直接内存 (-XX:MaxDirectMemorySize)</li><li>线程堆栈 (-Xss)</li><li>Socket缓存区</li><li>JNI代码</li><li>虚拟机和垃圾收集器</li></ul></li></ul><h3 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h3><ul><li>Java的<code>Runtime.getRuntime().exec()</code>方法可以执行Shell脚本，但会先复制一个当前虚拟机环境变量的进程，再利用新的进程执行外部命令，最后再退出这个进程。频繁执行会造成系统消耗过大</li></ul><h3 id="5-2-5-服务器虚拟机进程崩溃"><a href="#5-2-5-服务器虚拟机进程崩溃" class="headerlink" title="5.2.5 服务器虚拟机进程崩溃"></a>5.2.5 服务器虚拟机进程崩溃</h3><ul><li>异步调用，服务速度不对等，最终超过虚拟机的承受能力</li></ul><h3 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h3><h3 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h3><h3 id="5-2-8-由安全点导致长时间停顿"><a href="#5-2-8-由安全点导致长时间停顿" class="headerlink" title="5.2.8 由安全点导致长时间停顿"></a>5.2.8 由安全点导致长时间停顿</h3><ul><li>三个时间概念：<ul><li>user: 进程执行用户态代码所耗费的处理器时间</li><li>sys: 进程执行核心态代码所耗费的处理器时间</li><li>real: 执行动作从开始到结束耗费的时钟时间</li><li>处理器时间指线程<strong>占用处理器一个核心</strong>的耗时计数</li><li>时钟时间就是指现实世界中的时间计数</li></ul></li><li>安全点的设置<ul><li>一般循环这样的长时间操作是会设置安全点的</li><li>但对于int或范围更小的数据类型作为索引值的循环默认时不放置安全点的，称可数循环(Counted Loop)</li><li>使用long或范围更大的数据类型作为索引值的循环会放置安全点，称不可数循环(Uncounted Loop)</li><li>如果可数循环本身非常耗时，需用<code>-XX:+UseCountedLoopSafepoints</code>强制开启可数循环放置安全点</li></ul></li></ul><h2 id="5-3-实战：Eclipse运行速度调优"><a href="#5-3-实战：Eclipse运行速度调优" class="headerlink" title="5.3 实战：Eclipse运行速度调优"></a>5.3 实战：Eclipse运行速度调优</h2><ul><li>三大块非用户程序时间<ul><li>类加载时间</li><li>编译时间<ul><li>JVM的即时编译器<code>Just In Time Compiler</code>编译热点代码<code>Hot Spot Code</code>的耗时</li></ul></li><li>垃圾收集时间<ul><li>最重要，最耗时，稳定持续的消耗</li></ul></li></ul></li></ul><h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 - 类文件结构"></a>第六章 - 类文件结构</h1><h2 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h2><ul><li>所有平台统一支持的程序存储格式——字节码<code>Byte Code</code>是构成平台无关性的基石<ul><li>Class文件包含了Java虚拟机指令集、符号集以及若干其它辅助信息</li></ul></li><li>语言无关性正在越来越被开发者所重视<ul><li>任何其它语言的实现者都可以将Java虚拟机作为它们语言的运行基础，以Class文件作为它们产品的交付媒介<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png" class="" title="alt JVM语言无关性"></li></ul></li></ul><h2 id="6-3-Class-类文件的结构"><a href="#6-3-Class-类文件的结构" class="headerlink" title="6.3 Class 类文件的结构"></a>6.3 Class 类文件的结构</h2><ul><li>Class文件是一组以8个字节为基础单位的二进制流</li><li>采用一种伪结构来存储数据，包括两种数据类型：<ul><li><code>无符号数</code>：基本数据类型，以u1&#x2F;u2&#x2F;u4&#x2F;u8分别代表1&#x2F;2&#x2F;4&#x2F;8个字节。用来描述数字、索引引用、数量值、UTF-8编码的字符串值</li><li><code>表</code>：多个无符号数或其它表 作为数据项构成的复合数据结构，以_info结尾用来描述有层次关系的复合数据结构</li></ul></li></ul><h3 id="6-3-1-魔数与Class文件版本"><a href="#6-3-1-魔数与Class文件版本" class="headerlink" title="6.3.1 魔数与Class文件版本"></a>6.3.1 魔数与Class文件版本</h3><ul><li>每个Class文件的头4个字节称魔数<code>Magic Number</code><ul><li>固定为<code>0xCAFEBABE</code> (咖啡宝贝)</li><li>作用是确定这个文件是否为一个能被虚拟机接受的Class</li></ul></li></ul><ul><li>第5、6两个字节是次版本号 <code>Minor Version</code><ul><li>若Class使用了实验性功能，则固定为65535，否则全0</li></ul></li></ul><ul><li>第7、8两个字节是主版本号 <code>Major Version</code><ul><li>版本号从45开始，例如JDK17的主版本就是45+17-1&#x3D;61</li><li>高版本JDK仅向下兼容</li><li>JVM必须拒绝执行超过其版本号的Class文件，即使Class格式未发生变化</li></ul></li></ul><h3 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h3><ul><li>位于次、主版本号之后</li><li>相当于Class文件的资源仓库，是Class结构中与其它项目关联最多的数据，占比也最大</li><li>首先入口处需放置一个u2类型的常量池容量计数器 (容量从1开始，即<code>常量数=counter-1</code>)</li><li>主要存放两大类常量，每一项都是一个表，共17种类型：<ul><li>字面量：如文本字符串、final等</li><li>符号引用：<ul><li>被模块导出或者开放的包</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul></li></ul></li><li>可用<code>javap -verbose</code>输出字节码内容</li></ul><h3 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h3><ul><li>常量池之后的两个字节</li><li>用于识别一些类或者接口层次的访问信息</li><li>一共16个标志位可以使用，Java定义了其中9个，未定义的一律为0<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" class="" title="alt 访问标志"></li></ul><h3 id="6-3-4-类索引、父索引与接口索引集合"><a href="#6-3-4-类索引、父索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父索引与接口索引集合"></a>6.3.4 类索引、父索引与接口索引集合</h3><ul><li><p>类索引：u2，用于确定类的全限定名</p></li><li><p>父索引：u2，用于确定这个类的父类的全限定名</p><ul><li>类索引、父索引各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过其中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型常量中的全限定名字符串。搜索关系如下图<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B.png" class="" title="alt 类索引定位过程"></li></ul></li><li><p>接口索引集合：u2类型数据集合，描述该类实现了哪些接口</p><ul><li>接口索引的入口是u2类型的计数器，表示索引表的容量</li></ul><p>这三项数据确定类的继承关系，按顺序排列在访问标志之后</p></li></ul><h3 id="6-3-5-字段表-field-info-集合"><a href="#6-3-5-字段表-field-info-集合" class="headerlink" title="6.3.5 字段表 field_info 集合"></a>6.3.5 字段表 field_info 集合</h3><ul><li>用于描述接口或类中声明的变量，包括类级变量和实例级变量</li><li>结构如下<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="alt 字段表结构"><ul><li><code>access_flags</code> 访问标志位，如是否public&#x2F;private&#x2F;protected&#x2F;static&#x2F;final&#x2F;volatile&#x2F;transient等</li><li><code>name_index</code> 字段的简单名称</li><li><code>descriptor_index</code> 方法描述符</li><li><code>attribute_info</code> 附加的额外信息</li></ul></li></ul><ul><li>类的全限定名：org&#x2F;chanper&#x2F;TestClass</li><li>简单名称：没有类型和参数修饰的方法或字段名称</li><li>描述符：描述字段的数据类型，方法参数列表和返回值。    <ul><li>标识字符含义：</li><li>描述方法时，按照先参数列表，后返回值的顺序描述。参数列表放置于()中。如方法<code>java.lang.String toString()</code>的描述符为：<code>()Ljava/lang/String</code></li></ul></li></ul><h3 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h3><ul><li>结构类似字段表，依次包括<code>access_flags</code>，<code>name_index</code>，<code>descriptor_index</code>，<code>attribute_info</code>。仅标志位略不同</li><li>方法里的代码存放在方法属性表集合中的名为<code>Code</code>的属性中</li><li>Class文件中的方法特征签名范围更大，包括返回值和受查异常表</li></ul><h3 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h3><ul><li>Class文件、字段表、方法表都可以携带自己的属性表集合，且顺序不严格，可以写入自定义属性</li><li>每个属性都要从常量池中引用一个Constant_Utf8_info类型的常量来表示，包括<code>u2 attribute_name_index</code>, <code>u4 attribute_length</code>, <code>u1 info</code>三个字段。</li><li>属性值结构自定义，通过<code>attribute_length</code>指明长度</li></ul><h4 id="1-Code-属性"><a href="#1-Code-属性" class="headerlink" title="1. Code 属性"></a>1. Code 属性</h4><ul><li>方法体里面的代码经编译后存储在Code内。是Class文件最重要的属性</li><li><code>attribute_name_index</code>, <code>attribute_length</code></li><li><code>max_stack</code>: 操作数栈最大深度</li><li><code>max_locals</code>: 局部变量表所需存储空间(单位<code>Slot</code>)。<code>Slot</code>根据局部变量的作用域可复用，所以此大小是同时生存的最大局部变量空间</li><li><code>code</code>: (Code.code)字节码指令，约200种。大小u1，因此最多256种指令。</li><li><code>exception_table</code>: 异常表</li></ul><h4 id="2-Exceptions-属性"><a href="#2-Exceptions-属性" class="headerlink" title="2. Exceptions 属性"></a>2. Exceptions 属性</h4><ul><li>列举方法中可能抛出的受查异常(throws关键字)</li><li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>number_of_exceptions</code></li><li><code>exception_index_table</code>: 受查异常类型，指向常量池中的<code>CONSTANT_Class_info</code></li></ul><h4 id="3-LineNumberTable-属性"><a href="#3-LineNumberTable-属性" class="headerlink" title="3. LineNumberTable 属性"></a>3. LineNumberTable 属性</h4><ul><li>描述Java源码行号与字节码偏移量的对应关系</li><li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>line_number_table_length</code></li><li><code>line_number_table</code></li></ul><h4 id="4-LocalVariableTable-与-LocalVariableTypeTable"><a href="#4-LocalVariableTable-与-LocalVariableTypeTable" class="headerlink" title="4. LocalVariableTable 与 LocalVariableTypeTable"></a>4. LocalVariableTable 与 LocalVariableTypeTable</h4><ul><li><code>LocalVariableTable</code>描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</li><li><code>LocalVariableTypeTable</code>使用字段的特征签名来完成泛型的描述</li></ul><h4 id="5-SourceFile-与-SourceDebugExtension"><a href="#5-SourceFile-与-SourceDebugExtension" class="headerlink" title="5. SourceFile 与 SourceDebugExtension"></a>5. SourceFile 与 SourceDebugExtension</h4><ul><li><code>SourceFile</code>记录生成Class文件的源码文件名称</li><li><code>SourceDebugExtension</code>存储额外的代码调试信息</li></ul><h4 id="6-ConstantValue-属性"><a href="#6-ConstantValue-属性" class="headerlink" title="6. ConstantValue 属性"></a>6. ConstantValue 属性</h4><ul><li><code>ConstantValue</code>通知虚拟机自动为静态变量赋值</li><li>实例变量在实例构造器<code>&lt;init&gt;()</code>方法中完成赋值</li><li>类变量如果是<code>static final</code>的<code>基本类型或String</code>，就用<code>ConstantValue</code>初始化，否则在类构造器<code>&lt;clinit&gt;()</code>方法中初始化</li></ul><h4 id="7-InnerClasses-属性"><a href="#7-InnerClasses-属性" class="headerlink" title="7. InnerClasses 属性"></a>7. InnerClasses 属性</h4><ul><li>记录内部类和宿主类之间的关联</li><li><code>inner_classes</code>, <code>inner_class_info_index</code>, <code>outer_class_info_index</code>, <code>inner_class_flags</code></li></ul><h4 id="8-Deprecated-与-Synthetic"><a href="#8-Deprecated-与-Synthetic" class="headerlink" title="8. Deprecated 与 Synthetic"></a>8. Deprecated 与 Synthetic</h4><ul><li>都是标志类型的布尔属性，没有属性值</li><li><code>Deprecated</code>标识某个类、方法、字段不再推荐使用</li><li><code>Synthetic</code>标识此字段、方法由编译器自动产生，非源码直接产生</li></ul><h4 id="9-StackMapTable-属性"><a href="#9-StackMapTable-属性" class="headerlink" title="9. StackMapTable 属性"></a>9. StackMapTable 属性</h4><ul><li>在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，代替以前消耗性能的基于数据流分析的类型推导验证器</li><li><code>stack_map_frame_entries</code></li></ul><h4 id="10-Signature-属性"><a href="#10-Signature-属性" class="headerlink" title="10. Signature 属性"></a>10. Signature 属性</h4><ul><li>记录泛型签名信息</li><li>Java的泛型实现是伪泛型，实现简单，容易Backport，内存开销较小</li><li>但运行期反射无法获取泛型类型</li></ul><h4 id="11-BootstrapMethods-属性"><a href="#11-BootstrapMethods-属性" class="headerlink" title="11. BootstrapMethods 属性"></a>11. BootstrapMethods 属性</h4><ul><li>用于保存<code>invokeDynamic</code>指令引用的引导方法限定符</li><li><code>bootstrap_methods</code></li></ul><h4 id="12-MethodParameters-属性"><a href="#12-MethodParameters-属性" class="headerlink" title="12. MethodParameters 属性"></a>12. MethodParameters 属性</h4><ul><li>记录方法的各个形参名称和信息</li><li><code>parameters</code></li></ul><h4 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13. 模块化相关属性"></a>13. 模块化相关属性</h4><ul><li><code>Module</code>存储模块名称、版本、标志信息、模块requires、exports、opens、uses、provides等</li><li><code>ModulePackages</code>描述该模块中所有的包</li><li><code>ModuleMainClass</code>确定该模块的主类</li></ul><h4 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14. 运行时注解相关属性"></a>14. 运行时注解相关属性</h4><ul><li><code>RuntimeVisibleAnnotations</code>, <code>RuntimeInvisibleAnnotations</code></li><li><code>RuntimeVisibleParameterAnnotations</code>, <code>RuntimeInvisibleParameterAnnotations</code></li><li><code>RuntimeVisibleTypeAnnotations</code>, <code>RuntimeInvisibleTypeAnnotations</code></li></ul><h2 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h2><ul><li>JVM的指令由一个字节长度的操作码<code>Opcode</code>,和零至多个操作数<code>Operand</code>构成</li><li>面向操作数栈</li></ul><h3 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1 字节码与数据类型"></a>6.4.1 字节码与数据类型</h3><ul><li>大多数指令都包含其操作对应的数据类型信息</li><li>对于<code>boolean，byte，short，char</code>类型的操作，实际上都是使用相应的<code>int</code>类型作为运算类型来进行的<ul><li>编译期或运行期会将<code>byte和short</code>类型的数据带符号扩展为相应的<code>int</code>类型数据</li><li>编译期或运行期会将<code>boolean和char</code>类型数据零位扩展为相应的<code>int</code>类型数据</li></ul></li></ul><h3 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2 加载和存储指令"></a>6.4.2 加载和存储指令</h3><ul><li>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</li><li>如<code>iload，lload，fload，istore，fstore，bipush，sipush...</code></li></ul><h3 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3 运算指令"></a>6.4.3 运算指令</h3><ul><li>对两个操作数栈上的值进行某种特定运算，并将结果重新存入到操作栈顶</li><li>分为对整型数据、浮点型数据运算的指令</li><li>如<code>iadd，isub，imul，idiv...</code></li><li>JVM的向零舍入模式：截断数字</li><li>向最接近数舍入模式：优先选择最低有效位为0的</li></ul><h3 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4 类型转换指令"></a>6.4.4 类型转换指令</h3><ul><li>将两种不同的数值类型相互转换</li><li>JVM直接支持以下类型的宽化类型转换：<ul><li><code>int -&gt; long, float, double</code></li><li><code>long -&gt; float, double</code></li><li><code>float -&gt; double</code></li></ul></li><li>窄化类型转换，必须使用显示转换指令。可能发生上限溢出，下限溢出，精度丢失</li></ul><h3 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5 对象创建与访问指令"></a>6.4.5 对象创建与访问指令</h3><ul><li>创建类：<code>new</code></li><li>创建数组：<code>newarray，anewarray，multianewarray</code></li><li>JVM对类实例和数组的创建与操作使用了不同的字节码指令</li></ul><h3 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6 操作数栈管理指令"></a>6.4.6 操作数栈管理指令</h3><ul><li>出栈：<code>pop</code></li><li>复制栈顶元素：<code>dup</code></li><li>栈顶两个元素互换：<code>swap</code></li></ul><h3 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7 控制转移指令"></a>6.4.7 控制转移指令</h3><ul><li>让JVM有条件或无条件得从指定位置得一下条指令继续执行程序(修改PC值)</li><li>分条件分支、复合条件分支、无条件分支等</li><li>各种类型的比较最终都会转换为int类型的比较操作</li></ul><h3 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8 方法调用和返回指令"></a>6.4.8 方法调用和返回指令</h3><ul><li><code>invokevirtual</code>：调用对象的方法实例</li><li><code>invokeinterface</code>：调用接口方法</li><li><code>invokespecial</code>：调用一些需要特殊处理的实例方法</li><li><code>invokestatic</code>：调用类静态方法</li><li><code>invokedynamic</code>：用于在运行时动态解析出调用点限定符所引用的方法</li></ul><h3 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9 异常处理指令"></a>6.4.9 异常处理指令</h3><ul><li>显式抛出异常：<code>athrow</code></li><li>处理异常(catch)采用异常表完成，而不是字节码指令</li></ul><h3 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10 同步指令"></a>6.4.10 同步指令</h3><ul><li>JVM支持方法级的同步和方法内部一段指令序列的同步，使用管程Monitor来实现</li><li>ACC_SYNCHRONIZED访问标志标记一个方法是否声明为同步方法</li><li>monitorenter和monitorexit两条指令支持synchronized关键字的语义</li></ul><h2 id="6-5-共有设计，私有实现"><a href="#6-5-共有设计，私有实现" class="headerlink" title="6.5 共有设计，私有实现"></a>6.5 共有设计，私有实现</h2><ul><li>JVM实现方式：<ul><li>将输入的JVM代码在加载或执行时翻译成另一种虚拟机的指令集</li><li>将输入的JVM代码在加载或执行时翻译成宿主机处理程序的本地指令集(即时编译)</li></ul></li></ul><h2 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6 Class文件结构的发展"></a>6.6 Class文件结构的发展</h2><ul><li>Class文件格式具备的平台中立、紧凑、稳定和可扩展的特点是Java技术体系实现平台无关、语言无关两项特性的重要支柱</li></ul><h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 - 虚拟机类加载机制"></a>第七章 - 虚拟机类加载机制</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ul><li>类加载机制：JVM把描述类的数据从Class文件加载到内存，并对数据继续校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</li><li>Java中，类型的加载、连接和初始化过程都是在程序运行期完成的</li></ul><h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><ul><li>类加载到卸载的七个阶段，其中验证、准备、解析三个部分统称连接<ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul></li><li>这些阶段通常都是互相交叉混合进行的，一个阶段的执行过程中调用、激活另一个阶段</li><li>JVM有且只有以下六种情况必须对类进行初始化(主动引用)<ul><li>遇到new, getstatic, putstatic, invokestatic这四条字节码指令时。例如new关键字实例化对象，读取或设置一个类的静态字段，调用类型的静态方法时</li><li>java.lang.reflect对类型进行反射调用的时候</li><li>初始化类时发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>JVM启动时，包含main()方法的类需要先初始化</li><li>动态语言支持，方法句柄对应的类尚未进行初始化时</li><li>接口中有default关键字修饰的接口方法，在其实现类初始化时需要先初始化该接口</li></ul></li><li>其它引用类型的方式称为被动引用，都不会触发初始化。如：<ul><li>子类引用父类定义的静态字段，只会初始化父类，而不会初始化子类</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="alt 类的生命周期"><h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h2><h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><ul><li>完成三件事：<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li>获取类的二进制字节流不限于Class文件，还可以是压缩包如jar，网络如applet，动态生成，数据库等等</li><li>数据类本身不通过类加载器创建，它是由JVM直接在内存中动态构造出来的</li></ul><h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><ul><li>目的是确保Class文件的字节流包含的信息符合全部约束要求，保证代码运行不会JVM自身的安全</li><li>分四个阶段：<ul><li>文件格式验证：保证输入的字节流能正确解析并存储于方法区之内</li><li>元数据验证：对字节码描述信息进行语义分析</li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义合法，符合逻辑。(停机问题：不完全保证合法)</li><li>符号引用验证：对类自身以外的各类信息进行匹配性校验</li></ul></li></ul><h3 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h3><ul><li>正式为类中定义的变量(静态变量)分配内存并设置类变量初始值的阶段</li><li>通常情况下初始值是数据类型的零值，除非类字段存在ConstantValue属性</li></ul><h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><ul><li>将常量池内的符号引用替换为直接引用的过程</li><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标</li><li>直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li><li>分为：<ul><li>类或接口的解析</li><li>字段解析</li><li>方法解析</li><li>接口方法解析</li></ul></li></ul><h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><ul><li>类加载的最后一个阶段，根据程序编码初始化类变量和其它资源(执行类构造器<code>&lt;clinit&gt;()</code>)</li><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<code>类变量的赋值动作</code>和<code>静态语句块</code>合并产生的，顺序由源文件中定义顺序决定</li><li>JVM中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型一定是<code>java.lang.Object</code></li><li>接口(实现类)的<code>&lt;clinit&gt;()</code>不需要先执行(父)接口的<code>&lt;clinit&gt;()</code></li><li>同一个类加载器下，一个类型只会被初始化一次</li></ul><h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><ul><li>实现<code>&quot;通过类全限定名来获取描述该类的二进制字节流&quot;</code>这个动作的代码称为<code>类加载器Class Loader</code></li><li>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在JVM中的唯一性</li></ul><h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><ul><li>从JVM角度，只有两种不同的类加载器：<ul><li>启动类加载器Boostrap ClassLoader，C++实现，JVM自身的一部分</li><li>其它类加载器，Java实现，独立于JVM，且全部继承自抽象类<code>java.lang.ClassLoader</code></li></ul></li><li>开发者角度，分三种类加载器<ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li></ul></li><li>各种类加载器之间的层次关系称类加载器的<strong>双亲委派模型</strong>。<ul><li>要求除了顶层的启动类加载器外，其它的类加载器必须有自己的父类加载器(一般通过组合关系实现复用)</li><li>类加载器工作时收到类加载的请求，首先交给父类加载器去完成，父类无法完成时才自己去加载<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class="" title="alt 类加载器的双亲委派模型"></li></ul></li></ul><h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><ul><li>三次破坏</li><li>OSGi实现模块化部署的关键是它自定义的类加载器机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。类加载器不再是双亲委派模型，而是更加复杂的网状结构</li></ul><h2 id="7-5-Java模块化系统"><a href="#7-5-Java模块化系统" class="headerlink" title="7.5 Java模块化系统"></a>7.5 Java模块化系统</h2><ul><li>模块化的关键目标：可配置的封装隔离机制</li><li>JDK 9之后的类加载委派关系：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%A7%94%E6%B4%BE%E5%85%B3%E7%B3%BB.png" class="" title="alt JDK9之后的类加载委派关系"></li></ul><h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 - 虚拟机字节码执行引擎"></a>第八章 - 虚拟机字节码执行引擎</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ul><li>执行引擎是虚拟机核心的组成部分之一</li><li>物理机的执行引擎直接建立在处理器、缓存、指令集和OS层面上，而JVM执行引擎有软件自行实现，不受物理条件制约，能够执行不被硬件直接支持的指令集格式</li><li>分解释执行、编译执行两种方式</li><li>执行引擎的输入是字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果</li></ul><h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><ul><li>JVM以方法作为最基本的执行单元</li><li>栈帧是支持JVM进行方法调用和方法执行的数据结构，也是JVM运行时数据区中<strong>虚拟机栈</strong>的元素</li><li>每一个栈帧包括<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>方法返回地址</code>和一些额外的<code>附加信息</code></li><li>对于执行引擎而言，活动线程中栈顶的方法是运行的，称<strong>当前栈帧</strong>，关联方法称<strong>当前方法</strong>。执行引擎的所有字节码指令只针对当前栈帧操作</li></ul><h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><ul><li>一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</li><li>容量以变量槽<code>Slot</code>为最小单位<ul><li>除了<code>long double</code>需要2个Slot外，其余数据类型都需要1个Slot</li><li>Slot根据变量作用范围可复用</li></ul></li><li>JVM通过索引定位的方法使用局部变量表，范围从0开始至局部变量表最大的变量槽数量</li><li>JVM实现通过引用应完成两件事：<ul><li>根据引用直接或间接找到对象在Java堆种数据存放的起始地址或索引</li><li>根据引用直接或间接找到对象所属数据类型在方法区中存储的类型信息</li></ul></li><li>类字段有两次赋初始值的过程，一次是准备阶段赋系统初始值，另一次是初始化阶段赋程序定义初始值。但局部变量没有初始化就不能使用</li></ul><h3 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h3><ul><li>Operand Stack 后入先出栈</li><li>32位数据栈容量为1，64位栈容量为2</li><li>优化处理：两个不同的栈帧会出现一部分重叠，节约空间，且可以共享一部分数据</li></ul><h3 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h3><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，以便支持调用过程中的动态连接</li></ul><h3 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h3><ul><li>两种退出方法执行的方式：<ul><li>正常调用完成，正常向主调函数提供返回值</li><li>异常调用完成，不会提供任何返回值</li></ul></li></ul><h3 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h3><ul><li>JVM规范没有描述的信息，如调试、性能收集相关信息</li><li>一般把动态连接、方法返回地址以及其它附加信息全部归为栈帧信息</li></ul><h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><ul><li>方法调用阶段唯一的任务是确定被调用方法的版本</li><li>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址</li></ul><h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><ul><li>如果一个方法符合<strong>编译器可知，运行期不可变</strong>，那么JVM在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这类方法的调用称为<code>解析</code></li><li>符合条件的方法包括静态方法、私有方法、实例构造器、父类方法，以及final修饰的方法。这五类方法统称<code>非虚方法</code>。其它方法称为<code>虚方法</code>。</li><li>前四类通过<code>invokestatic, invokespecial</code>指令调用，final方法通过<code>invokevirtual</code>调用(历史原因)</li><li>因此，解析调用是一个静态过程，编译器完全确定</li></ul><h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><p>解析与分派并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticDispatch</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Human guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Human!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Man guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Man!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Woman woman)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Woman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br><br>        <span class="hljs-type">StaticDispatch</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDispatch</span>();<br>        sd.sayHello(man);   <span class="hljs-comment">// 输出：Hello, Human!</span><br>        sd.sayHello(woman); <span class="hljs-comment">// 输出：Hello, Human!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Human称为变量的静态类型(外观类型)，编译期可知</li><li>Man&#x2F;Woman称为变量的实际类型(运行时类型)，运行期确定</li></ul><ul><li>JVM(编译器)在<code>重载</code>时通过参数的静态类型作为判断依据，而非实际类型</li><li>所有依赖静态类型决定方法执行版本的分派动作，都称为静态分派</li><li>发生在编译阶段</li><li>典型应用：方法重载</li></ul><p>一个更加极端恶心的例子，查看调用哪个sayHello，并注释对应方法再次执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Overload</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">long</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Character arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Character&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span>... arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Serializable arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Serializable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        sayHello(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发现重载的顺序是：char -&gt; int -&gt; long -&gt; Character -&gt; Serializable -&gt; Object -&gt; char…</li><li>重载的优先级：<ul><li>优先进行宽化转型</li><li>接着是自动装箱。char可以转型成int，但Character不可能转型成Integer</li><li>接着是实现的接口 -&gt; 父类(根据继承关系从下往上搜索)</li><li>最后是边长参数</li></ul></li></ul><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDispatch</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Man say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Woman say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Man say hello</span><br>        woman.sayHello();   <span class="hljs-comment">// Woman say hello</span><br><br>        man = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Woman say hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>确定调用方法的关键在于<code>invokevirtual</code>指令的步骤<ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，查找过程结束。不通过则返回<code>java.lang.IllegalAccessError</code></li><li>否则，按照继承关系自下而上依次对C的各个父类进行第二步的搜索和验证过程</li><li>如果始终没有找到合适的方法，抛出<code>java.lang.AbstractMethodError</code></li></ol></li><li><code>invokevirtual</code>的第一步就在运行期确定了接收者的实际类型，这就是Java方法重写的本质</li><li>这种在<strong>运行期</strong>根据实际类型确定方法执行版本的分派过程称为动态分配</li><li>典型应用：方法重写</li></ul><p>另外，只存在虚方法，不存在虚字段，即字段永远不参与多态。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldHasNoPolymorphic</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">2</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">guy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br><br>        <span class="hljs-comment">// 输出：</span><br>        <span class="hljs-comment">// I am Son, i have $0</span><br>        <span class="hljs-comment">// I am Son, i have $4</span><br>        <span class="hljs-comment">// This guy has $2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Son的构造器首先隐式调用Father构造器。但Father构造器中的showMeTheMoney()是虚方法调用，实际执行的是Son::showMeTheMoney(),且访问的是Son::money(尚未初始化&#x3D;0)</li><li>然后执行自身的构造器</li></ul><h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>单分派：根据一个宗量对目标方法进行选择</li><li>多分派：根据多于一个宗量对目标方法进行选择</li><li>Java语言是一门静态多分派，动态单分派的语言</li></ul><h4 id="JVM动态分派的实现"><a href="#JVM动态分派的实现" class="headerlink" title="JVM动态分派的实现"></a>JVM动态分派的实现</h4><ul><li>基于执行性能的考虑，JVM通常为类型在方法区建立虚方法表vtable，用虚方法表索引代替元数据以提高性能</li><li>虚方法表存放着各个方法的实际入口地址。<ul><li>如果某个方法在子类中没有重写，那子类的虚方法地址入口和父类一致。</li><li>如果子类重写了该方法，则地址入口被替换成子类实现版本的入口地址<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="" title="alt 方法表结构"></li></ul></li></ul><h2 id="8-4-动态类型语言支持"><a href="#8-4-动态类型语言支持" class="headerlink" title="8.4 动态类型语言支持"></a>8.4 动态类型语言支持</h2><p><strong>JVM 自诞生以来的二十年间，唯一新增的指令 —— <code>invokedynamic</code></strong></p><h3 id="8-4-1-动态类型语言"><a href="#8-4-1-动态类型语言" class="headerlink" title="8.4.1 动态类型语言"></a>8.4.1 动态类型语言</h3><ul><li>关键特征：<ul><li>类型检查的主体过程是在运行期，而非编译期</li><li>变量无类型，而变量值才有类型</li><li>相比于静态类型语言的编译器可以提供全面严谨的类型检查，动态类型语言更加灵活，清晰简洁</li></ul></li></ul><ul><li>运行时异常：只要代码不执行到这一行就不会出现问题</li><li>连接时异常：即使代码放到不会被执行到的路径分支上，类加载时也会抛出异常</li></ul><h3 id="8-4-2-Java与动态类型"><a href="#8-4-2-Java与动态类型" class="headerlink" title="8.4.2 Java与动态类型"></a>8.4.2 Java与动态类型</h3><ul><li>JDK 7以前的4条方法调用指令的实现方式，导致JVM上的动态类型语言实现复杂，同时带来额外的性能和内存开销</li></ul><h3 id="8-4-3-java-lang-invoke包"><a href="#8-4-3-java-lang-invoke包" class="headerlink" title="8.4.3 java.lang.invoke包"></a>8.4.3 java.lang.invoke包</h3><ul><li>主要目的是在之前单纯依赖符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制。称为<code>方法句柄 Method Handle</code></li><li>反射也能实现方法句柄的功能，但存在一些区别：<ul><li>Reflection在模拟Java代码层次的方法调用，而MethodHandle模拟字节码层次</li><li>Reflection中的Method对象(Java端的全面映像)远比MethodHandle中的对象包含的信息更多。也即Reflection重量级，MethodHandle轻量级。</li><li>MethodHandle由于在字节码层次，可以实施各类调用点优化措施</li></ul></li></ul><h3 id="8-4-4-invokedynamic-指令"><a href="#8-4-4-invokedynamic-指令" class="headerlink" title="8.4.4 invokedynamic 指令"></a>8.4.4 invokedynamic 指令</h3><ul><li>和MethodHandle机制作用一样，解决原有4条invoke指令分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，提供更高的自由度</li><li>每一处含有invokedynamic指令的位置称作动态调用点</li></ul><h2 id="8-5-基于栈的字节码解释执行引擎"><a href="#8-5-基于栈的字节码解释执行引擎" class="headerlink" title="8.5 基于栈的字节码解释执行引擎"></a>8.5 基于栈的字节码解释执行引擎</h2><h3 id="8-5-1-解释执行"><a href="#8-5-1-解释执行" class="headerlink" title="8.5.1 解释执行"></a>8.5.1 解释执行</h3><ul><li>基于物理机、JVM、或其他非Java的高级语言虚拟机的代码执行过程，大体上遵循现代经典编译原理的思路：在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树 AST(Abstract Syntax Tree)</li><li>词法、语法分析以及优化器、目标代码生成可以独立于执行引擎，形成完整意义的编译器，如C&#x2F;C++</li><li>也把其中一部分实现为一个半独立的编译器，如Java</li><li>又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子，如JavaScript执行引擎</li></ul><h3 id="8-5-2-基于栈的指令集和基于寄存器的指令集"><a href="#8-5-2-基于栈的指令集和基于寄存器的指令集" class="headerlink" title="8.5.2 基于栈的指令集和基于寄存器的指令集"></a>8.5.2 基于栈的指令集和基于寄存器的指令集</h3><ul><li>基于栈：<ul><li>指令通常不带参数(零地址指令)，使用操作数栈中的数据作为指令的运算输入，运算结果也存储在操作栈中</li><li>优点：可移植，代码相对紧凑，编译器实现更加简单</li><li>缺点：理论执行速度相对稍慢，完成相同功能所需指令数量更多</li></ul></li><li>基于寄存器：<ul><li>指令直接对寄存器进行操作，包含地址和操作数</li></ul></li></ul><h1 id="第九章-类加载及执行子系统的案例和实战"><a href="#第九章-类加载及执行子系统的案例和实战" class="headerlink" title="第九章 - 类加载及执行子系统的案例和实战"></a>第九章 - 类加载及执行子系统的案例和实战</h1><h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><h3 id="9-2-1-Tomcat：正统的类加载器架构"><a href="#9-2-1-Tomcat：正统的类加载器架构" class="headerlink" title="9.2.1 Tomcat：正统的类加载器架构"></a>9.2.1 Tomcat：正统的类加载器架构</h3><ul><li>一个功能健全的Web服务器需要解决以下问题：<ul><li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li><li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以相互共享</li><li>服务器应尽可能保证自身的安全不受部署的程序的影响</li><li>支持HotSwap热替换功能</li></ul></li><li>Tomcat的类加载器<ul><li><code>Common</code>类加载器：加载<code>/commons/*</code>，可被Tomcat和所有Web程序共同使用</li><li><code>Catalina</code>类加载器(Server类加载器)：加载<code>/server/*</code>，可被Tomcat使用，对Web程序不可见</li><li><code>Shared</code>类加载器: 加载<code>/shared/*</code>，被所有Web程序共同使用，对Tomcat本身不可见</li><li><code>Webapp</code>类加载器：加载<code>/WebApp/WEB-INF/*</code>，仅被该Web程序使用</li></ul></li><li>每一个Web应用程序对应一个WebApp类加载器，可以存在多个实例</li><li>每一个JSP文件对应一个JasperLoader类加载器 (HotSpot，JSP文件修改后重新创建新的JSP类加载)<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9E%B6%E6%9E%84.png" class="" title="alt Tomcat类加载器架构"></li></ul><h3 id="9-2-2-OSGi-灵活的类加载器架构"><a href="#9-2-2-OSGi-灵活的类加载器架构" class="headerlink" title="9.2.2 OSGi: 灵活的类加载器架构"></a>9.2.2 OSGi: 灵活的类加载器架构</h3><ul><li>OSGi (Open Service Gateway Initiative) 是OSGi联盟制定的基于Java语言的动态模块化规范</li><li>OSGi的每个模块Bundle的类加载器之间只有规则，没有固定的委派关系</li><li>从双亲委派模型的树形结构进一步发展成更加复杂的、运行时才能确定的网状结构</li></ul><h3 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h3><ul><li>字节码生成技术：javac、字节码类库、JSP编译器、AOP框架、动态代理(如Spring对Bean的增强)、反射等等</li><li>相对于实际用Java代码编写了代理类的<strong>静态代理</strong>，<strong>动态代理</strong>的优势不止是省去编码工作量，更是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为。当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</li></ul><h3 id="9-2-4-Backport工具：Java的时光机器"><a href="#9-2-4-Backport工具：Java的时光机器" class="headerlink" title="9.2.4 Backport工具：Java的时光机器"></a>9.2.4 Backport工具：Java的时光机器</h3><ul><li><code>Java Backporting Tools</code> Java逆向移植工具,把高版本JDK代码部署到低版本JDK环境中。实现工具如 Retrotranslator, Retrolambda</li><li>JDK每次升级的改进大致分以下五类：<ul><li>Java类库API的增强。如JDK 5引入的java.util.concurrent并发包</li><li>前端编译器层面的改进，称作语法糖。如自动装箱拆箱、变长参数、泛型等</li><li>需要在字节码中进行支持的改动。如动态语言支持需要新增invokedynamic指令</li><li>需要在JDK整体结构层面进行支持的改进。如Java模块化系统</li><li>集中在虚拟机内部的改进。如JDK 5重新定义的Java内存模型；G1、ZGC、Shenandoah收集器等</li></ul></li></ul><h2 id="9-3-实战-动手实现远程执行功能"><a href="#9-3-实战-动手实现远程执行功能" class="headerlink" title="9.3 实战 - 动手实现远程执行功能"></a>9.3 实战 - 动手实现远程执行功能</h2><p>使用前面学到的关于类加载及虚拟机执行子系统的知识去完成在服务端执行临时代码的功能。</p><h1 id="第十章-前边编译与优化"><a href="#第十章-前边编译与优化" class="headerlink" title="第十章 - 前边编译与优化"></a>第十章 - 前边编译与优化</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul><li>编译期可分为：<ul><li>前端编译器： *.java -&gt; *.class</li><li>JVM的即时编译器 JIT： 运行期字节码 -&gt; 本地机器码</li><li>静态提前编译器 AOT：  程序 -&gt; 二进制代码</li></ul></li><li>JVM对性能的全部优化集中在运行期的JIT中，让非javac产生的Class文件(如 JRuby、Groovy)也能享受编译器的优化措施</li><li>Java中的即时编译器在运行期的优化措施，支撑了程序执行效率的不断提升；前端编译器在编译期的优化过程，则是支撑了程序员的编码效率和语言使用者幸福感的提升。</li></ul><h2 id="10-2-Javac编译器"><a href="#10-2-Javac编译器" class="headerlink" title="10.2 Javac编译器"></a>10.2 Javac编译器</h2><pre><code class="hljs">Javac本身是由Java语言编写的程序</code></pre><h3 id="10-2-1-Javac的源码与调试"><a href="#10-2-1-Javac的源码与调试" class="headerlink" title="10.2.1 Javac的源码与调试"></a>10.2.1 Javac的源码与调试</h3><p>编译过程大致分为1个准备过程+3个处理过程</p><ul><li>准备过程：初始化插入式注解处理器</li><li>解析与填充符号表过程，包括：<ul><li>词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树</li><li>填充符号表：产生符号地址和符号信息</li></ul></li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程，包括：<ul><li>标注检查：对语法的静态信息进行检查</li><li>数据流及控制流分析：对程序动态运行过程进行检查</li><li>解语法糖：将简化代码编写的语法糖还原为原有的形式</li><li>字节码生成：将前面各个步骤所生成的信息转化为字节码</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" class="" title="alt javac编译过程"><h3 id="10-2-2-解析与填充符号表"><a href="#10-2-2-解析与填充符号表" class="headerlink" title="10.2.2 解析与填充符号表"></a>10.2.2 解析与填充符号表</h3><p><strong>1. 词法、语法分析</strong></p><ul><li>词法分析：将源码中的字符流转变为标记Token的过程。程序编写的最小元素是单个字符，编译时的最小元素是标记。</li><li>语法分析：根据标记序列构造抽象语法树的过程。AST是一种用来描述程序代码语法结构的树形表示形式，其中每个节点都代表着程序代码中的一个语法结构，如包、类型、修饰符、运算符、接口等</li></ul><p><strong>2. 填充符号表</strong></p><ul><li>符号表是由一组符号地址和符号信息构成的数据结构 (类似键值对的存储形式)</li><li>符号表登记的信息在后续语义分析、目标代码生成阶段都要使用</li></ul><h3 id="10-2-3-注解处理器"><a href="#10-2-3-注解处理器" class="headerlink" title="10.2.3 注解处理器"></a>10.2.3 注解处理器</h3><ul><li>插入式注解器可以看作一组编译器的插件，插件工作时可以读取、修改、添加抽象语法树中的任意元素</li><li>处理注解期间，如果注解器对语法树进行过修改，编译器将重新解析、填充符号表。每次循环称为一个轮次Round</li><li>典型应用：Lombok工具</li></ul><h3 id="10-2-4-语义分析与字节码生成"><a href="#10-2-4-语义分析与字节码生成" class="headerlink" title="10.2.4 语义分析与字节码生成"></a>10.2.4 语义分析与字节码生成</h3><p><strong>1. 语义分析</strong></p><ul><li>AST能够表示一个结构正确的源程序，但无法保证语义符合逻辑，因此需要语义分析对结构上正确的源程序进行上下文相关性质的检查。</li><li>分以下两类：<ul><li>标注检查：检查包括变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等，另外还有<code>常量折叠</code>等少量代码优化</li><li>数据及控制流：检查诸如程序局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理了等问题。(某些语义只能在编译期，而不能在运行期检查)</li></ul></li></ul><p><strong>2. 语法糖 Syntactic Sugar</strong></p><ul><li>程序语言中添加的某种语法，这种语法对编译结果和功能并没有实际影响，但却能更方便程序员使用该语言。</li><li>解语法糖：编译阶段还原回基础语法结构</li><li>优点：减少代码量，增加程序可读性，减少代码出错的机会</li></ul><p><strong>3. 字节码生成</strong></p><ul><li>Javac编译过程的最后一个阶段，把前面各个步骤生成的信息(语法树、符号表)转化为字节码指令写入到磁盘中，还进行了少量代码添加和转换工作</li><li>完成对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交由<code>ClassWriter::writeClass()</code>方法输出字节码，生成最终的Class文件。至此编译过程宣告结束。</li></ul><h2 id="10-3-Java语法糖的味道"><a href="#10-3-Java语法糖的味道" class="headerlink" title="10.3 Java语法糖的味道"></a>10.3 Java语法糖的味道</h2><p>除了以下介绍的几种语法糖，还有内部类、枚举类、断言、数值字面量、对枚举和字符串的switch支持、try with、Lambda(非单纯的语法糖)等等</p><h3 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h3><ul><li>泛型的本质是参数化类型或者参数化多态</li><li>Java的泛型实现方式是”类型擦除式泛型” Type Erasure Generics，C#则是”具现化式泛型” Reified Generics</li><li>类型擦除的缺陷：<ul><li>无法支持原始数据类型</li><li>运行期无法取到泛型类型信息</li><li>丧失了面向对象思想应有的优雅，带来了一些模棱两可的状况</li></ul></li><li>未来 - Valhalla项目：<ul><li>新的泛型实现方案</li><li>值类型 Value Type：与引用类型一样具有构造函数、方法、字段等，区别在于赋值时通常是整体复制，而不是传递引用；可以分配在调用栈上，随方法退出而自动释放</li></ul></li></ul><h3 id="10-3-2-自动装箱、拆箱、遍历循环"><a href="#10-3-2-自动装箱、拆箱、遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱、遍历循环"></a>10.3.2 自动装箱、拆箱、遍历循环</h3><ul><li>自动装箱：Integer.valueOf()</li><li>自动拆箱：Integer.intValue()</li><li>遍历循环：Iterable::iterator()</li><li>变长参数：args[]</li></ul><h3 id="10-3-3-条件编译"><a href="#10-3-3-条件编译" class="headerlink" title="10.3.3 条件编译"></a>10.3.3 条件编译</h3><ul><li>Java的条件编译会根据布尔常量值的真假，消除分支中不成立的代码块</li><li>利用了if语句，因此只能实现语句基本块级别的条件编译</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>        System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        System.out.println(<span class="hljs-string">&quot;block 2&quot;</span>);<br>&#125;<br>----------------------------------<br><span class="hljs-comment">// 反编译后：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-4-实战：插入式注解处理器"><a href="#10-4-实战：插入式注解处理器" class="headerlink" title="10.4 实战：插入式注解处理器"></a>10.4 实战：插入式注解处理器</h2><ul><li>注解处理器需要继承<code>javax.annotation.processing.AbstractProcessor,</code>且实现<code>process()</code></li><li><code>@SupportedAnnotationTypes</code>代表注解处理器对哪些注解感兴趣</li><li><code>@SupportedSourceVersion</code>指出可以处理哪些版本的Java代码</li><li>每一个注解处理器在运行时都是单例的</li></ul><h1 id="第十一章-后端编译与优化"><a href="#第十一章-后端编译与优化" class="headerlink" title="第十一章 - 后端编译与优化"></a>第十一章 - 后端编译与优化</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><ul><li>编译器无论在何时、在何种状态下把Class文件转换成本地基础设施(硬件指令集、操作系统)相关的二进制机器码，都可以视为整个编译过程的后端</li><li>后端编译器性能的好坏、代码优化质量的高低是衡量一款商用虚拟机优秀与否的关键指标之一，也是商业JVM的核心，最能体现技术水平与价值</li></ul><h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>Java最初都是通过解释器进行解释执行的，当JVM发现某个方法或代码块运行频繁，就会把它们判定为热点代码，编译成本地机器码，并通过各种手段进行优化，提高热点代码执行效率。完成这一任务的后端编译器称即时编译器 JIT</p><h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><ul><li>主流商用JVM都同时包含解释器和编译器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92.png" class="" title="alt 解释器与编译器的交互"></li><li>解释器<ul><li>启动迅速，节约内存</li><li>可以作为编译器激进优化的后备逃生门</li></ul></li><li>编译器<ul><li>执行效率高</li><li>HotSpot中包括客户端编译器C1，服务端编译器C2，以及Graal编译器</li><li>工作模式：-Xint仅解释模式，-Xcomp优先编译，以及默认的混合模式<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F.png" class="" title="alt JVM执行模式"></li><li>分层编译：根据编译器编译、优化的规模与耗时，划分不同的编译层次，包括：<ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控模式</li><li>第1层：使用C1编译字节码，进行简单可靠的稳定优化，不开启性能监控</li><li>第2层：C1编译，仅开启方法及回边次数统计等有限的性能监控</li><li>第3层：C1编译，开启全部性能监控，收集更多统计信息</li><li>第4层：C2编译，启用更多耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li></ul></li><li>实施分层编译后，解释器、C1、C2同时工作，热点代码可能被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量</li></ul></li></ul><h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><ul><li>编译的对象——热点代码分两类：<ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul></li><li>编译的目标对象都是整个方法体，而非单独的循环体。对于循环体，编译时自动进行”栈上替换”</li><li>热点探测的两种方式：<ul><li>基于采样：<ul><li>周期性检查各个线程的调用栈顶，如果某些方法经常出现在栈顶，即是热点方法。</li><li>实现简单高效，容易获取对象调用关系</li><li>不精确，容易受线程阻塞或其它外界因素的影响</li></ul></li><li>基于计数器：<ul><li>为每个方法、代码块设置计数器，统计方法的执行次数，超过阈值即热点方法</li><li>精确严谨</li><li>实现复杂，需要为每个方法建立并维护计数器，且不能直接获取方法调用关系</li></ul></li></ul></li><li>HotSpot采用第二种计数器方式，为每个方法设置<code>方法调用计数器</code>和<code>回边计数器</code><ul><li><p>方法调用计数器：统计方法一段时间内执行的相对频率。</p><ul><li>超过时间限度会进行热度衰减，计数器减半</li><li>这段时间称半衰周期<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" class="" title="alt 方法调用计数器触发即时编译器"></li></ul></li><li><p>回边计数器：统计方法中循环体代码执行的次数</p><ul><li>统计的是绝对次数，没有热度衰减</li><li>回边计数器溢出时，会同步设置方法调用计数器为溢出状态<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" class="" title="alt 回边计数器触发即时编译器"></li></ul></li></ul></li></ul><h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><ul><li><p>默认条件下，无论时方法调用产生的标准编译请求，还是栈上替换编译请求，JVM在编译器未完成编译前，都仍将解释执行代码，编译动作在后台编译线程中进行</p></li><li><p>客户端编译器：简单快速的三段式编译器，主要是局部优化</p><ul><li>阶段1：一个平台独立的前端将字节码构造成一个高级中间代码表示HIR</li><li>阶段2：一个平台相关的后端从HIR中产生低级中间代码表示LIR</li><li>阶段3：在平台相关的后端使用线性扫描算法在LIR上分配寄存器，做窥孔优化，产生机器代码<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E8%AF%91%E6%9E%B6%E6%9E%84.png" class="" title="alt 客户端编译架构"></li></ul></li><li><p>服务端编译器：</p><ul><li>专门面向服务端的典型应用场景，针对性调整服务端的性能配置，能够容忍高优化复杂度</li><li>执行大部分经典的优化动作</li><li>根据解释器、C1提供的性能监控信息，进行一些不稳定的激进优化</li></ul></li></ul><h3 id="11-2-4-实战：查看及分析即时编译结果"><a href="#11-2-4-实战：查看及分析即时编译结果" class="headerlink" title="11.2.4 实战：查看及分析即时编译结果"></a>11.2.4 实战：查看及分析即时编译结果</h3><p>需要fastdebug&#x2F;slowdebug优化级别的HotSpot虚拟机……</p><h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><h3 id="11-3-1-提前编译的优劣得失"><a href="#11-3-1-提前编译的优劣得失" class="headerlink" title="11.3.1 提前编译的优劣得失"></a>11.3.1 提前编译的优劣得失</h3><ul><li>两条分支：<ul><li>与传统C、C++编译器类似，在程序运行之前把源码编译成机器码的静态翻译<ul><li>直击即时编译的最大弱点——占用程序运行时间和运算资源</li></ul></li><li>把原本即时编译器在运行时要做的编译工作提前做好保存，下次运行直接把它加载进来使用<ul><li>本质是做编译器缓存加速，改善Java程序启动时间，以及需要一段时间预热才能到达最高性能的问题，称为动态提前编译或即时编译缓存</li></ul></li></ul></li><li>然而，即时编译器相对于提前编译器有三条天然的优势：<ul><li>性能分析制导优化：实现一些只能在动态运行时才能显现的执行偏好</li><li>激进预测性优化：依赖性能监控信息可以做出不可靠的激进优化，由低级编译器和解释器负责保底</li><li>链接时优化：Java动态链接的本质使得代码优化没有边界隔阂</li></ul></li></ul><h3 id="11-3-2-实战：Jaotc的提前编译"><a href="#11-3-2-实战：Jaotc的提前编译" class="headerlink" title="11.3.2 实战：Jaotc的提前编译"></a>11.3.2 实战：Jaotc的提前编译</h3><p>Jaotc属于提前编译的第二条分支——编译器缓存加速，支持对Class文件和模块进行提前编译，以减少程序启动时间和到达全速性能的预热时间。但是必须针对特定物理机和目标虚拟机的运行参数。<br>JDK 17中移除了Jaotc</p><h2 id="11-4-编译优化技术"><a href="#11-4-编译优化技术" class="headerlink" title="11.4 编译优化技术"></a>11.4 编译优化技术</h2><h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p>分类：</p><ul><li>编译器策略</li><li>基于性能监控的优化技术</li><li>基于证据的优化技术</li><li>数据流敏感重写</li><li>语言相关的的优化技术</li><li>内存及代码位置变换</li><li>循环交换</li><li>全局代码调整</li><li>控制流图变换</li></ul><h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联:"></a>11.4.2 方法内联:</h3><ul><li>编译器最重要的优化手段，称为优化之母</li><li>目的：<ul><li>去除方法调用的成本</li><li><strong>为其它优化建立良好的基础</strong></li></ul></li><li>措施：把目标方法的代码原封不动复制到发起调用的方法之中</li><li>解决Java实例方法默认是虚方法的解决方案：<ul><li>类型继承关系分析CHA，确定方法类型</li><li>非虚方法 - 直接内联</li><li>虚方法 - 向CHA查询是否只有一个版本<ul><li>是 - 守护内联 (Java动态链接-&gt;激进优化，需预备好逃生门 -&gt; 解释执行&#x2F;重新编译)</li><li>否 - 内联缓存 (仍是方法调用，但快于查虚方法表。后续命中-&gt;单态内联缓存，未命中-&gt;超多态内联缓存)</li></ul></li></ul></li></ul><h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><ul><li>前沿优化技术。不是直接优化代码，而是为其它优化措施提供依据</li><li>基本原理：<ul><li>分析对象动态作用域，当一个对象在方法里面被定义后，它可能传递到外部方法中使用，称为方法逃逸；</li><li>还有可能被外部线程访问，称线程逃逸</li><li>对象由低到高的逃逸程度：从不逃逸-&gt;方法逃逸-&gt;线程逃逸</li></ul></li><li>措施：<ul><li>栈上分配：<ul><li>如果一定对象不会发生线程逃逸，那么可以让这个对象在栈上分配，所占空间随栈帧出栈而销毁，减小GC压力</li><li>支持方法逃逸，不支持线程逃逸</li></ul></li><li>标量替换：<ul><li>标量：无法再分解成更小数据的表示，如原始数值类型、reference类型等</li><li>聚合量：数据可以继续分解</li><li>把一个Java对象拆散，根据程序访问情况，将其用到的成员变量恢复为原始类型来访问，这个过程称标量替换</li><li>不允许对象逃逸出方法之外</li></ul></li><li>同步消除：<ul><li>对不发生线程逃逸的对象，读写不会有竞争，可以安全消除线程同步措施</li></ul></li></ul></li></ul><h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><ul><li>经典的、普遍应用于各种编译器的优化技术</li><li>措施：<ul><li>如果一个表达式E之前被计算过，且中间E的所有变量没有变化，可以直接用之前计算过的结果替代E</li><li>限于程序基本块内的，称局部公共子表达式消除</li><li>涵盖多个基本块的，称全局公共子表达式消除</li></ul></li></ul><h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><ul><li>即时编译器中一项语言相关的经典优化技术</li><li>措施：确定数组长度，访问时直接对下标进行越界判断</li></ul><h2 id="11-5-实战：深入理解Graal编译器"><a href="#11-5-实战：深入理解Graal编译器" class="headerlink" title="11.5 实战：深入理解Graal编译器"></a>11.5 实战：深入理解Graal编译器</h2><ul><li>Graal使用Java编写</li><li>利用JVM CI实现与HotSpot分离。JVM CI的功能：<ul><li>响应HotSpot的编译请求，并将请求分发给Java实现的即时编译器</li><li>允许编译器访问HotSpot中与即时编译相关的数据结构，并提供一组这些数据结构在Java语言层面的抽象表示</li><li>提供HotSpot代码缓存的Java端抽象表示，允许编译器部署编译完成的二进制机器码</li></ul></li></ul><h1 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章 - Java内存模型与线程"></a>第12章 - Java内存模型与线程</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><ul><li>Amadahl定律：通过系统中并行化和串行化的比重来描述多处理器系统能获得的运算加速能力。代理摩尔定律成为计算机性能发展源动力的根本原因。</li><li>并发应用场景：<ul><li>计算机的运算速度与它的存储和通信子系统的速度差距过大，需要充分利用计算机处理器的能力</li><li>一个服务端需要同时对多个客户端提供服务</li></ul></li></ul><h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><ul><li>高速缓存: 内存与处理器之间的缓冲，复制同步策略</li><li>产生新的问题：共享内存多核系统的缓存一致性问题</li><li>乱序执行：尽量充分利用处理器内部的运算单元，且保证结果一致</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" class="" title="alt 计算机内存交互关系"><center>计算机内存交互关系</center><h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><ul><li>模型必须足够严谨，让Java的并发内存访问操作不会产生歧义</li><li>模型必须足够宽松，使得虚拟机的实现能充分利用硬件的各种特性，如寄存器、高速缓存、特殊指令等，来获取更快的执行速度</li></ul><h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><ul><li>Java内存模型规定所有变量都存储在主内存中</li><li>每条线程有自己的工作内存，保存该线程使用的变量的主内存副本</li><li>线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的数据。</li><li>不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.png" class="" title="alt Java内存交互模型"><center>Java内存交互模型</center><h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><ul><li>JVM必须保证以下操作是原子的、不可再分的：<ul><li>lock, unlock, read, load, use, assign, store, write</li></ul></li><li>上述8种基本操作必须满足一定规则<ul><li>略</li></ul></li></ul><h3 id="12-3-3-volatile型变量的特殊规则"><a href="#12-3-3-volatile型变量的特殊规则" class="headerlink" title="12.3.3 volatile型变量的特殊规则"></a>12.3.3 volatile型变量的特殊规则</h3><p>当一个变量被定义成volatile之后，将具备两项特性：</p><ol><li><p>保证此变量对所有线程的可见性(变量值修改后对其它线程立即可知)</p><ul><li>但并不完全保证线程安全</li><li>不符合以下两条规则的场景，仍需通过加锁保证原子性：<ul><li>运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量值</li><li>变量不需要与其它的状态变量共同参与不变约束</li></ul></li></ul></li><li><p>禁止指令重排序优化</p><ul><li>普通变量只能保证执行结果正确，不能保证变量赋值操作的顺序和程序代码中的执行顺序一致。即 <code>线程内表现为串行的语义 Within-Thread As-If-Serial Semantics</code></li></ul></li></ol><p>Java中对volatile变量特殊规定的定义：</p><ul><li>每次使用变量前必须先从主内存刷新最新值，保证能看见其它线程对变量所做的修改</li><li>每次修改变量必须立刻同步回主内存中，保证其它线程看到自己对变量的修改</li><li>volatile修饰变量不会被指令重排序优化，保证代码执行顺序与程序顺序相同</li></ul><h3 id="12-3-4-long、double型变量的特殊规则"><a href="#12-3-4-long、double型变量的特殊规则" class="headerlink" title="12.3.4 long、double型变量的特殊规则"></a>12.3.4 long、double型变量的特殊规则</h3><ul><li>对于没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。即<code>long和double的非原子性协定</code></li><li>但主流64位JVM并不会出现非原子性访问行为</li></ul><h3 id="12-3-5-原子性、可见性、有序性"><a href="#12-3-5-原子性、可见性、有序性" class="headerlink" title="12.3.5 原子性、可见性、有序性"></a>12.3.5 原子性、可见性、有序性</h3><ol><li><p>原子性 Atomicity</p><ul><li>由Java内存模型直接保证的原子性变量操作：read, load, assign, use, store, write</li><li>需要更大范围的原子性保证则可以用lock和unlock操作，反映到字节码层次就是monitorenter和monitorexit指令，而在Java代码中就是同步块synchronized关键字</li></ul></li><li><p>可见性 Visibility</p><ul><li>指当一个线程修改了共享变量的值后，其它线程能够立即得知这个参数</li><li>volatile变量可以保证多线程操作时变量的可见性，普通变量不行</li><li>除volatile外，synchronized、final关键字也可以实现可见性</li></ul></li><li><p>有序性 Ordering</p><ul><li>Java程序中，如果在本线程内观察，所有操作都是有序的；<code>线程内表现为串行的语义</code></li><li>如果在一个线程中观察另一个线程，所有的操作都是无序的。<code>指令重排序</code>和<code>工作内存与主内存同步延迟</code></li><li>volatile和synchronized保证线程之间操作的有序性</li></ul></li></ol><p>synchronized可以实现这三种特性，但也伴随着更大的性能影响</p><h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><ul><li>先行发生是Java内存模型中定义的两项操作之间的偏序关系</li><li>作用：判断数据是否存在竞争，数据是否安全</li><li>Java有且仅有以下这些天然的，无需任何同步器协助就存在的先行发生关系：<ul><li>程序次序规则</li><li>管程锁定规则</li><li>volatile变量规则</li><li>线程启动规则</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li><li>传递性</li></ul></li><li>如果两个操作的关系不满足上述规则，也无法从这些规则推导出来，则它们没有顺序性保障，虚拟机可以对它们随意进行重排序</li><li>时间先后顺序与先行发生原则基本没有因果关系，衡量并发安全问题以先行发生原则为准</li></ul><h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><h3 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h3><ul><li>线程是比进程更轻量化的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度</li><li>目前，线程是Java进行处理器资源调度的最基本单位</li><li>Java提供了不同硬件和OS平台下对线程操作的统一处理。<code>java.lang.Thread</code>类的实例就代表一个线程，它的关键方法都被声明为Native，即依赖于具体平台的实现</li><li>实现线程主要由三种方式 (不局限于Java)：内核线程、用户线程、混合线程</li></ul><h4 id="1-使用内核线程-1-1"><a href="#1-使用内核线程-1-1" class="headerlink" title="1. 使用内核线程 1:1"></a>1. 使用内核线程 1:1</h4><ul><li>内核线程KLT是直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上</li><li>每个内核线程可以视为内核的一个分身，这样OS就能同时处理多件任务，称之为多线程内核</li><li>程序一般使用内核线程的一种高级接口——轻量级进程LWP，即线程。即每个轻量级进程都成为一个独立的调度单元，与内核线程是一对一的关系</li><li>局限性：<ul><li>由于是基于内核线程实现的，因此各种线程操作，如创建、析构、同步，都需要进行系统调用。系统调用需要在用户态和内核态之间切换，代价较高</li><li>每个LWP需要消耗一定的内核资源，因此一个系统支持LWP的数量有限</li></ul></li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" class="" title="alt 内核线程实现"><h4 id="2-使用用户线程-1-N"><a href="#2-使用用户线程-1-N" class="headerlink" title="2. 使用用户线程 1:N"></a>2. 使用用户线程 1:N</h4><ul><li>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及实现</li><li>用户线程的建立、同步、销毁、调度完全在用户态中完成，不需要内核帮助。因此速度快开销低，且支持大规模的线程数量</li><li>进程和用户线程之间是一对多的关系</li><li>缺点：没有内核支援，所有操作都需要用户程序自己去处理，实现复杂</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" class="" title="alt 用户线程实现"><h4 id="3-使用用户线程-轻量级进程混合实现-N-M"><a href="#3-使用用户线程-轻量级进程混合实现-N-M" class="headerlink" title="3. 使用用户线程+轻量级进程混合实现 N:M"></a>3. 使用用户线程+轻量级进程混合实现 N:M</h4><ul><li>既存在用户线程，也存在轻量级进程</li><li>用户线程建立在用户空间，开销低，支持大规模的用户线程并发</li><li>OS支持的LWP作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度及处理器映射，并且用户线程的系统调用要通过LWP完成，大大降低进程被阻塞的风险</li><li>用户线程和LWP是多对多的关系</li></ul><h4 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4. Java线程的实现"></a>4. Java线程的实现</h4><ul><li>早期JDK 1.2以前的Classic虚拟机使用的是名为”绿色线程”的用户线程实现</li><li>目前，主流JVM普遍都是基于OS原生线程模型实现的，即1:1的内核线程模型</li></ul><h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><ul><li>线程调度：系统为线程分配处理器使用权的过程</li><li>调度方式：<ul><li>协同式<ul><li>线程的执行时间由线程本身控制，线程工作执行完后，需要主动通知系统切换线程</li><li>实现简单，但线程执行时间不可控</li></ul></li><li>抢占式 (Java的实现方法)<ul><li>由系统为每个线程分配执行时间</li><li>执行时间由系统控制，不会由一个线程导致进程或系统阻塞</li><li>可以通过线程优先级、优先级推进器等功能调节系统分配的执行时间，但不稳定</li></ul></li></ul></li></ul><h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><ul><li>线程的6种状态：<ul><li>新建 New</li><li>运行 Runnable</li><li>无限期等待 Waiting</li><li>限期等待 Timed Waiting</li><li>阻塞 Blocked</li><li>结束 Terminated</li></ul></li><li>阻塞状态时等待另一个线程释放某个排它锁，而等待是等一段时间，或等某个唤醒的动作</li></ul><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" class="" title="alt 线程状态转换关系"><h2 id="12-5-Java与协程"><a href="#12-5-Java与协程" class="headerlink" title="12.5 Java与协程"></a>12.5 Java与协程</h2><h3 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h3><ul><li>现代B&#x2F;S系统中一次对外部业务的请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也增加了服务的数量，缩短了留给每个服务的响应时间。例如<strong>微服务架构</strong></li><li>Java的内核线程模式存在切换、调度成本高昂，系统能容纳的线程数量有限等缺陷</li></ul><h3 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h3><ul><li>用户态和核心态的切换开销主要来源于响应中断、保护和恢复执行现场的成本。涉及一系列数据在各种寄存器、缓存中的来回拷贝</li><li>DOS操作系统曾出现过<code>栈纠缠Stack Twine</code>这种由用户模拟多线程的工作模式</li><li>最初的用户线程被设计为协同式调度，也称<code>协程</code>。分为有栈协程和无栈协程</li><li>协程的主要优势是轻量，同时存活数量以十万计</li><li>协程的局限性在于需要应用层实现的内容特别多，如调用栈、调度器</li></ul><h3 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h3><ul><li><code>纤程 Fiber</code>：典型的有栈协程，使用用户线程，并完整实现调用栈的保护、恢复工作</li><li>新并发模式下，使用纤程并发的代码分为执行过程和调度器</li><li>其实也可以不依赖虚拟机实现协程，如Kotlin的协程、Quasar协程库</li></ul><h1 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章- 线程安全与锁优化"></a>第13章- 线程安全与锁优化</h1><h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>“线程安全”的定义 (来自Brian Goetz -《Java Concurrency In Practice》)：<br>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，就称这个对象是线程安全的</p><h3 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h3><p>按线程安全由强至弱，将各种操作共享的数据分为以下五类：</p><ul><li><p><strong>1. 不可变</strong></p><ul><li>Immutable的对象一定是线程安全的，不需要任何保障措施</li><li>对于基本类型只要在定义时使用final修饰，就是不可变的</li><li>对于类对象，需要对象自行保证其行为不会对其状态产生任何影响</li><li>典型的不可变类型包括String, Long、 Double等数值包装类型, BigInteger、BigDecimal等大数据类型</li></ul></li><li><p><strong>2. 绝对线程安全</strong></p><ul><li>满足上述线程安全的定义，不管运行环境如何，都不需要任何额外的同步措施</li></ul></li><li><p><strong>3. 相对线程安全</strong></p><ul><li>即通常意义上的线程安全，需要保证对该对象的单次操作是线程安全的。但对于一些特定顺序的连续调用，需要额外的同步</li><li>Java中大部分声称线程安全的类都是相对线程安全</li></ul></li><li><p><strong>4. 线程兼容</strong></p><ul><li>指对象本身不是线程安全，但可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全使用</li></ul></li><li><p><strong>5. 线程对立</strong></p><ul><li>指不管调用端是否采取同步，都无法在多线程环境中并发使用代码</li><li>由于Java天生支持多线程，线程对立的代码很少出现，且通常是有害的，应尽量避免</li><li>如Thread::suspend(), Thread::resume()等</li></ul></li></ul><h3 id="13-2-2-线程安全的实现方式"><a href="#13-2-2-线程安全的实现方式" class="headerlink" title="13.2.2 线程安全的实现方式"></a>13.2.2 线程安全的实现方式</h3><p><strong>1. 互斥同步</strong></p><ul><li>最常见也最主要的并发正确性保障手段</li><li>同步指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</li><li>互斥是实现互斥的一种手段，例如临界区、互斥量、信号量</li><li>即互斥是因，同步是果；互斥是方法，同步是目的</li></ul><ul><li>synchronized是最基本的，重量级的块结构同步互斥手段<ul><li>编译后在同步块前后生成<code>monitorenter</code>和<code>monitorexit</code>字节码指令</li><li>通过对一个reference类型的参数指定锁定和解锁的对象</li><li>推论：<ul><li>synchronized同步块对同一条线程来说是可重入的。即同一线程不会死锁</li><li>synchronized同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。即无法强制退出</li></ul></li></ul></li><li>Lock接口，以非块结构实现互斥同步。典型实现如ReentrantLock, ReentrantReadWriteLock<ul><li>高级功能：等待可中断、公平锁、锁绑定多个条件</li><li>相同情况下，synchronized更加合适的原因：<ul><li>sychronized是语法层面的同步，足够清晰，也足够简单</li><li>Lock要确保在finally块中释放锁，否则可能永远不释放</li><li>JVM更容易针对synchronized进行优化</li></ul></li></ul></li></ul><p><strong>2. 非阻塞同步</strong></p><ul><li>互斥同步的主要问题在于进行线程阻塞和唤醒所带来的性能开销</li><li>非阻塞同步是一种基于冲突检测的乐观并发策略，即不管有没有风险，先进行操作，发生冲突再进行补偿措施</li><li>比较并交换 <code>CAS指令</code>：<ul><li>原子操作，不会被其它线程中断</li><li>三个操作数，内存位置V，旧的预期值A，准备设置的新值B</li><li>当且仅当V符合A时，处理器才会用B更新V的值，否则就不更新。无论是否更新，都返回旧值</li><li>逻辑漏洞 - ABA问题：原值A，被其他线程修改为B，后来又被修改回A，CAS无法判断是否未被修改过。可以通过控制变量值的版本来保证CAS正确性</li></ul></li></ul><p><strong>3. 无同步方案</strong></p><ul><li>如果程序不涉及共享数据，自然也就不需要任何同步措施保证正确性</li><li>可重入代码：<ul><li>又称纯代码，可以在任何时刻中断，去执行其它代码，不会影响执行结果</li><li>相对线程安全来说，可重入性是更为基础的特性，可以保证代码线程安全</li><li>即所有可重入代码都是线程安全的，但并非所有线程安全的代码都是可重入的</li></ul></li><li>线程本地存储：<ul><li>程序中的共享数据的代码能否保证再同一线程内执行，如果能也不需要进行同步</li><li>典型用例如消费队列的架构模式、经典Web交互模型中的”一个请求对应一个服务器线程”</li></ul></li></ul><h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>目的：为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率</p><h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><ul><li>若一个物理机有一个以上的处理器&#x2F;核心，能让多线程并行执行，就可以让后面请求锁地线程稍等，但不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。</li><li>自旋锁：为了让线程等待，只需让线程执行一个忙循环，即自旋</li><li>JDK 6加入自适应自旋，自选的时间不再固定。根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自旋获得锁的成功次数越多，自旋容许时间就越长</li></ul><h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><ul><li>指JVM即时编译器运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除</li><li>主要依据来源于逃逸分析的数据支持，如果一段代码的所有数据都不会逃逸出去被其他线程访问，就可以当作栈上数据，无需同步加锁</li></ul><h3 id="13-3-3-锁相关"><a href="#13-3-3-锁相关" class="headerlink" title="13.3.3 锁相关"></a>13.3.3 锁相关</h3><ul><li>一般编写代码要求同步块范围尽可能小</li><li>但如果JVM检测到一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围扩展（粗化）到整个操作序列的外部</li></ul><h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><ul><li>目的是在没有多线程竞争的前提下，减少传统的重量级锁使用OS互斥量产生的性能消耗</li><li>对象头Mark Word的32位比特空间里，有2位用于存储锁标志位，标记未被锁定、轻量级锁、重量级锁、GC标记、可偏向等状态</li><li>使用CAS加锁解锁</li><li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁</li><li>轻量级锁能提升程序同步性能的依据是：”<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>“这一经验法则</li><li>如果确实存在锁的竞争，轻量级锁反而比传统的重量级锁更慢<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%87%E5%BF%97%E4%BD%8D.png" class="" title="alt 对象头标志位"></li></ul><h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><ul><li>目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能</li><li>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其它线程获取，则持有偏向锁的线程将永远不需要再进行同步</li><li>一旦另一个线程尝试获取这个锁，偏向模式立刻宣告结束</li><li>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象处于偏向锁状态，又收到需要计算一致性哈希码请求时，偏向状态立刻撤销，并且锁会膨胀为重量级锁(可以通过<code>ObjectMonitor</code>拿到哈希码)</li><li>偏向锁可以提高带有同步但无竞争的程序性能，但同样带有效益权衡。如果程序中大多数锁都总是被多个不同的线程访问，那偏向模式就是多余的</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-位运算</title>
    <link href="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode 136. 只出现一次的数字"></a>LeetCode 136. 只出现一次的数字</h1><p>链接：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode136.png" class="" title="alt LeetCode136"><p>找出数组中唯一成单的数字，主要学习异或运算的性质和哈希表的使用。</p><h2 id="解法1-异或运算"><a href="#解法1-异或运算" class="headerlink" title="解法1. 异或运算"></a>解法1. 异或运算</h2><p>异或运算的三个性质</p><ul><li>任何数和0做异或，结果仍是原来的数<br>  $ a \bigoplus 0 &#x3D; a $</li><li>任何数和自身做异或结果是0<br>  $ a \bigoplus a &#x3D; 0 $</li><li>异或运算满足交换律和结合律<br>  $ a \bigoplus b \bigoplus a &#x3D; b \bigoplus a \bigoplus a &#x3D; b $<br>因此数组中所有元素异或即可得到单个的元素。时间复杂度$O(n)$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            ans ^= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="解法2-哈希表"><a href="#解法2-哈希表" class="headerlink" title="解法2. 哈希表"></a>解法2. 哈希表</h2><p>使用哈希表存储每个数字和该数字出现的次数。最后次数为1的就是单个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.get(i);<br>            map.put(i, count == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ++count;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Integer i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(i) == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$,空间复杂度$O(n)$</p><hr><h1 id="LeetCode-191-位1的个数"><a href="#LeetCode-191-位1的个数" class="headerlink" title="LeetCode 191. 位1的个数"></a>LeetCode 191. 位1的个数</h1><p>链接：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode191.png" class="" title="alt LeetCode191"><h2 id="方法1-移位"><a href="#方法1-移位" class="headerlink" title="方法1 - 移位"></a>方法1 - 移位</h2><p>循环检查二进制的每一位是否为1，例如让n和 $2^i$ 进行与运算，或者让n和1相与并右移n，得到二进制末尾是否为1<br>时间复杂度$O(k)$, 其中$k$是二进制位数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            count += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注，Java中：</p><ul><li><code>&lt;&lt;</code> 左移，高位舍弃，低位补0</li><li><code>&gt;&gt;</code> 右移，舍弃最低位，高位用符号位填补，正数补0，负数补1</li><li><code>&gt;&gt;&gt;</code> 无符号右移，舍弃最低位，高位用0填补</li></ul><h2 id="方法二-Brian-Kernighan算法"><a href="#方法二-Brian-Kernighan算法" class="headerlink" title="方法二 - Brian Kernighan算法"></a>方法二 - Brian Kernighan算法</h2><p>利用 $n \And (n-1)$ 能够把二进制中的最低位1变为0的特性，反复操作，直至n&#x3D;0</p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/n&n-1.png" class="" title="alt n&amp;n-1"><p>可以看到，n-1会把n末尾的0变1，直到遇到最低位的1把它变0，其余保持不变。相与时，n末尾的0与运算后仍是0，而最低位1和0相与得0，其余位不变。因此，$n \And (n-1)$把n的最低位1变成了0，其余位不变。</p><p>时间复杂度$O(logn)$, 循环次数就是n的二进制中1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法3-分治"><a href="#方法3-分治" class="headerlink" title="方法3 - 分治"></a>方法3 - 分治</h2><p>0x55555555 &#x3D; 0B0101…0101<br>0x33333333 &#x3D; 0B0011…0011<br>0x0f0f0f0f &#x3D; 0B00001111…00001111</p><p>贴上Java中的<code>Integer::bitCount()</code>源码，太神奇了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bitCount</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        i = i - ((i &gt;&gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);                   <span class="hljs-comment">// 此时i每两位的值是原数字每两位1的个数</span><br>        i = (i &amp; <span class="hljs-number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);    <span class="hljs-comment">// 此时i每4位的值是原数字每4位1的个数 </span><br>        i = (i + (i &gt;&gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0f0f0f0f</span>;                   <span class="hljs-comment">// 此时i每8位的值是原数字每8位1的个数</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">8</span>);                                  <span class="hljs-comment">// 每两个8位合并统计</span><br>        i = i + (i &gt;&gt;&gt; <span class="hljs-number">16</span>);                                 <span class="hljs-comment">// 两个16位合并统计</span><br>        <span class="hljs-keyword">return</span> i &amp; <span class="hljs-number">0x3f</span>;                                    <span class="hljs-comment">// 取出低6位，因为32bit最高只有32个1</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>注意第二行，前半句保留奇数组的”两位”，后半句保留偶数组的”两位”，然后相加使得相邻的两个”两位”合并统计，即得到每4位1的个数<br>分开&amp;的原因在于2bit最多表示3个1，不足以表示原数字每4位1的个数，因此要多做一次&amp;然后相加<br>而在第三行，4bit(0-15)可以表示8位二进制1的个数，因此只需要&amp;一次</p><hr><h1 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode 461. 汉明距离"></a>LeetCode 461. 汉明距离</h1><p>链接：<a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p><img src="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/LeetCode461.png" class="" title="alt LeetCode461"><p>先把两数字异或，然后同LeetCode191，统计1的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x ^ y, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (s != <span class="hljs-number">0</span>) &#123;<br>            s &amp;= s - <span class="hljs-number">1</span>;<br>            ret++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 总结</title>
    <link href="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-复习"><a href="#Java-SE-复习" class="headerlink" title="Java SE 复习"></a>Java SE 复习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li>引用数据类型</li><li>基本数据类型 4大类8种 <em>(1-2-4-8)</em><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.svg" class="" title="alt Java基本数据类型"></li></ol><ul><li><p>自动类型转换：类型范围小的变量，可以直接赋值给类型范围大的变量</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 自动类型转换"><p><strong><code>byte --&gt; short (char) --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></p></li><li><p>在表达式中，小范围类型的变量会自动转换成较大范围的类型再运算</p><ul><li><strong><code>byte, short, char --&gt; int --&gt; long --&gt; float --&gt; double</code></strong></li><li>最终结果类型由表达式中的最高类型决定</li><li>在表达式中，byte、short、char 直接转换成int类型参与运算的</li></ul></li><li><p>强制类型转换：可以强行将类型范围大的变量、数据赋值给类型范围小的变量</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.svg" class="" title="alt 强制类型转换"><ul><li>强制类型转换可能造成数据(丢失)溢出</li><li>浮点型强转成整型，直接丢掉小数部分，保留整数部分返回</li></ul></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>短路逻辑运算符<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.svg" class="" title="alt 短路逻辑运算符"></li><li>逻辑与<code>&amp;</code>, 逻辑或<code>|</code>: 无论左边是false还是true，右边都要执行</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>代码块<code>&#123;&#125;</code>是类的5大成分之一(成员变量、构造器、方法、代码块、内部类)</li><li>静态代码块<ul><li><code>static&#123; &#125;</code></li><li>通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次</li><li>使用场景：在类加载的时候做一些静态数据初始化的操作，以便后续使用</li></ul></li><li>构造代码块(很少使用)<ul><li><code>&#123; &#125;</code></li><li>每次创建对象调用构造器前，都会执行该代码块</li><li>使用场景：初始化实例资源</li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>饿汉单例：</p><ul><li>在用类获取对象时，对象已经提前为你创建好了</li><li>设计步骤：定义类，构造器私有，定义静态变量存储单例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 属于类，与类一起仅加载一次</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;创建了一个对象&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉单例：</p><ul><li>在真正需要该对象时，才去创建一个对象(延迟加载对象)</li><li>设计步骤：定义类，构造器私有，定义静态变量存储对象，提供一个返回单例对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance &#123;<br>  <span class="hljs-comment">// 类加载时初始为null</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance instance;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleInstance</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleInstance</span>();<br>    <span class="hljs-keyword">return</span> instace;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>子类中访问成员满足就近原则，先找子类，子类没有找父类，父类没有报错</li><li>子类可以直接使用父类的静态成员(共享)</li><li>方法重写<ul><li>私有方法不能被重写。但可以定义相同签名的方法。</li><li>子类重写父类方法时，访问权限必须大于或等于父类 <code>缺省 &lt; protected &lt; public</code></li><li>子类不能重写父类的静态方法</li></ul></li><li>权限修饰符<ul><li><code>private &lt; 缺省 &lt; protected &lt; public</code><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4.svg" class="" title="alt 权限修饰符作用范围"></li></ul></li><li>final 修饰符<ul><li>修饰类，表明该类不能被继承</li><li>修饰方法，表明该方法不能被重写</li><li>修饰变量，表明该变量不能被重新赋值 <ul><li>基本类型 – 数据值不能改变</li><li>引用类型 – 存储的地址值不能改变(地址指向的对象可变)</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>一种约束规范</li><li>接口中的变量默认都是 <code>public static final</code></li><li>接口中的方法默认都是 <code>public abstract</code></li><li>JDK 8&#x2F;9 新增特性：<ul><li><ol><li>默认方法 - default修饰，自动public，需用接口实现类的对象来调用</li></ol></li><li><ol start="2"><li>静态方法 - static修饰，自动public，需用接口本身的接口名调用</li></ol></li><li><ol start="3"><li>私有方法 - private修饰，只能在 接口中被其它的方法访问</li></ol></li></ul></li><li>一个类同时继承父类和实现接口中的同名方法，优先使用父类的</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>访问特点：<ul><li>方法调用：编译看左边，运行看右边</li><li>变量调用：编译看左边，运行也看左边</li></ul></li><li>强制类型转换<ul><li>可以转换成真正的子类型，从而调用子类的独有功能</li><li>强转前尽量使用<code>instanceof</code>判断对象的真实类型再进行强转</li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1. 静态内部类"></a>1. 静态内部类</h3><ul><li><code>static</code>修饰，属于外部类这个类</li><li>创建格式：<code>Outer.Inner in = new Outer.Inner()</code></li><li>可以直接访问外部类静态对象</li><li>不可以直接访问外部类实例成员</li></ul><h3 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2. 成员内部类"></a>2. 成员内部类</h3><ul><li><code>无 static</code>修饰，属于外部类的对象</li><li>创建格式：Outer.Inner in &#x3D; new Outer().new Inner();</li><li>可以直接访问外部类静态对象</li><li>可以直接访问外部类实例成员(必须先有外部类对象，才能有成员内部类对象)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">hearbeat</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>          System.out.println(hearbeat); <span class="hljs-comment">// 78</span><br>          System.out.println(<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 110</span><br>          System.out.println(People.<span class="hljs-built_in">this</span>.hearbeat); <span class="hljs-comment">// 150</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a>3. 局部内部类</h3><ul><li>放在方法、代码块、构造器等执行体中</li><li>类文件名：<code>Outer$NInner.class</code></li><li>鸡肋</li></ul><h3 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h3><ul><li>本质上是没有名字的局部内部类</li><li>既是一个类，也代表一个对象(new的类型的子类类型)，写出来就会产生一个匿名内部类的对象</li><li>可以直接作为对象传给方法</li><li>作用：方便创建子类对象，简化代码编写</li><li>创建格式：<code>new 类/抽象类名/接口( )&#123; 重写方法 &#125;</code></li></ul><ul><li>Lambda表达式：<ul><li>一个匿名函数，是一段可以传递的代码</li><li>用于简化函数式接口的匿名内部类的写法形式</li><li>函数式接口：有且仅有一个抽象方法的接口，通常加上@FunctionalInterface注解</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两种创建过程"><a href="#两种创建过程" class="headerlink" title="两种创建过程"></a>两种创建过程</h3><ol><li><p><code>&quot;&quot;</code>双引号创建字符串：会先判断常量池里面是否有相同的字符串，若有则直接指向该地址</p></li><li><p><code>new</code>关键字不论常量池中是否已经有该串，都会在堆中开辟新的内存空间存放该字符串</p></li></ol><h3 id="String-面试题"><a href="#String-面试题" class="headerlink" title="String 面试题"></a>String 面试题</h3><ul><li>问题：下列代码的运行结果是？<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E9%9D%A2%E8%AF%95%E9%A2%98.svg" class="" title="alt String面试题1"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先在堆的字符串常量池里创建&quot;abc&quot;的串，然后new再创建一个新串赋给s2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>); <br><span class="hljs-comment">// 由于是双引号，直接指向常量池里的&quot;abc&quot;，因此这条语句没有创建新字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-comment">//false, s1指向的是常量池里的&quot;abc&quot;,s2指向的是堆里的&quot;abc&quot;</span><br>System.out.println(s1 == s2) <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s7</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qwe&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;qw&quot;</span>;<br><span class="hljs-comment">// 只要不是直接双引号给出的字符串，都是非常量池的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s9</span> <span class="hljs-operator">=</span> s8 + <span class="hljs-string">&quot;e&quot;</span>;<br><span class="hljs-comment">// false, s7指向常量池的&quot;qwe&quot;,s9指向堆里的&quot;qwe&quot;</span><br>System.out.println(s7 == s9);  <br><span class="hljs-type">String</span> <span class="hljs-variable">s10</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asd&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s11</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;s&quot;</span> + <span class="hljs-string">&quot;d&quot;</span>;<br><span class="hljs-comment">// true, 编译优化机制：直接将&quot;a&quot;+&quot;s&quot;+&quot;d&quot;转换为&quot;asd&quot;，可以通过class文件确认</span><br><span class="hljs-comment">// 而s9由于s8是变量，不是字面量，因此没有优化</span><br>System.out.println(s10 == s11);<br></code></pre></td></tr></table></figure><h3 id="StringBuilder-拼接字符串"><a href="#StringBuilder-拼接字符串" class="headerlink" title="StringBuilder 拼接字符串"></a>StringBuilder 拼接字符串</h3><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/String%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt String拼接字符串"> <center>**String拼接字符串原理 - 每次拼接都会产生新的对象**</center><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/StringBuilder%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.svg" class="" title="alt StringBuilder拼接字符串"> <center>**StringBuilder拼接字符串原理 - 对同一个对象做修改**</center><ul><li>StringBuilder相当于一个容器，拼接、修改更加高效</li><li>StringBuilder只是个工具，最终的目的是得到String </li><li>StringBuffer是StringBuilder的多线程安全版，单线程下StringBuilder效率更高</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li><p><strong>List</strong>: 有序、可重复、有索引</p><ul><li><strong>ArrayList</strong>: 底层基于数组，默认长度10，存满时扩容1.5倍</li><li><strong>LinkedList</strong>: 底层基于双链表，可模拟栈&#x2F; 队列</li></ul></li><li><p><strong>Set</strong>: 无序、不重复、无索引</p><ul><li><strong>HashSet</strong>:<br>基于哈希表，底层采用<code>数组+链表+红黑树</code>实现。哈希表默认长度16，加载因子0.75，每次扩容2倍。相同哈希值的元素构成链表，新元素挂在老元素后面，当链表长度超过8自动转为红黑树。</li><li><strong>LinkedHashSet</strong>:<br>有序，底层<code>哈希表+双链表</code>记录存储顺序</li><li><strong>TreeSet</strong>:<br>自动排序，底层基于<code>红黑树</code>实现。必须指定比较规则 (比较器&#x2F;比较接口)</li></ul><p>如果希望 Set 认为两个内容一样的对象是重复的，必须重写对象的<code>hashCode()</code>和<code>equals()</code>方法</p></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.svg" class="" title="alt 集合体系"><ul><li><p>遍历方式：</p><ol><li>迭代器 <code>Iterator::hasNext, Iterator::next</code></li><li><code>for-each 循环</code> 注意集合中存储的是对象的地址，因此修改第三方变量不会影响到集合中的元素</li><li>lambda表达式 <code>forEach(Consumer&lt;? super T&gt; action)</code></li></ol><p>遍历时直接用集合删除元素可能出现并发异常，可以通过迭代器删除</p></li><li><p><strong>Collections</strong> 集合工具类</p><ul><li>addAll</li><li>sort</li><li>shuffle</li></ul></li><li><p>不可变集合 <strong>ImmutableCollections</strong>：</p><ul><li>List.of</li><li>Set.of</li><li>Map.of</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p><strong>HashMap</strong>: </p><ul><li>无序，不重复，无索引，值不作要求</li><li>基于哈希表、数组、红黑树实现</li><li>基于hashCode()和equals()保证键的唯一</li></ul></li><li><p><strong>LinkedHashMap</strong>：</p><ul><li>按键有序，不重复，无索引，值不作要求</li><li>基于哈希表、双链表记录存储顺序</li></ul></li><li><p><strong>TreeMap</strong>: </p><ul><li>自动按键排序 ，不重复，无索引，值不作要求</li><li>底层基于<code>红黑树</code>实现，必须指定键的比较规则(比较器&#x2F;比较接口)</li></ul></li><li><p><strong>Properties</strong></p><ul><li>本质是Map集合，一般代表一个属性文件，存储对象键值对，作为系统配置信息</li><li><code>store(Stream, comments), load(Stream), setProperty, getProperty</code></li></ul><p>Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据。</p></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/map%E4%BD%93%E7%B3%BB.svg" class="" title="alt map体系"><ul><li>遍历方式：<ol><li>键找值：<code>map.keySet(), map.get(key)</code></li><li>键值对：<code>map.entrySet(), entry.getKey(), entry.getValue()</code></li><li>Lambda表达式：<code>map.forEach(BiConsumer&lt;K, V&gt;)</code></li></ol></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>自定义泛型类<br><code>public class MyGeneric&lt;T&gt; &#123;&#125;</code></li><li>自定义泛型方法<br><code>public &lt;T&gt; void MyFun(T t) &#123;&#125;</code></li><li>自定义泛型接口<br><code>public interface MyInterface&lt;E&gt; &#123;&#125;</code></li><li>泛型通配符<br>？可以在使用泛型时代表一切类型<br><code>? extends Class</code> 泛型上限，限定必须是Class或其子类<br><code>? super Class</code> 泛型下限，限定必须是Class或其父类</li><li>底层实现上，字节码中的泛型类型都会被擦除</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>对于任何一个Class对象，可以在运行时得到这个类的全部成分</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul><li>Class.forName(String)</li><li>类目.class</li><li>对象.getClass()<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96Class.svg" class="" title="alt 反射获取Class对象"></li></ul><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><ul><li>Class::getConstructors([paramTypes]) 获取公有构造器, Class::getDeclaredConstructors([paramTypes]) 获取所有构造器</li><li>Constructor::newInstance() 根据指定构造器创建新对象</li><li>Constructor::setAccessible(boolean) 设置访问检查，实现暴力反射(调用私有构造器，破坏了封装性)</li></ul><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ul><li>Class::getFields(name), Class::getDeclaredFields(name)</li><li>Field::set(object, val), Field::get(obj) 设置&#x2F;获取成员变量的值</li><li>Field::setAccessible(boolean)</li></ul><h3 id="获取方法对象"><a href="#获取方法对象" class="headerlink" title="获取方法对象"></a>获取方法对象</h3><ul><li>Class::getMethods([name, params]), Class::getDeclaredMethods([name, params])</li><li>Method::invoke(obj, args…) 对obj对象调用目标方法，可以获取返回值</li><li>Method::setAccessible(boolean)</li></ul><h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><ul><li><p>结合Lambda表达式，简化集合、数组操作的API</p></li><li><p>流的三类方法：</p><ul><li><p>获取Stream流：<br>创建一条流水线，并把数据放到流水线上准备进行操作。如<code>Collection.stream(), Arrays.stream(T[]), Stream.of(T...)</code></p></li><li><p>中间方法：<br>流水线上的操作，调用完成后返回新的Stream流，支持链式编程。如<code>filter, limit, skip, distinct, map, concat</code></p></li><li><p>终结方法：<br>流水线的最后一个操作，调用后不返回Stream，因此一个Stream流仅有一个。如<code>forEach, count</code></p></li></ul></li><li><p>流的收集</p><ul><li>把Stream流操作后的结果转回集合或数组。Stream是手段，集合&#x2F;数组才是目的</li><li>流只能使用一次 </li><li>方法：<code>stream.collect, stream.toArray, stream.toList</code>, Collector包括<code>Collectors::toList, Collectors::toSet, Collectors::toMap</code>等</li></ul></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul><li>代表OS的文件&#x2F;文件夹对象。提供定位、获取文件信息、删除、创建等功能</li><li><code>createNewFile</code></li><li><code>mkdir</code>创建一级目录, <code>mkdirs</code>创建多级目录</li><li><code>delete</code>删除文件&#x2F;空文件夹且不走回收站</li><li><code>list</code>返回目录下文件名数组,<code>listFiles</code>返回目录下文件对象数组，仅包括一级</li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>常见字符集:<ul><li>ASCII: 1个字节存储1个字符，共128个</li><li>GBK: 包含汉字等字符，一个中文2个字节存储</li><li>Unicode (UTF-8): 一个中文3个字节存储</li></ul></li><li>编解码：<ul><li>英文、数字在任何字符集都占1字节，不会乱码</li><li>编码：<code>string.getBytes(chatset)</code></li><li>解码：<code>String(byte[], charset)</code></li></ul></li></ul><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><ul><li><p>分类</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E5%88%86%E7%B1%BB.svg" class="" title="alt IO流分类"></li><li><p>体系</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/IO%E6%B5%81%E4%BD%93%E7%B3%BB.svg" class="" title="alt IO流体系"></li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><ul><li><p>InputStream</p><ul><li><code>read(), read(byte[len]), readAllBytes</code> 读取1 &#x2F; len &#x2F; 所有字节</li></ul></li><li><p>OutputStream</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字节流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><ul><li><p>Reader</p><ul><li><code>read(), read(char[len])</code> 读取 1 &#x2F; len 个字符</li></ul></li><li><p>Writer</p><ul><li>覆盖管道，默认打开文件流会清空，构造器append &#x3D; true开启附加模式</li><li><code>write(), flush(), close()</code> 输出字符流，必须刷新，结束需要关闭资源。close操作包括flush</li><li>一般用 <strong>try-with-resource</strong> 处理资源 (Closeable&#x2F;AutoCloseable)</li></ul></li></ul><ul><li>使用总结<ul><li>字节流适合一切文件数据的拷贝，包括音视频、文本等</li><li>字节流不适合读取中文内容输出</li><li>字符流适合文本文件的读写</li></ul></li></ul><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul><li>也称高效流、高级流。自带8KB缓冲区，可以提高原始字节流、字符流读写数据的性能。建议使用<strong>缓冲流+字节数组</strong></li><li><code>BufferedInputStream(InputStream)</code></li><li><code>BufferedOutputStream(OutputStream)</code></li><li><code>BufferedReader(Reader)</code>, <code>readline()</code></li><li><code>BufferedWriter(Writer)</code>, <code>newLine()</code></li></ul><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><ul><li>把原始的字节流按照指定编码转换</li><li>字符输入转换流：<code>InputStreamReader(InputStream, charset)</code></li><li>字符输出转换流：<code>OutputStreamWriter(OutputStream, charset)</code></li><li>建议创建转换流后使用缓冲流进行包装，提高性能</li></ul><h4 id="对象字节流-序列化"><a href="#对象字节流-序列化" class="headerlink" title="对象字节流 - 序列化"></a>对象字节流 - 序列化</h4><ul><li>以内存为基准，把内存中的对象存储到磁盘文件中，称为对象序列化</li><li>对象字节输出流：<code>ObjectOutputStream(OutputStream)</code></li><li><code>oos.writeObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li>以内存为基准，把存储在磁盘文件中的数据恢复成内存中的对象，称为对象反序列化</li><li>对象字节输入流：<code>ObjectInputStream(InputStream)</code></li><li><code>ois.readObject(obj)</code> obj 必须实现<code>Serializable</code>序列化接口</li></ul><ul><li><code>transient</code>修饰的成员变量不参与序列化</li><li>通常指定一个序列化版本号，以确保序列化、反序列化的对象保持一致</li></ul><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><ul><li>方便、高效地打印数据到文件中</li><li>基于字节<code>PrintStream</code>, 基于字符<code>PrintWriter</code></li><li><code>print()</code>, PrintStream支持写字节，PrintWriter支持写字符</li><li><code>System.out</code>就是一个PrintStream对象。可以重定向输出语句到文件中：<code>System.setOut(new PrintStream(File))</code></li></ul><h4 id="commons-io-库"><a href="#commons-io-库" class="headerlink" title="commons-io 库"></a>commons-io 库</h4><ul><li>IOUtils::copy</li><li>FileUtils::copyFileToDirectory</li><li>FileUtils::copyDirectoryToDirectory</li><li>…</li></ul><ul><li>JDK 1.7 引入了 NIO库</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><ul><li>定义任务类继承java.lang.Thread，重写run()方法</li><li>创建线程对象， 调用Thread::start()启动线程</li></ul><ul><li>优点：编码简单</li><li>缺点：不利于扩展，自定义线程无法继承其它类</li></ul><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><ul><li>创建Runnable接口匿名内部类，重写run()方法</li><li>把Runnable交给Thread类处理，调用start()启动线程</li></ul><ul><li>优点：可以继续继承、实现，扩展性强</li><li>缺点：多一层包装，线程如果有执行结果不可以直接返回</li></ul><h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><ul><li>定义任务类实现Callable接口，重写call()方法</li><li>用FutureTask把Callable对象封装成线程任务对象</li><li>把FutureTask交给Thread类处理调用，start()启动线程</li><li>线程执行完毕后，通过FutureTask::get()获取任务执行的结果</li></ul><ul><li>优点：可以继续继承、实现，扩展性强。且可以在线程执行完毕后获取执行结果</li><li>缺点：编码稍复杂</li></ul><h3 id="Thread常用API"><a href="#Thread常用API" class="headerlink" title="Thread常用API"></a>Thread常用API</h3><ul><li>setName, getName</li><li>currentThread() 返回当前正在执行的线程对象的引用</li><li>sleep(long) 让线程休眠指定时间，单位毫秒</li><li>yield, join, interrupt…</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><p>多个线程同时访问同一个共享资源且修改该资源</p></li><li><p>线程同步的核心思想：加锁</p><ul><li>同步代码块 <ul><li>synchronized(锁对象) </li><li>一般把共享资源作为锁对象</li><li>建议实例方法使用this作为锁对象，静态方法使用类.class对象作为锁对象</li></ul></li><li>同步方法 <ul><li>synchronized 修饰方法</li><li>底层：实例方法默认对this加锁，静态方法默认对类.class加锁</li></ul></li><li>Lock锁<ul><li>实现类：ReentrantLock</li><li>lock, unlock</li></ul></li></ul></li><li><p>线程通信</p><ul><li>wait() 让当前线程释放锁并进入等待，直到另一个线程唤醒</li><li>notify(), notifyAll() 唤醒正在等待的单个 &#x2F; 所有线程</li><li>必须通过当前同步锁对象进行调用</li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>创建线程的开销很大，可以通过复用线程，提高系统性能</p></li><li><p>线程池接口：<code>ExecutorService</code>; 实现类：<code>ThreadPoolExecutor</code>;  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-type">int</span> corePoolSize,                   //指定线程池的线程数量 (核心线程)</span><br>  <span class="hljs-type">int</span> maximumPoolSize,                <span class="hljs-comment">//指定线程池可支持的最大线程数 (&gt;=核心线程数)</span><br>  <span class="hljs-type">long</span> keepAliveTime,                 <span class="hljs-comment">//指定临时线程的最大存活时间</span><br>  TimeUnit unit,                      <span class="hljs-comment">//指定存活时间的单位(秒、分、时、天)</span><br>  BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//指定任务队列</span><br>  ThreadFactory threadFactory,        <span class="hljs-comment">//指定用哪个线程工厂创建线程</span><br>  RejectedExecutionHandler handler    <span class="hljs-comment">//指定线程忙，任务满的时候，新任务来了怎么办</span><br>)<br></code></pre></td></tr></table></figure><ul><li>新任务提交时的服务顺序：核心线程 -&gt; 任务队列 -&gt; 创建临时线程 -&gt; 拒绝服务<ul><li>如果核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程</li><li>核心线程、临时线程都在忙，任务队列也满了，新的任务到达时才会开始拒绝服务</li></ul></li><li>常用方法：<code>execute(Runnable), submit(Callable), shutdown(), shutdownNow()</code></li><li>拒绝策略：<ul><li><code>ThreadPoolExecutor.AbortPolicy</code> 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>ThreadPoolExecutor.DiscardPolicy</code> 丢弃且不抛异常，不推荐</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 抛弃队列中等待最久的任务 然后把当前任务加入队列中</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 绕过线程池，由主线程直接调用任务的run()方法执行</li></ul></li></ul></li><li><p>线程池工具类: <code>Executors</code> 通过调用方法返回不同类型的线程池对象</p><ul><li><code>newCachedThreadPool()</code> 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉</li><li><code>newFixedThreadPool​(int nThreads)</code> 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它</li><li><code>newSingleThreadExecutor()</code> 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程</li><li><code>newScheduledThreadPool​(int corePoolSize)</code> 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务</li><li>底层仍是基于ThreadPoolExecutor实现的</li><li>最大任务队列长度&#x2F;线程数量是Integer.MAX_VALUE,可能出现OOM</li></ul></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul><li>一种控制任务延时调用，或者周期调用的技术</li><li>实现方式：<ol><li>Timer<ul><li>Timer::schedule(task, delay&#x2F;time, period);</li><li>Timer单线程，处理多个任务按顺序执行，存在延时，和设置定时器的时间有出入</li><li>可能因为异常导致Timer线程死掉，从而影响后续任务执行</li></ul></li><li>ScheduledExecutorService<ul><li>Executors.newScheduledThreadPool​(int corePoolSize)</li><li>ScheduledExecutorService.scheduleAtFixedRate(Runnable, delay, period, unit)</li><li>基于线程池，某个任何的执行情况不会影响其它定时任务</li></ul></li></ol></li></ul><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul><li>并发: CPU分时轮询执行</li><li>并行: 同一时刻同时执行</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li>Java定义了6中状态：Thread.State::{NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED}<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" class="" title="线程的生命周期"></li></ul><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li>操作类 <code>InetAddress</code></li><li>getLocalHost 返回本主机的地址对象</li><li>getByName(host) 得到指定主机(域名&#x2F;IP)的IP地址对象</li><li>getHostName 返回此IP地址的主机名</li><li>getHostAddress 返回IP地址字符串 </li><li>isReachable(timeout) 指定时间ms内是否连通该IP</li></ul><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ul><li>标识主机上的进程，16bit，0-65535</li><li>周知端口 0-1023：预先定义的知名应用，如HTTP 80，FTP 21</li><li>注册端口 1024-49151：分配给用户进程&#x2F;应用程序，如Tomcat 8080，MySQL 3306</li><li>动态端口 49152-65535</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li>Ping命令直接基于网络层ICMP协议，无连接，不针对特定端口。与传输层TCP&#x2F;UDP，或是应用层HTTP等都无关</li><li>Socket是一个调用接口，实际是对TCP&#x2F;IP协议的封装</li><li>UDP协议的数据包大小限制64KB</li></ul><h3 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h3><ul><li>DatagramPacket 数据包对象<ul><li>DatagramPacket(byte[] buf, length, InetAddress, port)</li><li>getLength() 获取实际接受的字节个数</li></ul></li><li>DatagramSocket 发送者&#x2F;接收者对象<ul><li>DatagramSocket(port)</li><li>send(packet)</li><li>receive(packet)</li></ul></li></ul><ul><li>广播 Broadcast<ul><li>使用广播地址 255.255.255.255</li><li>发送端指定端口，其它主机注册该端口即可</li></ul></li><li>组播 Multicast<ul><li>使用组播地址 224.0.0.0 - 239.255.255.255</li><li>发送端指定组播IP和端口，接收端绑定该组播IP，并注册该端口</li><li>DatagramSocket的子类MulticastSocket::joinGroup负责绑定组播IP</li></ul></li></ul><h3 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h3><ul><li><code>java.net.Socket</code> 基于TCP协议<ul><li>Socket(host, port)</li><li>Socket::getOutputStream()</li><li>Socket::getInputStream()</li></ul></li><li>ServerSocket 服务端<ul><li>ServerSocket(port)</li><li>ServerSocket::accept() 等待接收客户端的Socket通信连接，连接成功返回Socket对象与客户端建立端到端通信</li></ul></li><li>服务端一般使用循环，负责接收客户端Socket管道连接,每接收到一个Socket管道后分配一个独立的线程负责处理它(线程池技术)</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><ul><li><strong>Error</strong>：系统级别问题、JVM退出等，代码无法控制</li><li><strong>Exception</strong>：java.lang包下，称为异常类，表示程序本身可以处理的问题<ul><li><strong>RuntimeException</strong>及其子类：运行时异常，编译阶段不会报错。如空指针、数组索引越界等</li><li>除<strong>RuntimeException</strong>之外的所有异常：编译时异常，编译期必须处理，也称受检异常。如日期格式化异常</li></ul></li></ul><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.svg" class="" title="alt 异常体系"><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><strong>throws</strong>：用在方法声明上，将方法内部出现的异常抛出给调用者</li><li><strong>try-catch</strong>：监视捕获异常，在方法内部自己处理，程序继续执行</li><li><strong>try-catch-finally</strong>: 除非JVM崩溃，否则必须执行finally块</li><li><strong>try-with-resource</strong>: 自动关闭资源(Closeable&#x2F;AutoCloseable)，即使出现异常</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>定义异常继承 Exception &#x2F; RuntimeException</li><li>重写构造器</li><li>在出现异常的地方主动 throw 自定义异常对象</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>又称Java标注，对Java中类、方法、变量做标记，然后进行特殊处理</p><ul><li><p>自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Book &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">price</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">100</span>;<br>    String[] author();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>元注解：对注解类的注解</p><ul><li>@Target：约束注解标记的位置<ul><li>ElementType.TYPE 类，接口</li><li>ElementType.FIELD 成员变量</li><li>ElementType.METHOD 成员方法</li><li>ElementType.PARAMETER 方法参数</li><li>ElementType.CONSTRUCTOR 构造器</li><li>ElementType.LOCAL_VARIABLE 局部变量</li></ul></li><li>@Retention：约束注解的存活范围<ul><li>RetentionPolicy.SOURCE 注解只作用在源码阶段，生成的字节码文件中不存在</li><li>RetentionPolicy.CLASS 默认值，注解作用在源码阶段，字节码文件阶段，运行阶段不存在</li><li>RetentionPolicy.RUNTIME 注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li></ul></li></ul></li><li><p>注解解析</p><ul><li>Annotation: 注解对象</li><li>AnnotatedElement: 注解解析相关方法的接口，所有类成分Class&#x2F;Method&#x2F;Field&#x2F;Constructor均已实现<ul><li>getDeclaredAnnotations()</li><li>getDeclaredAnnotation(class)</li><li>isAnnotationPresent(class)</li></ul></li><li>解析技巧：注解在哪个成分上，就先拿哪个成分对象</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>对业务功能进行代理，类似AOP编程</li><li>Proxy::newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li><li>InvocationHandler::invoke(Object proxy, Method method, Object[] args)</li><li>优点：<ul><li>非常灵活，支持任意接口类型做代理，也可以直接为接口本身做代理</li><li>可以为被代理对象的所有方法做代理</li><li>不改变方法源码的情况下，实现对功能的增强</li><li>简化编程，提高可扩展性，提高了开发效率</li></ul></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li>解决浮点型运算精度失真问题</li><li>禁止使用BigDecimal(double)把double值转换为BigDecimal对象，依然存在精度损失风险</li><li>推荐使用<code>BigDecimal(String)或BigDecimal.valueOf(Double)</code>的构造方式，自动对精度进行截断处理</li><li>BigDecimal只是手段，目的是Double</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举类都继承了 <code>java.lang.Enum</code></li><li>枚举都是最终类，不可以被继承</li><li>构造器都是私有，对外不能创建对象</li><li>枚举类相当于多例模式<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8F%8D%E7%BC%96%E8%AF%91.svg" class="" title="alt 枚举类型反编译"><center>枚举类型反编译</center></li></ul><h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><ul><li>Date 日期对象<ul><li>Date() </li><li>setTime(), getTime() 时间毫秒值</li></ul></li><li>SimpleDateFormat<ul><li>new SimpleDateFormat(pattern)</li><li>format(Date&#x2F;time): Date&#x2F;time -&gt; String</li><li>parse(dateStr): String -&gt; Date</li></ul></li><li>Calendar 系统此刻日历对象<ul><li>Calendar.getInstance()</li></ul></li></ul><p>JDK 8新增日期时间API：</p><ul><li>LocalDate 不包含具体时间的日期</li><li>LocalTime 不包含日期的时间</li><li>LocalDateTime 包含日期和时间</li><li>Instant 时间戳</li><li>DateTimeFormatter 时间格式化和解析</li><li>Duration 计算两个时间间隔</li><li>Period 计算两个日期间隔</li><li>ChronoUnit 针对特定时间单位测量时间差</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>Pattern.complie(regex)</li><li>pattern.matcher(String)</li><li>matcher.find()</li><li>matcher.group()</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><p>优势：可以将系统执行的信息选择性的记录到指定的位置，如控制台、文件、数据库等。并且随时以开关的形式控制是否记录，灵活性好</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB.svg" class="" title="alt 日志体系"></li><li><p>Logback 模块</p><ul><li>logback-core: 核心模块</li><li>logback-classic: log4j 改良版本，完整实现 slf4j API</li><li>logback-access: 与Tomcat和Jetty等Servlet容器集成，提供HTTP访问日志功能</li></ul></li><li><p>使用：</p><ul><li>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR，默认DEBUG</li><li>配置文件<code>logback.xml</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;Test.class&quot;</span>);<br>LOGGER.debug(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.info(<span class="hljs-string">&quot;log info......&quot;</span>);<br>LOGGER.trace(<span class="hljs-string">&quot;a = &quot;</span> + a);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>针对最小的功能单元，即Java中的方法，编写测试代码</li><li>传统测试方法的缺陷：只能测试main，方法之间相互影响，无法得到测试结果的报告，无法实现自动化测试</li><li>Junit单元测试框架<ul><li>优点：可以灵活选择测试方法，自动生成测试报告</li><li>使用：<ul><li>导入JUnit</li><li>编写公共的，无参数无返回值测试方法，并加上@Test注解</li><li>允许测试</li></ul></li><li>测试注解：@Before, @After, @BeforeClass, @AfterClass, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll</li></ul></li></ul><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li>可扩展标记语言（eXtensible Markup Language），一种数据表示格式</li><li>纯文本，默认UTF-8编码，可嵌套，经常用于网络传输、配置文件</li><li>XML格式：<ul><li>第一行文档声明 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</code></li><li>特殊字符：小于 &amp;lt;  大于 &amp;gt; 和号 &amp;amp; 单引号 &amp;apos; 引号 &amp;quot;</li><li>解释器忽略文本：&lt;![CDATA[…内容…]]&gt;</li></ul></li><li>XML约束：限定xml文件中的标签以及属性规则<ul><li>DTD <code>&lt;!DOCTYPE 根标签名 PUBLIC/SYSTEM &quot;dtd文件名&quot; &quot;dtd文件位置&quot;&gt;</code> 不能约束具体数据类型</li><li>SCHEME <code>&lt;根标签 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xxx.com&quot; xsi:schemaLocation=&quot;http://xxx.xsd&quot;&gt;</code> 约束更严谨</li></ul></li><li>XML解析<ul><li>SAX解析：一行一行解析</li><li>DOM解析：整个文件解析，如JAXP、JDOM、<strong>Dom4j</strong>、jsoup</li><li>Dom4j API:<ul><li>List<Element> elements() 得到当前元素下所有子元素</li><li>List<Element> elements(String name) 得到当前元素下指定名字的子元素返回集合</li><li>Element element(String name) 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</li><li>String getName() 得到元素名字</li><li>String attributeValue(String name) 通过属性名直接得到属性值</li><li>String elementText(子元素名) 得到指定名称的子元素的文本</li><li>String getText() 得到文本</li></ul></li></ul></li><li>XML检索——XPath<ul><li>使用路径表达式来定位元素节点或属性节点</li><li>基于dom4j和jaxen</li><li>selectSingleNode(exp), selectNodes(exp)</li><li>四大检索方案：<ul><li>绝对路径：<code>/根元素/子元素/孙元素</code> 从根元素开始，一级一级向下查找，不能跨级</li><li>相对路径: <code>./子元素/孙元素</code> 从当前元素开始，一级一级向下查找，不能跨级</li><li>全文检索: <code>//name</code> <code>//father/son</code> <code>//father//grandson</code> 直接全文搜索所有的name元素并打印</li><li>属性查找: <code>//@attr</code> <code>//ele[@attr]</code> <code>//ele//[@attr=val]</code> 查找属性&#x2F;含有指定值的属性的元素</li></ul></li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>工厂模式：<ul><li>对象通过工厂的方法创建返回</li><li>可以为该对象进行加工和数据注入，实现类与类之间的解耦操作</li></ul></li><li>装饰模式<ul><li>创建新类，包装原始类</li><li>可以在不改变原有类的基础上，动态扩展一个类的功能</li></ul></li></ul><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><ul><li>JVM内存区：<strong>虚拟机栈、堆、方法区</strong>、本地方法栈、程序计数器<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/Java%E5%86%85%E5%AD%98%E5%8C%BA.svg" class="" title="alt Java内存区"></li></ul><ul><li>基本内存分配：<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" class="" title="alt 基本内存分配"><ul><li>方法区存放加载的类信息</li><li>栈(栈帧): 局部变量表</li><li>堆: new出来的对象实例 （如数组）</li></ul></li></ul><ul><li><p>两个引用指向同一对象</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1.png" class="" title="alt 两个引用指向同一对象"><ul><li>栈内存中两个引用的地址值指向堆中同一块内存区</li><li>利用引用修改堆中数据后，所有引用指向该内存区域的数据都会反映出来</li></ul></li></ul><ul><li>Java参数传递机制<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 基本类型参数传递"><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" class="" title="alt 引用类型参数传递"><ul><li>无论基本类型还是引用类型，都是值传递</li><li>基本类型传递的是本身的数据值</li><li>引用类型的值是指向堆内存的某个地址</li></ul></li></ul><ul><li>两个对象内存图;<img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 两个类对象内存图"><ul><li>方法区保存了类的信息，包括类名、成员变量、成员方法等</li><li>堆中实际类对象的成员方法存的是方法区里类的成员方法引用</li></ul></li></ul><ul><li><p>集合存储内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 集合存储内存图"><ul><li>数组&#x2F;集合中存储的元素并不是对象本身，而是对象的地址</li></ul></li><li><p>静态常量内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 静态常量内存图"></li><li><p>子类继承内存图</p><img src="/2022/10/08/JavaSE-%E5%A4%8D%E4%B9%A0/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" title="alt 子类继承内存图"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows平台搭建Dash系统</title>
    <link href="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows平台搭建Dash系统"><a href="#Windows平台搭建Dash系统" class="headerlink" title="Windows平台搭建Dash系统"></a>Windows平台搭建Dash系统</h1><h2 id="1-Dash简介"><a href="#1-Dash简介" class="headerlink" title="1. Dash简介"></a>1. Dash简介</h2><p><strong>Dynamic Adaptation Streaming over HTTP (Dash):</strong><br>HTTP上的动态自适应视频流技术，它将一个视频划分为许多个segment，每个segment有不同质量的副本，能够在播放时根据用户当前的网络状况选择最佳的码率，减少卡顿。详情: <a href="https://dashif.org/">https://dashif.org/</a></p><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2. 配置环境"></a>2. 配置环境</h2><ul><li>环境<ul><li>系统：Windows 10</li><li>客户端：Chrome</li></ul></li><li>工具 (安装好并将<code>bin</code>目录加入系统环境变量)<ul><li>服务器：Nginx <a href="https://www.cnblogs.com/taiyonghai/p/9402734.html">安装教程</a></li><li>编解码器：<a href="https://github.com/BtbN/FFmpeg-Builds/releases">FFmpeg</a></li><li>视频切片工具：<a href="https://www.bento4.com/downloads/">Bento4</a></li><li>播放器：<a href="https://github.com/Dash-Industry-Forum/dash.js">dash.js</a></li></ul></li><li>视频<ul><li>Big Buck Bunny   可以去 <a href="https://download.blender.org/peach/bigbuckbunny_movies/">https://download.blender.org/peach/bigbuckbunny_movies/</a> 下载</li></ul></li></ul><h2 id="3-对视频进行编码"><a href="#3-对视频进行编码" class="headerlink" title="3. 对视频进行编码"></a>3. 对视频进行编码</h2><ul><li>目标编码格式：H.264&#x2F;AVC</li><li>目标分辨率级别：<ul><li>1920×1080 (1080p)</li><li>1280×720 (720p)</li><li>854×480 (480p)</li><li>640×360 (360p)</li><li>256×144 (144p)</li></ul></li><li>编码命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1920x1080 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1920x1080.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 1280x720 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_1280x720.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 896x504 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_896x504.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 640x360 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_640x360.mp4<br>ffmpeg -i Big_Buck_Bunny_1080p.avi -s 256x144 -c:v libx264 -keyint_min 48 -g 48 -sc_threshold 0 -an BBB_256x144.mp4<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>：输入文件名</li><li><code>-s</code>：输出的分辨率</li><li><code>-c:v libx264</code>：将视频编码为H.264&#x2F;AVC格式</li><li><code>-keyint_min 48 -g 48 -sc_threshold 0</code>：固定GOP长度为48帧(即2s，具体由帧率决定)。这里如果没有这个参数后面bento4切分时会报错，具体原因见 <a href="https://blog.csdn.net/LvGreat/article/details/103540007">FFmpeg的GOP（I帧）对齐问题</a></li><li><code>-an</code>：不对音频进行编码，dash中音视频分开编码</li><li>最后是输出文件名</li></ul></li></ul><p> 可以写个bat，扔那边慢慢跑，视频小的话几十秒就好了。完成后：<br> <img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90.png" class="" title="alt 视频编码完成"><br>​</p><h2 id="4-视频切片"><a href="#4-视频切片" class="headerlink" title="4. 视频切片"></a>4. 视频切片</h2><ol><li><p>使用bento4的<code>mp4fragment</code>对视频进行fragment</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4fragment --fragment-duration 2000 BBB_1920x1080.mp4 fragmented_1080p.mp4<br>mp4fragment --fragment-duration 2000 BBB_1280x720.mp4 fragmented_720p.mp4<br>mp4fragment --fragment-duration 2000 BBB_896x504.mp4 fragmented_480p.mp4<br>mp4fragment --fragment-duration 2000 BBB_640x360.mp4 fragmented_360p.mp4<br>mp4fragment --fragment-duration 2000 BBB_256x144.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>  <code>--fragment-duration</code>：指定fragment时长为2s</p></li><li><p>使用<code>mp4dash</code>对已fragment的视频进行切片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mp4dash fragmented_1080p.mp4 fragmented_720p.mp4 fragmented_480p.mp4 fragmented_360p.mp4 fragmented_144p.mp4<br></code></pre></td></tr></table></figure><p>成后目录中会自动生成out文件夹，里面有mpd文件和切分的segment</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E5%AE%8C%E6%88%90.png" class="" title="alt 视频切片完成"></li></ol><h2 id="5-编写简易网页播放器"><a href="#5-编写简易网页播放器" class="headerlink" title="5. 编写简易网页播放器"></a>5. 编写简易网页播放器</h2><p>参考：<a href="https://github.com/Dash-Industry-Forum/dash.js%E2%80%8B">https://github.com/Dash-Industry-Forum/dash.js​</a></p><p>将out里面的video文件夹和<code>stream.mpd</code>放到nginx的html文件夹里，下载<code>dash.all.min.js</code>也放入html文件夹中。</p><p>具体的目录结构可以自定义。我这边的目录如下：</p><img src="/2020/12/01/Windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BADash%E7%B3%BB%E7%BB%9F/demo%E7%9B%AE%E5%BD%95.png" class="" title="alt Demo目录"><p>DashJS.html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dash.js Rocks<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">            <span class="hljs-selector-tag">video</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>;</span><br><span class="language-css">                <span class="hljs-attribute">height</span>: <span class="hljs-number">360px</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;videoPlayer&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dash.all.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;./stream.mpd&quot;</span>;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> player = dashjs.<span class="hljs-title class_">MediaPlayer</span>().<span class="hljs-title function_">create</span>();</span><br><span class="language-javascript">                player.<span class="hljs-title function_">initialize</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#videoPlayer&quot;</span>), url, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript">            &#125;)();</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p><h2 id="6-配置Nginx服务器"><a href="#6-配置Nginx服务器" class="headerlink" title="6. 配置Nginx服务器"></a>6. 配置Nginx服务器</h2><p>配置访问控制，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨源资源共享（CORS） - HTTP | MDN</a></p><p>修改Nginx的conf下的nginx.conf文件中的server段，主要是加入location &#x2F;file那一块</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">server <span class="hljs-punctuation">&#123;</span><br>    listen       <span class="hljs-number">8800</span>;<br>    server_name  localhost;<br><br>    location / <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>        index  index.html index.htm;<br>    <span class="hljs-punctuation">&#125;</span><br>    location /file <span class="hljs-punctuation">&#123;</span><br>        if ($request_method = &#x27;OPTIONS&#x27;) <span class="hljs-punctuation">&#123;</span><br>            add_header Access-Control-Allow-Origin $http_origin;<br>            add_header Access-Control-Allow-Methods             <br>            $http_access_control_request_method;<br>            add_header Access-Control-Allow-Credentials <span class="hljs-literal"><span class="hljs-keyword">true</span></span>;<br>            add_header Access-Control-Allow-Headers <br>            $http_access_control_request_method;<br>            add_header Access-Control-Max-Age <span class="hljs-number">1728000</span>;<br>            return <span class="hljs-number">204</span>;<br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><br>    #error_page  <span class="hljs-number">404</span>              /<span class="hljs-number">404.</span>html;<br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>        root   html;<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>验证Nginx配置是否正确，正确后启动Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br>start nginx<br></code></pre></td></tr></table></figure><h2 id="7-验证"><a href="#7-验证" class="headerlink" title="7. 验证"></a>7. 验证</h2><p>最后打开 <a href="http://localhost:8800/DashDemo/DashJS.html">http://localhost:8800/DashDemo/DashJS.html</a> 验证是否成功即可</p><p>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://codeleading.com/article/26092631381/#5_Bento4_90">DSAH视频系统（服务器&amp;播放器）搭建 - 代码先锋网</a></li><li>[2] <a href="https://blog.csdn.net/OCTODOG/article/details/79007302">Nginx 搭建DASH服务器_山城过雨的博客-CSDN博客</a></li><li>[3] <a href="https://www.instructables.com/Making-Your-Own-Simple-DASH-MPEG-Server-Windows-10/">Making Your Own Simple MPEG-DASH Server (Windows 10) : 12 Steps - Instructables</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Dash</tag>
      
      <tag>视频流</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
