

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Myfavicon.ico">
  <link rel="icon" href="/img/Myfavicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="chanper">
  <meta name="keywords" content="">
  
    <meta name="description" content="《实战Java高并发程序设计》学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-并发">
<meta property="og:url" content="https://chanpero.github.io/2022/11/20/Java-%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name">
<meta property="og:description" content="《实战Java高并发程序设计》学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-20T11:42:37.000Z">
<meta property="article:modified_time" content="2022-11-28T13:22:37.378Z">
<meta property="article:author" content="chanper">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Java-并发 </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"chanpero.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"e6fbf52343bffac933f91eae00e480dc","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"1InH4XckKf2mHSUQuLHRajZH-gzGzoHsz","app_key":"jDwLBVwoqcNPXW57ymIDicVB","server_url":"https://1inh4xck.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?e6fbf52343bffac933f91eae00e480dc";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>chanper</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java-并发"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-20 19:42" pubdate>
          2022年11月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          170 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java-并发</h1>
            
            
              <div class="markdown-body">
                
                <p>《实战Java高并发程序设计》学习笔记</p>
<h1 id="第-1-章-走入并行世界"><a href="#第-1-章-走入并行世界" class="headerlink" title="第 1 章 - 走入并行世界"></a>第 1 章 - 走入并行世界</h1><h2 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h2><ul>
<li>同步：一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li>
<li>异步：一旦开始，调用就会立即返回，调用者可以继续后续的操作</li>
</ul>
<ul>
<li>并发：多个任务交替执行</li>
<li>并行：多个任务同时执行</li>
</ul>
<ul>
<li>临界区：表示一种公共资源或共享数据，可以被多个线程使用，但同一时间只能有一个线程使用。一旦临界区资源被占用，其它线程想要使用就必须等待</li>
</ul>
<ul>
<li>阻塞：一个线程占用了临界区资源，其它线程必须等待，导致线程挂起，就是阻塞</li>
<li>非阻塞：没有一个线程可以防碍其他线程执行，所有线程都会尝试不断前进</li>
</ul>
<p>多线程的活跃性问题：</p>
<ul>
<li>死锁：多个线程都占有其它线程需要的资源，且都不释放，从而没有一个线程可以同时拿到所有资源，造成所有线程都进入等待</li>
<li>饥饿：某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行</li>
<li>活锁：多个线程在竞争资源时，都主动释放给其它线程使用，导致资源不断在两个线程间跳动，从而没有一个线程可以同时拿到所有资源</li>
</ul>
<h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><ul>
<li>阻塞：其它线程释放资源之前，当前线程无法继续执行（悲观）</li>
<li>无饥饿：对于公平锁，所有线程遵守先进先出的原则，就不会产生饥饿</li>
<li>无障碍：任何线程都可以进入临界区，但是一旦检测到冲突就需要回滚（乐观）</li>
<li>无锁：无锁并行都是无障碍的，任何线程都可以进入临界区，且必然有一个线程可以在有限步内完成操作并离开。通常包含一个无限循环尝试竞争</li>
<li>无等待：要求所有线程在有限步内完成操作，分为有界无等待和与线程数无关的无等待。典型的如RCU（Read Copy Update），对读不加控制，修改只针对副本，并在合适的时机写回</li>
</ul>
<h2 id="并行加速定律"><a href="#并行加速定律" class="headerlink" title="并行加速定律"></a>并行加速定律</h2><pre><code class="hljs">加速比 = 优化前耗时 / 优化后耗时
</code></pre>
<ol>
<li>Amdahl 定律<br>并行优化的效果取决于CPU数量，以及系统中的串行化代码的比例。CPU数量越多，串行化比例越低，优化效果越好。仅增加CPU数量而不降低串行化比例，无法提高系统性能。</li>
<li>Gustafson 定律<br>只要增加处理器，就能获得更快的速度。如果可被并行化的代码所占比例足够大，那么加速比就能随着处理器数量线性增长。</li>
</ol>
<h2 id="JMM-并发原则"><a href="#JMM-并发原则" class="headerlink" title="JMM 并发原则"></a>JMM 并发原则</h2><ul>
<li>原子性：<ul>
<li>一个操作不可中断</li>
<li>对于32位JVM，long和double两个64位数据的读写是不保证原子性的</li>
</ul>
</li>
<li>可见性：<ul>
<li>一个线程修改了某个共享变量，其它线程是否能够立即得知这个修改。</li>
<li>原因在于缓存优化、硬件优化、指令重排、编辑器的优化等</li>
<li>在一个线程中观察另一个线程的变量，它们的值是否能观察到、何时能观察到是没有保证的</li>
</ul>
</li>
<li>有序性：<ul>
<li>程序在执行时可能会进行指令重排，于原指令的顺序未必一致</li>
<li>原因在于一条指令的执行，对于CPU来说需要分为多个步骤依次执行，为了提高CPU效率，使用了流水线技术。这样就可能某个步骤需要等另一指令的某个步骤先完成，从而产生中断。为了尽可能减少流水线的中断，因此需要做指令重排</li>
<li>不能重排的指令：Happen-Before规则 保证指令重排不会破坏原有的语义<ul>
<li>程序顺序原则：在一个线程内保证语义的串行性</li>
<li>volatile规则：volatile变量的写先于读发生，保证了volatile变量的可见性</li>
<li>锁规则：unlock必然发生在随后的lock前</li>
<li>传递性：A先于B，B先于C，则A必先于C</li>
<li>线程<code>start()</code>方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结<code>Thread.join()</code></li>
<li>线程的中断<code>interrupt()</code>先于被中断线程的代码</li>
<li>对象构造函数的执行、结束先于<code>finalize()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第-2-章-并行程序基础"><a href="#第-2-章-并行程序基础" class="headerlink" title="第 2 章 - 并行程序基础"></a>第 2 章 - 并行程序基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>进程是程序的基本执行实体，是线程的容器</li>
<li>线程是轻量级进程，是程序执行的最小单位</li>
<li>线程的切换和调度的成本远远小于进程</li>
<li>线程的状态：<ul>
<li>NEW：刚刚创建，线程还没开始执行</li>
<li>RUNNABLE：线程正在执行，拥有所需的一切资源</li>
<li>BLOCKED：遇到sychronized同步块暂停执行，进入同步队列(尝试获取锁但失败的线程)，直到获得请求的锁</li>
<li>WAITING：无限等待，等待一些特殊事件，如notify(), join()</li>
<li>TIMED_WAITING：有限等待</li>
<li>TERMINATED：线程执行完毕</li>
</ul>
</li>
</ul>
<pre><code class=" mermaid">stateDiagram
  NEW --&gt; RUNNABLE: 启动
  RUNNABLE --&gt; BLOCKED: synchronized
  BLOCKED --&gt; RUNNABLE: synchronized
  RUNNABLE --&gt; WAITING: wait()
  WAITING --&gt; RUNNABLE: notify()
  RUNNABLE --&gt; TIMED_WAITING: wait()
  TIMED_WAITING --&gt; RUNNABLE: notify()
  RUNNABLE --&gt; TERMINATED: 结束
</code></pre>


<h2 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h2><ul>
<li><p>新建线程：</p>
<ul>
<li>extends Thread()::run()</li>
<li>implements Runnable::run()</li>
<li>new Thread(Runnable)::start()</li>
</ul>
</li>
<li><p>终止线程：</p>
<ul>
<li>Thread::stop(), 不推荐使用。因为会立即终止线程，并释放持有的锁，可能破坏对象一致性</li>
</ul>
</li>
<li><p>线程中断：</p>
<ul>
<li>Thread::interrupt() 中断线程</li>
<li>Thread::isInterrupted() 判断是否中断</li>
<li>static boolean Thread.interrupted() 判断是否中断，并清除当前中断状态</li>
<li>Thread::sleep()方法由于中断抛出异常时，会清除中断标志位</li>
</ul>
</li>
<li><p>线程等待</p>
<ul>
<li>Object::wait() 对象所在线程停止运行，释放CPU和锁资源，进入等待队列</li>
<li>Object::notify() 随机唤醒一个等待队列中的线程进入同步队列</li>
<li>Object::notifyAll() 唤醒等待队列中的的所有线程进入同步队列</li>
<li>工作原理：<ul>
<li>每个Object拥有一个等待该对象锁的<code>等待队列</code>，和一个尝试获取锁但失败的线程<code>同步队列</code></li>
<li>wait()和notify()执行前会先获取Object对象的监视器，执行后释放监视器。因此调用必须包含在对应的synchronized块中</li>
<li>wait()会主动释放目标对象锁，而sleep()不会释放锁资源，仅让出CPU，且不能被唤醒</li>
<li>notify()不会立即释放CPU和锁资源，而是等同步代码执行完毕才释放</li>
</ul>
</li>
</ul>
</li>
<li><p>线程挂起和恢复 – deprecated</p>
<ul>
<li>Thread::suspend() 挂起线程且不释放任何锁资源。挂起的线程竟然属于Runnable状态</li>
<li>Thread::resume()</li>
</ul>
</li>
<li><p>等待线程结束和谦让</p>
<ul>
<li>Thread::join( [millis] ) 无限&#x2F;有限等待，直到目标线程，也就是调用的对象线程执行完毕</li>
<li>Thread::yield() 让出当前CPU</li>
<li>join()方法底层是通过wait()实现的，调用的线程执行完毕后会执行notifyAll()唤醒所有等待队列的线程进入同步队列</li>
</ul>
</li>
</ul>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul>
<li>volatile关键字告诉JVM,该变量极有可能会被某些程序或者线程修改</li>
<li>volatile有助于操作的原子性,可见性,有序性</li>
<li>但volatile不能代替锁，不保证一些复合操作的原子性</li>
</ul>
<h2 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">tg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>( <span class="hljs-string">&quot;PrintGroup&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T1&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(tg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroupName</span>(), <span class="hljs-string">&quot;T2&quot;</span>);<br>t1.start();<br>t2.start();<br>System.out.println(tg.activeCount()); <span class="hljs-comment">// 获得活动线程总数</span><br>tg.list();  <span class="hljs-comment">//打印线程组中所有线程</span><br></code></pre></td></tr></table></figure>

<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><ul>
<li>完成一些系统性服务，例如GC线程、JIT线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonT</span>();<br>t.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 必须在守护线程开始之前设置，否则当作普通的用户线程执行</span><br>t.start();  <span class="hljs-comment">// 只要主线程结束，整个程序就会结束，不管守护线程是否结束</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li>Java的线程优先级从低到高为1-10</li>
<li>Thread::setPriority(int)</li>
<li>优先级的后果不可预测，无法精确控制。因此如果要求严格，仍需要自己在应用层解决线程调度问题</li>
</ul>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ul>
<li>对同步的代码加锁，使得每次只有一个线程进入同步块，从而保证现成的安全性</li>
<li>如果指定加锁对象，则进入同步代码前要先获得指定对象的锁</li>
<li>如果作用于实例方法，相当于对当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>如果作用于静态方法，相当于对当前类加锁，进入同步代码前要获得当前类的锁</li>
<li>synchronized还可以保证线程间的可见性和有序性（使多线程串行执行）</li>
</ul>
<h2 id="并发下的隐蔽错误"><a href="#并发下的隐蔽错误" class="headerlink" title="并发下的隐蔽错误"></a>并发下的隐蔽错误</h2><ul>
<li>如非线程安全的ArrayList, HashMap, Integer等等</li>
<li>jps查看系统运行的Java程序，jstack pid 打印指定java进程的内部线程及其堆栈</li>
</ul>
<hr>
<h1 id="第-3-章-JDK并发包"><a href="#第-3-章-JDK并发包" class="headerlink" title="第 3 章 - JDK并发包"></a>第 3 章 - JDK并发包</h1><h2 id="同步控制工具"><a href="#同步控制工具" class="headerlink" title="同步控制工具"></a>同步控制工具</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote>
<p>可重入锁，性能和synchronized相当，但使用更灵活，提供额外的高级功能</p>
</blockquote>
<ul>
<li>ReentrantLock::lock() 获得锁，如果锁已经被占用，则等待</li>
<li>ReentrantLock::lock(boolean fair) 公平锁，维护一个等待队列，先来后到</li>
<li>ReentrantLock::lockInterruptibly() 获得锁，但优先响应中断</li>
<li>ReentrantLock::tryLock() 尝试获得锁，不等待直接返回。如果成功返回true，失败返回false。</li>
<li>ReentrantLock::tryLock(time, TimeUnit) 在给定时间内尝试获取锁</li>
<li>ReentrantLock::unlock 释放锁</li>
</ul>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><blockquote>
<p>与重入锁关联的wait &#x2F; notify机制</p>
</blockquote>
<ul>
<li>Lock::newCondition()</li>
<li>Condition::await() 使当前线程进入等待队列，同时释放当前锁。要求先获得相关锁</li>
<li>Condition::awaitUninterruptibly() 使当前线程进入等待队列，但等待时不响应中断。要求先获得相关锁</li>
<li>Condition::signal() &#x2F; signalAll() 唤醒一个&#x2F;所有等待队列中的线程。要求先获得相关锁</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<ol>
<li>基于许可的多线程控制<br>  为每个访问共享区间的线程派发一个许可，拿到许可的线程才能进入共享区间活动。完成任务离开共享区间时，必须归还许可，以确保后续的线程可以正常取得许可。如果许可用完，则线程必须先等待。</li>
<li>排他锁和共享锁<br>  排他模式下，只有一个线程可以访问共享变量。而共享模式下，则允许多个线程同时访问共享变量。例如，重入锁是排他的，信号量是共享的。</li>
</ol>
</blockquote>
<p>信号量是对锁的扩展，允许多个线程同时访问共享资源</p>
<ul>
<li>Semaphore(int permits, [boolean fair]) 构造信号量，指定准入数，可选是否公平</li>
<li>Semaphore::acquire(), Semaphore::acquireUninterruptibly()</li>
<li>Semaphore::tryAcquire(), Semaphore::tryAcquire(timeout, TimeUnit)</li>
<li>Semaphore::release()</li>
</ul>
<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><blockquote>
<p>JDK5提供的读写分离锁，可以有效地减少锁竞争，提升系统性能。</p>
</blockquote>
<ul>
<li>读写锁的访问约束：<ul>
<li>读与读不互斥</li>
<li>读与写互斥</li>
<li>写与写互斥</li>
</ul>
</li>
<li>API:<ul>
<li>实现类：ReentrantReadWriteLock()</li>
<li>ReadWriteLock::readLock(), ReadWriteLock::writeLock()</li>
<li>锁操作和ReentrantLock基本一致</li>
</ul>
</li>
</ul>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<p>倒计数器，Latch：门闩。通常用来控制线程等待，让某一个线程等倒计数结束再开始执行</p>
</blockquote>
<ul>
<li>CountDownLatch(int count) 指定数量的线程完成任务后，等待在Latch上的线程才能继续执行</li>
<li>CountDownLatch::countDown() 通知Latch一个线程已经完成了任务，计数器减一</li>
<li>CountDownLatch::await() 设置Latch阻止线程继续执行，直到指定数量的线程执行至此</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>循环栅栏，每若干个线程任务执行完，调用一次指定的动作</p>
</blockquote>
<ul>
<li>CyclicBarrier(int parties, Runnable barrierAction) 每若干个任务完成，执行一次barrierAction</li>
<li>CyclicBarrier::await() 设置Barrier阻止线程继续执行，直到指定数量的线程执行至此</li>
<li>BrokenBarrierException 表示当前Barrier已经破损，可能无法等待所有线程到齐。例如一个线程被中断，其它线程就会收到该异常</li>
</ul>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><blockquote>
<p>线程阻塞工具，可以在线程内任意位置让线程阻塞，不需要先获得对象锁，也不抛出InterruptedException，弥补了suspend&#x2F;resume导致线程无法继续执行的情况</p>
</blockquote>
<ul>
<li>static LockSupport::park(), parkNanos(), parkUntil() (有限)阻塞当前线程。支持中断响应，通过Thread.interrupted()获得中断标记</li>
<li>static LockSupport::unpark(thread) 类似信号量机制给予线程继续执行的许可，但许可数量仅为1</li>
</ul>
<h3 id="深度理解-AbstractQueuedSynchronizer"><a href="#深度理解-AbstractQueuedSynchronizer" class="headerlink" title="深度理解 AbstractQueuedSynchronizer"></a>深度理解 AbstractQueuedSynchronizer</h3><blockquote>
<p>重入锁、信号量内部各有一个AbstractQueuedSynchronizer的子类Sync。<br>Sync内部维护了一个同步等待队列，保存等待在这个锁上的线程，如lock()引起的等待。<br>还维护了一个条件变量等待队列，保存等待在条件变量上的等待变量，如Condition.await()引起阻塞的线程。<br>一个重入锁可以生成多个条件变量，因此可能有多个条件变量等待队列<br>AbstractQueuedSynchronizer是重入锁、信号量、读写锁等并发工具的核心</p>
</blockquote>
<h3 id="Guava-和-RateLimiter"><a href="#Guava-和-RateLimiter" class="headerlink" title="Guava 和 RateLimiter"></a>Guava 和 RateLimiter</h3><blockquote>
<p>Guava是Google的一个核心库，常用作项目的基础工具库。RateLimiter是其中的一个限流工具库<br>为了维持服务器的负载平稳，需要进行限流措施。普通的平均限流过于简单粗暴。经典的两种限流算法：</p>
<ul>
<li>漏桶算法：利用一个缓冲区，当有请求进入系统时，无论请求的速率如何，都先保存在缓存区内，然后再以固定的流速流出缓存区并加以处理。特点是无论外部请求压力如何，总是以固定的流速处理数据。漏桶容积和流出速率是该算法的两个重要参数。</li>
<li>令牌桶算法：桶中存放令牌，程序只有拿到令牌才能对请求进行处理。没有令牌则要么丢弃请求，要么等待可用令牌。该算法在单位时间产生一定量的令牌存入桶中，桶的容量有限，且令牌数不会超过桶的容量。</li>
</ul>
<p>Guava中的RateLimiter采用了令牌桶算法</p>
</blockquote>
<h2 id="线程复用-ThreadPool"><a href="#线程复用-ThreadPool" class="headerlink" title="线程复用 - ThreadPool"></a>线程复用 - ThreadPool</h2><blockquote>
<p>虽然与进程相比，线程是一种轻量级的工具，但其创建和销毁依然需要花费时间，线程过多容易导致创建和销毁的开销大于真实工作的时间，同时大量线程会抢占宝贵的内存资源，导致OOM，给GC带来压力。因此，对线程的使用需要掌握一个度。</p>
</blockquote>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为了避免系统频繁的创建和销毁线程，利用线程池技术对线程进行复用<br>线程池负责对线程进行控制和管理。其中有活跃线程，需要时直接拿来用，完成工作后不关闭，返回线程池，方便其它任务执行。</p>
<h3 id="JDK-Executor框架"><a href="#JDK-Executor框架" class="headerlink" title="JDK - Executor框架"></a>JDK - Executor框架</h3><ul>
<li>Executors 线程池工厂，返回ExecutorService (ThreadPoolExecutor) 对象，表示一个线程池<ul>
<li><code>newFixedThreadPool</code>: 返回一个固定线程数量的线程池。新任务提交时，若有空闲线程立即执行，否则暂存在任务队列中</li>
<li><code>newSingleThreadExecutor</code>: 返回只有一个线程的线程池</li>
<li><code>newCachedThreadPool</code>: 返回一个可调整线程数量的线程池。新任务提交时，优先使用可复用线程，否则创建新线程处理任务。所有线程完成后返回线程池，空闲线程有存活时间</li>
<li><code>newSingleThreadScheduledExecutor</code>: 返回一个ScheduledExecutorService对象，线程数量为1。用于实现延时、周期任务。如果中途任务出现异常，后续执行都会被中断。<ul>
<li>schedule(Runnable, delay, TimeUnit) 延迟执行任务</li>
<li>scheduleAtFixedRate(Runnable, initialDelay, period, TimeUnit) 固定速率循环执行任务。但必须等上一个任务执行完才会开始下一个</li>
<li>scheduleWithFixedDelay(Runnable, initialDelay, delay, TimeUnit) 上一个任务执行完间隔delay后开始下一个</li>
</ul>
</li>
<li><code>newScheduledThreadPool</code>: 返回一个ScheduledExecutorService对象，线程数量可指定</li>
</ul>
</li>
</ul>
<pre><code class=" mermaid">classDiagram
  Executor &lt;|-- ExecutorService
  &lt;&lt;interface&gt;&gt; Executor
  Executor: + execute(Runnable)
  &lt;&lt;interface&gt;&gt; ExecutorService
  ExecutorService: + shutdown()
  ExecutorService: + isTerminated()
  ExecutorService: + submit()
  ExecutorService: + ......()

  AbstractExecutorService ..|&gt; ExecutorService
  AbstractExecutorService &lt;|-- ThreadPoolExecutor
  ThreadPoolExecutor: +ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)
</code></pre>


<h3 id="线程池内部实现-ThreadPoolExecutor"><a href="#线程池内部实现-ThreadPoolExecutor" class="headerlink" title="线程池内部实现 - ThreadPoolExecutor"></a>线程池内部实现 - ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-type">int</span> corePoolSize,      <span class="hljs-comment">// 指定常驻线程数量</span><br>                   <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">// 指定允许的最大线程数量</span><br>                   <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">// 当线程数量超过corePoolSize后，多余的空闲线程的存活时间</span><br>                   TimeUnit unit,         <span class="hljs-comment">// keepAliveTime单位</span><br>                   BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">// 任务队列，保存被提交但尚未被执行的任务</span><br>                   ThreadFactory threadFactory,       <span class="hljs-comment">// 线程工厂，用于创建线程</span><br>                   RejectedExecutionHandler handler   <span class="hljs-comment">// 任务过多时的拒绝策略</span><br>                   )<br></code></pre></td></tr></table></figure>


<h4 id="任务队列-BlockingQueue"><a href="#任务队列-BlockingQueue" class="headerlink" title="任务队列 - BlockingQueue"></a>任务队列 - BlockingQueue</h4><p>指被提交但未执行的任务队列，一个BlockingQueue接口的对象，仅用于存放Runnable对象。常用的队列实现有：</p>
<ul>
<li><code>SynchronousQueue</code>: 直接提交的队列，没有容量，来一个任务执行一个，没有多余线程则执行拒绝策略</li>
<li><code>ArrayBlockingQueue</code>: 有界任务队列，构造时指定容量</li>
<li><code>LinkedBlockingQueue</code>: 无界任务队列，任务繁忙时会一直创建线程执行，直至资源耗尽</li>
<li><code>PriorityBlockingQueue</code>: 带有执行优先级的无界队列</li>
</ul>
<p>使用自定义线程池时，需要根据应用的具体情况，选择合适的并发队列为任务做缓冲。当线程资源紧张时，不同的并发队列对系统行为和性能的影响均不同。</p>
<pre><code class=" mermaid">graph LR
  任务提交 -- 小于corePoolSize --&gt; end1(分配线程执行)
  任务提交 -- 大于corePoolSize --&gt; 提交到等待队列 -- 成功 --&gt;等待执行
  提交到等待队列 -- 失败 --&gt; 提交线程池 -- 已达到最大线程数 --&gt; 拒绝执行
  提交线程池 -- 未达到最大线程数 --&gt; end2(分配线程执行)
</code></pre>

<h4 id="拒绝策略-RejectedExecutionHandler"><a href="#拒绝策略-RejectedExecutionHandler" class="headerlink" title="拒绝策略 - RejectedExecutionHandler"></a>拒绝策略 - RejectedExecutionHandler</h4><p>指定当任务数量超过系统实际承载能力时的策略，通常是线程池中的线程已经用完，达到了最大线程数，排队队列也已满的情况。ThreadPoolExecutor提供了以下策略：</p>
<ul>
<li><code>AbortPolicy</code>: 默认策略，丢弃并抛出RejectedExecutionException异常</li>
<li><code>CallersRunsPolicy</code>: 绕过线程池，由主线程直接调用任务的run()方法执行</li>
<li><code>DiscardOldestPolicy</code>: 抛弃队列中等待最久的任务，然后尝试再次提交当前任务</li>
<li><code>DiscardPolicy</code>: 丢弃且不抛异常</li>
</ul>
<h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 - ThreadFactory"></a>线程工厂 - ThreadFactory</h4><p>ThreadFactory接口用来创建线程，其中仅有一个方法<code>Thread newThread(Runnable r);</code><br>通常使用<code>Executors.defaultThreadFactory()</code>即可</p>
<h4 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h4><p>通过重写ThreadPoolExecutor中提供的接口对线程池进行控制</p>
<ul>
<li>ThreadPoolExecutor::beforeExecute(Thread t, Runnable r) 线程执行前</li>
<li>ThreadPoolExecutor::afterExecute(Runnable r, Throwable t) 线程执行后</li>
<li>ThreadPoolExecutor::terminated() 线程池销毁后</li>
</ul>
<h4 id="获取线程池的堆栈信息"><a href="#获取线程池的堆栈信息" class="headerlink" title="获取线程池的堆栈信息"></a>获取线程池的堆栈信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(...);<br><br><span class="hljs-comment">// 1. 用execute()替代submit()</span><br>pools.execute(task)<br><br><span class="hljs-comment">// 2. 使用Future (第五章)</span><br><span class="hljs-type">Future</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pools.submit(task)<br>result.get();<br><br><span class="hljs-comment">// 3. 扩展ThreadPoolExecutor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;&#125;<br></code></pre></td></tr></table></figure>


<h3 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h3><blockquote>
<p>Java Concurrency in Practice 一书给出了估算线程池大小的公式：<br>$$<br>N_{threads} &#x3D; N_{cpu} \times U_{cpu} \times (1 + \frac{W}{C}<br>$$<br>其中，<br>$ N_{cpu} &#x3D; CPU的数量 $<br>$ U_{cpu} &#x3D; 目标CPU的使用率0-1之间 $<br>$ \frac{W}{C} &#x3D; 等待时间与计算时间的比率 $</p>
</blockquote>
<h3 id="Fork-x2F-Join-框架"><a href="#Fork-x2F-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><blockquote>
<p>Fork: 创建子线程，使得系统进程可以多一个执行分支<br>Join: 等待分支执行结束，获得最终结果<br>ForkJoinPool 可以优化多分支任务的执行，提高效率。例如多线程的负载均衡。但如果任务的划分层次很多且一直得不到返回值，可能出现性能严重下降，或导致栈溢出，引发异常。</p>
</blockquote>
<ul>
<li>ForkJoinPool::submit(ForkJoinTask&lt;T&gt;)  向ForkJoinPool线程池提交一个ForkJoinTask (支持 fork() &#x2F; join() 的任务)</li>
<li>ForkJoinTask两个子类：RecursiveAction 和 RecursiveTask, 前者没有返回值，后者可以携带返回值</li>
</ul>
<h3 id="Guava-线程池"><a href="#Guava-线程池" class="headerlink" title="Guava 线程池"></a>Guava 线程池</h3><ul>
<li>MoreExecutors::DirectExecutor 提供了一个简单的线程池实现。该线程池不创建额外线程，总是在当前线程中执行任务。便于使用统一的编码风格处理同步和异步调用，简化设计。</li>
<li>MoreExecutors::getExitingExecutorService() 将普通线程转为Daemon线程池，从而可以在程序执行外后，即便有线程池存在，也能结束线程</li>
<li>MoreExecutors还提供了对Future模式的扩展，见第5章</li>
</ul>
<h2 id="JDK-并发容器"><a href="#JDK-并发容器" class="headerlink" title="JDK 并发容器"></a>JDK 并发容器</h2><p>大部分容器都在java.util.concurrent包中，Collections工具类可以将任意集合包装成线程安全的集合。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Collections::synchronizedMap(map)方法可以将普通map包装成线程安全的map，但是内部频繁使用mutex互斥锁，性能较低。更好的选择是juc下的ConcurrentHashMap，专门为并发进行了性能优化，更适合多线程的场合。</p>
<ul>
<li>内部数据结构<ul>
<li><code>int SizeCtl</code> 记录参与Map扩展的线程数量，或新table的扩容阈值</li>
<li><code>CounterCell[]</code> 记录元素的个数</li>
<li><code>Node&lt;K, V&gt;[] table</code> 实际存放Map内容的地方</li>
<li><code>Node&lt;K, V&gt;[] nextTable</code> 当Table需要扩容时，会把新数据填充到nextTable中</li>
</ul>
</li>
<li>节点类型<ul>
<li><code>Node</code>: 若干链表构成的数组，每个元素是链表的表头</li>
<li><code>TreeBin</code>: 当链表长度大于等于8时，会将链表树状化，变成一棵红黑树</li>
<li><code>ForwardingNode</code>: 当数组容量达到75%时，数组将进行扩容。扩容过程中已经完成复制的老数组元素用ForwardingNode对象替代，表示当前槽位数据已经处理过了，避免竞争</li>
</ul>
</li>
</ul>
<pre><code class=" mermaid">classDiagram
  Node &lt;|-- TreeNode
  Node &lt;|-- ForwardingNode
  Node &lt;|-- TreeBin
  TreeNode *-- TreeBin

  class Node &#123;
    + hash: int
    + key: K
    + val: V
    + next: Node
  &#125; 

  class TreeNode &#123;
    + parent: TreeNode
    + left: TreeNode
    + right: TreeNode
    + prev: TreeNode
    +red: boolean
  &#125;
  
  class ForwardingNode&#123;
    + nextTable: Node&lt;K, V&gt;
  &#125;

  class TreeBin &#123;
    + root: TreeNode
    + first: TreeNode
    + waiter: Thread
    + prev: TreeNode
    + red: boolean
  &#125;
</code></pre>

<ul>
<li>put()方法实现步骤<ul>
<li>尝试初始化数组</li>
<li>可能参与帮助扩容 - helpTransfer()</li>
<li>根据对应槽位是链表还是红黑树，放入给定的key、value</li>
<li>统计元素总数 - CounterCell()</li>
<li>根据是否达到负载因子，默认0.75，触发扩容操作。扩容会将一半的元素移到新空间，且相对位置不变</li>
</ul>
</li>
<li>get()方法实现步骤<ul>
<li>根据hash值得到对应槽位</li>
<li>若槽位第一个元素key和请求的一样，直接返回</li>
<li>否则调用对应的find()进行查找<ul>
<li>链表：顺序查找</li>
<li>ForwardingNode::find()</li>
<li>TreeBin::find()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>可以通过Collections.synchronizedList(new LinkedList&lt;String&gt;())得到线程安全的LinkedList。对于队列，更推荐使用ConcurrentLinkedQueue。</p>
<ul>
<li>ConcurrentLinkedQueue 使用无锁CAS保证并发安全，需要处理可能存在的不一致问题，增加了设计和实现难度，但极大提升了性能</li>
<li>head, tail分别表示链表的头、尾。但tail的更新并不是及时的，可能产生拖延，每次更新会跳跃两个元素</li>
</ul>
<blockquote>
<p>TODO: 第4章 - 无锁并发</p>
</blockquote>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>对于CopyOnWriteArrayList，不仅读完全不用加锁，写操作也不会阻塞读操作。只有写操作之间需要进行同步等待。</p>
<ul>
<li>所谓CopyOnWrite，就是在写入时，进行一次自我复制，修改时对副本进行操作，写完后再替换原本的数据，这样就保证写操作不影响读操作</li>
</ul>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>一种实现数据共享通道的接口。主要实现有ArrayBlockingQueue(有界), LinkedBlockingQueue(无界), PriorityBlockingQueue(优先级)…<br>BlockingQueue让服务线程在队列为空时进行等待，有新消息进入队列后，自动将线程唤醒</p>
<p>以ArrayBlokcingQueue为例：</p>
<ul>
<li>压入元素：offer()和put()，队满时offer()立即返回false，而put()会一直等待，直到有空闲位置</li>
<li>弹出元素：poll()和take()，队空时poll()返回null，而take()会一直等待，直到有可用元素</li>
<li>物理上是一个数组，逻辑上是一个环形结构，每次入队和出队都会调整队头和队尾两个索引的位置</li>
</ul>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><ul>
<li>跳表是一种快速查找数据的数据结构，类似平衡树。但在高并发下，平衡树调整平衡需要一个全局锁，而跳表只需要对局部加锁，因此性能更高。</li>
<li>跳表分层维护多个链表，每个链表都是有序的，且上层链表都是下层链表元素的子集。不同于哈希map，跳表在插入时随机插入，但会维护有序性</li>
<li>跳表是一种使用空间换时间的算法，查询的时间复杂度为$O(logn)$</li>
<li>ConcurrentSkipListMap使用CAS对Node操作，保证并发安全</li>
</ul>
<h2 id="JMH-性能测试"><a href="#JMH-性能测试" class="headerlink" title="JMH 性能测试"></a>JMH 性能测试</h2><p>一个专门用于性能测试的框架，基本概念：</p>
<ol>
<li>模式 Mode<ul>
<li>Throughput: 整体吞吐量，1s内可执行调用次数</li>
<li>AverageTime: 调用的平均时间</li>
<li>SampleTime: 随机取样，最后输出取样结果的分布</li>
<li>SingleShotTime: 运行一次时间，通常测试冷启动时的性能</li>
</ul>
</li>
<li>迭代 Iteration<ul>
<li>JMH一次测量单位，通常为1s</li>
</ul>
</li>
<li>预热 Warmup<ul>
<li>由于JVM的JIT机制，编译前后的效率不同，通常只考虑JIT编译后的性能</li>
</ul>
</li>
<li>状态 State<ul>
<li>指定对象作用范围</li>
<li>Scope.Thread 一个对象仅被一个线程访问</li>
<li>Scope.Benchmark 多个线程共享一个实例</li>
</ul>
</li>
<li>配置类 Options&#x2F;OptionsBuilder<ul>
<li>对测试进行配置，指定一些参数，如测试类、进程个数、预热迭代次数</li>
</ul>
</li>
</ol>
<hr>
<h1 id="第-4-章-锁优化"><a href="#第-4-章-锁优化" class="headerlink" title="第 4 章 - 锁优化"></a>第 4 章 - 锁优化</h1><p>锁是最常用的同步方法之一，对于多核CPU实现多线程可以明显提高系统的性能，但也会增加额外的开销，高并发环境下，激烈的锁竞争会导致程序的性能下降。因此，必须合理设计并发。</p>
<h2 id="提高锁性能"><a href="#提高锁性能" class="headerlink" title="提高锁性能"></a>提高锁性能</h2><ul>
<li>减少锁持有时间：只在必要时进行同步，有助于降低锁冲突的可能性，进而提高系统吞吐量</li>
<li>减小锁粒度：通过分割数据结构，缩小锁定对象的范围，降低锁冲突的可能性</li>
<li>用读写分离锁替换独占锁：在读多写少的场合可以有效提升系统并发能力</li>
<li>锁分离：读写锁的进一步延申，分割系统功能点，实现不同功能的可并发</li>
<li>锁粗话：对于一连串的锁请求和锁释放，尽量整合成单次锁请求，尤其是循环内的锁请求</li>
</ul>
<h2 id="JVM-的锁优化"><a href="#JVM-的锁优化" class="headerlink" title="JVM 的锁优化"></a>JVM 的锁优化</h2><ul>
<li>锁偏向：<ul>
<li>如果一个线程获得了锁，锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作</li>
<li>适合几乎没有锁竞争的场合，节省了大量有关锁请求的操作，提高程序性能</li>
<li>但如果锁竞争激烈，每次都是不同线程请求锁，偏向模式就会失效，性能反而会下降</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li>如果锁偏向失效，JVM并不会立即挂起线程。，而是使用轻量级锁</li>
<li>即简单地将对象头部作为指针指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁</li>
<li>线程若成功获得轻量级锁，则顺利进入临界区。反之，当前线程就会膨胀为重量级锁</li>
</ul>
</li>
<li>自旋锁：<ul>
<li>锁膨胀后，为了避免真的挂起线程，JVM尝试让当前线程做几个空循环</li>
<li>若干循环后，如果可以得到锁，则进入临界区，节省了线程挂起的巨大开销</li>
<li>如果还是不能获得锁，就真的将线程在OS层面挂起</li>
</ul>
</li>
<li>锁消除：<ul>
<li>JVM在JIT编译时，基于逃逸分析，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁</li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li>为每一个线程分配一个独立的线程局部对象，只有当前线程可访问。因此自然是线程安全的</li>
<li>ThreadLocal::set(), ThreadLocal::get()</li>
<li>实现上，Thread::ThreadLocal::ThreadLocalMap使用弱引用保存各个线程的局部变量，key是ThreadLocal对象，value是局部变量</li>
<li>如果共享对象对于竞争的处理容易引起性能损失，就应该考虑使用ThreadLocal为每个线程分配单独的对象</li>
<li>ThreadLocalRandom继承自Random，使用Unsafe，让每个线程维护自己的种子变量，不存在竞争，优化了高并发环境中随机数的产生效率</li>
</ul>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><blockquote>
<p>锁是一种悲观的策略，它总是假设每一次的临界区操作都会产生冲突，因此会阻塞线程，牺牲性能。<br>而无锁是一种乐观的策略，它假设对资源的访问是没有冲突的，所有线程都可以在不停顿的状态下持续执行。</p>
</blockquote>
<h3 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h3><p>CAS比较交换是无锁策略的一种典型实现方式，更新规则如下：<br>$$ CAS(V, E, N)，其中V：要更新的变量， E：预期值， N：新值$$</p>
<ul>
<li>仅当V值等于E值时，才会更新V为N，否则说明已经有其它线程更新了V</li>
<li>CAS返回当前V的真实值</li>
<li>CAS无锁方式，对死锁天然免疫，没有锁竞争带来的开销，也没有线程间频繁调度的开销，因此比基于锁的方式拥有更优越的性能</li>
</ul>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><ul>
<li>JUC下的atomic包中，实现了一些直接使用CAS的线程安全的类型，如AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference…</li>
<li><code>AtomicInteger::getAndSet(newVal), AtomicInteger::getAndIncrement(), AtomicInteger::addAndGet(delta)...</code></li>
<li>内部使用UnSafe类实现更新</li>
</ul>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><ul>
<li><p>封装了一些类似指针的操作，例如根据偏移量获得&#x2F;设置对应位置上的数据</p>
<pre><code class="hljs">public final native boolean compareAndSetInt(Object o, long offset, int expected, int x)
- offset是对象内的偏移量，即一个字段到对象头部的偏移
</code></pre>
</li>
<li><p><code>UnSafe::objectFieldOffset(Field f)</code> 获取指定字段相对于对象内存地址的偏移量valueOffset</p>
</li>
<li><p><code>Unsafe::putIntVolatile(object, offset, x)...</code></p>
</li>
<li><p>UnSafe仅可由JDK内部 (Bootstrap Class Loader) 使用，App Loader无法加载</p>
</li>
</ul>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><blockquote>
<p>ABA问题：CAS操作存在的一个问题，如果在A线程修改对象之前，B线程连续修改了两次对象，且修改后仍是原值，那么A线程就无法知道这是已经被修改过的对象。对于一些需要过程状态信息的对象，就可能产生异常。</p>
</blockquote>
<ul>
<li>AtomicReference无法解决ABA问题，根本原因在于对象值本身与状态画上了等号，对象在修改过程中丢失了状态信息</li>
<li>AtomicStampedReference通过在内部额外维护一个时间戳来表示状态值，解决ABA问题。当设置对象值时，仅当对象值和时间戳都满足期望值才会写入</li>
<li><code>AtomicStampedReference::compareAndSet(expectedReference, newReference, exptectedStamp, newStamp)</code></li>
<li><code>AtomicStampedReference::getReference(), AtomicStampedReference::getStamp()</code></li>
</ul>
<h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><ul>
<li>对数组的原子性操作封装，使用Unsafe类通过CAS方式保障int[]在多线程下的安全性</li>
<li>除AtomicIntegerArray外，还有AtomicLongArray, AtomicReferenceArray, 共三个</li>
<li><code>AtomicIntegerArray::compareAndSet(int i, int expect, int update)</code> 其中i是数组下标</li>
</ul>
<h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><ul>
<li>可以在几乎不改动原有代码的基础上，让普通的变量具有线程安全性</li>
<li>除AtomicIntegerFieldUpdater外，还有AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, 共三个</li>
<li><code>AtomicIntegerFieldUpdater::newUpdater(Class, fieldName)</code></li>
<li>注意事项：<ul>
<li>Updater使用反射，只能修改它可见范围内的变量</li>
<li>变量必须用volatile修饰</li>
<li>由于CAS通过Unsafe::objectFieldOffset()得到对象中的偏向量直接赋值，因此不支持static字段</li>
</ul>
</li>
</ul>
<h3 id="SychronousQueue的实现"><a href="#SychronousQueue的实现" class="headerlink" title="SychronousQueue的实现"></a>SychronousQueue的实现</h3><ul>
<li>内部维护一个线程等待队列，对SychronousQueue的任何一次读操作都需要等待一个写操作，反之亦然。因此更像是一个数据交换通道</li>
<li>内部将put(), take()两种功能抽象为一个共同的方法Transfer::transfer(Object e, timed, nanos)<ul>
<li>对象e非空时，表示当前操作传递给一个消费者，为空则表示当前操作需要请求一个数据。</li>
<li>返回值非空表示数据已经被接收或正常提供，否则表示失败，出现超时或中断</li>
</ul>
</li>
</ul>
<h2 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h2><blockquote>
<p>死锁就是两个或者多个线程互相占用对方需要的资源，导致彼此之间互相等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在。</p>
</blockquote>
<ul>
<li>经典问题 – 哲学家就餐问题</li>
<li>要避免死锁，除了使用无锁函数外，可以利用重入锁的中断或限时等待</li>
</ul>
<hr>
<h1 id="第-5-章-并行模式与算法"><a href="#第-5-章-并行模式与算法" class="headerlink" title="第 5 章 - 并行模式与算法"></a>第 5 章 - 并行模式与算法</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>一种对象创建模式，用于产生一个对象的具体实例，可以确保系统中一个类只产生一个实例</li>
<li>好处：<ul>
<li>省略new操作花费的时间</li>
<li>减轻GC压力，缩短GC停顿时间</li>
</ul>
</li>
<li>实现：<ol>
<li><p>饿汉方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Singleton is create&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 私有且静态。类初始化时即创建</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>懒汉方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;LazySingleton is create&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">lazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 第一次调用时才初始化instance</span><br>  <span class="hljs-comment">// 为了防止对象被多次创建，必须用synchronized进行同步</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> sychronized LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>结合方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticSingleton</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">StaticSingleton</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;StaticSingleton is create&quot;</span>);<br><br>    <span class="hljs-comment">// 巧妙使用内部类和类的初始化机制</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StaticSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticSingleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><ul>
<li>使用不可改变的对象，可以确保其在没有同步操作的多线程环境中依然保持内部状态的一致性和正确性。因此可以去除同步操作，提高并行性能</li>
<li>主要使用场景：<ul>
<li>对象创建后，其内部状态和数据不再发生任何变化</li>
<li>对象需要被共享，被多线程频繁访问</li>
</ul>
</li>
<li>Java实现不变模式：<ul>
<li>去除setter()方法及修改自身属性的方法</li>
<li>所有属性设为私有，并用final标记，确保其不可修改</li>
<li>确保没有子类可以重载修改它的行为</li>
<li>有一个可以创建完整对象的构造函数</li>
</ul>
</li>
<li>JDK 中不变模式应用非常广泛，例如String, Boolean, Byte, Long…等等元数据类、包装类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不变模式实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;  <span class="hljs-comment">// 确保无子类</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String no;    <span class="hljs-comment">// 私有，final</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> price;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Product</span><span class="hljs-params">(String no, String name, <span class="hljs-type">double</span> price)</span>&#123; <span class="hljs-comment">// 创建对象时必须指定数据</span><br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.no = no;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.price = price;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> no;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> price;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者 - 消费者模式"></a>生产者 - 消费者模式</h2><ul>
<li>经典的多线程设计模式，为多线程间的协作提供了良好的解决方案</li>
<li>两类线程，若干生产者线程负责提交用户请求，若干消费者线程负责具体处理生产者提交的任务。</li>
<li>生产者和消费者之间通过内存缓冲区进行通信，缓解性能差</li>
<li>无锁CAS的实现框架 - Disruptor<ul>
<li>使用环形队列，快速定位元素位置，充分复用内存</li>
<li>监控策略：Blocking, Sleeping, Yielding, BusySpin</li>
<li>CPU Cache 优化，解决缓存行伪共享</li>
</ul>
</li>
</ul>
<h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>Future模式是多线程开发中非常常见的一种设计模式，核心思想是异步调用。Future模式让被调用者立即返回，并在后台处理请求，对于调用者可以先处理其它任务，在真正需要数据的场合再尝试获得需要的数据。</p>
<ul>
<li>JUC 提供了Future模式的封装。<ul>
<li>FutureTask(Callable) 用Callable接口的对象构造FutureTask</li>
<li>FutureTask::get() 获取call()方法的结果，如果call()尚未完成则等待</li>
<li>FutureTask::cancel(), FutureTask::isDone(), FutureTask::get(timeout, timeunit)…</li>
</ul>
</li>
<li>Guava库对Future增加了通知功能以及异常处理，能够在任务完成&#x2F;失败时自动回调，从而不阻塞主线程</li>
</ul>
<h2 id="并行流水线"><a href="#并行流水线" class="headerlink" title="并行流水线"></a>并行流水线</h2><blockquote>
<p>执行过程中有数据相关性的运算都是无法完美并行的，但是可以借用流水线的思想，拆分步骤，将有依赖关系的操作分配在不同的线程中进行计算，尽可能利用多核的优势。通常需要一个中间消息传递队列，例如BlockingQueue</p>
</blockquote>
<h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><blockquote>
<p>将原始数据集合按照期望的线程数进行分割，每个线程各自独立搜索，当其中一个线程找到数据后，立即返回结果即可</p>
</blockquote>
<h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><blockquote>
<p>奇偶交换排序：分两阶段，奇交换总是比较奇数索引及其相邻的后续元素，偶交换总是比较偶数索引及其相邻的后续元素。且奇交换和偶交换成对出现，保证比较涉及每一个元素。可以利用多线程对每一次元素比较和交换进行操作。</p>
<p>希尔排序：将整个数组根据间隔h分割为若干个子数组，利用多线程分别对每一个子数组进行排序，每一组排序完成后递减h的值，进行下一轮更加精细的排序，直到h为1。</p>
</blockquote>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><blockquote>
<p>利用矩阵分割+多线程实现矩阵乘法的并行化</p>
</blockquote>
<h2 id="网络-NIO"><a href="#网络-NIO" class="headerlink" title="网络 NIO"></a>网络 NIO</h2><blockquote>
<p>Java NIO 涉及通道Channel、缓冲区Buffer、文件IO、网络IO等。NIO可以将网络IO等待时间从线程中抽离，主要涉及Selector, SocketChannel等API。</p>
</blockquote>
<h2 id="异步-AIO"><a href="#异步-AIO" class="headerlink" title="异步 AIO"></a>异步 AIO</h2><blockquote>
<p>NIO在网络操作中提供了非阻塞的方法，但IO行为还是同步的。而AIO不是在IO准备好时再通知线程，而是在IO操作完成后，再给线程发出通知，因此AIO完全不会阻塞。主要涉及AsynchronousServerSocketChannel, CompletionHandler等API。</p>
</blockquote>
<hr>
<h1 id="第-6-章-Java-8-x2F-9-x2F-10-与并发"><a href="#第-6-章-Java-8-x2F-9-x2F-10-与并发" class="headerlink" title="第 6 章 - Java 8&#x2F;9&#x2F;10 与并发"></a>第 6 章 - Java 8&#x2F;9&#x2F;10 与并发</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li>特征：<ul>
<li>可以将函数作为参数传递给另一个函数</li>
<li>一个函数可以作为另一个函数的返回值</li>
<li>限制函数副作用 (不修改全局变量&#x2F;外部状态)<ul>
<li>显式函数：函数与外界交换数据的唯一渠道就是参数和返回值，不会读取或修改外部状态。利于调试和排错</li>
<li>隐式函数：与之相反。不利于调试和跟踪</li>
</ul>
</li>
<li>声明式，不需要再提供明确的指令操作</li>
<li>几乎所有对象都是不变的</li>
<li>易于并行，提高性能</li>
<li>代码量精简</li>
</ul>
</li>
<li>FunctionalInterface 注释<ul>
<li>只定义了单一抽象方法的接口 (Object实现的方法除外)</li>
<li>可以存在实例方法&#x2F;默认方法</li>
</ul>
</li>
<li>Lambda 表达式<ul>
<li>匿名函数，没有函数名的函数体</li>
<li>可以直接作为参数传递给相关的调用者</li>
</ul>
</li>
<li>方法引用<ul>
<li>精简Lambda表达式的手段，通过类名&#x2F;实例名，以及方法名定位一个静态&#x2F;实例方法</li>
<li><code>ClassName::method, instance::method, Class::new, TypeName[]::new</code>等等</li>
<li>Java会自动识别流中元素是作为调用目标还是调用方法的参数</li>
</ul>
</li>
</ul>
<h2 id="并行流与并行排序"><a href="#并行流与并行排序" class="headerlink" title="并行流与并行排序"></a>并行流与并行排序</h2><ul>
<li>stream.parallel()</li>
<li>list.parallelStream()</li>
<li>Arrays.parallelSort(arr)</li>
<li>Arrays.parallelSetAll(arr, generator)</li>
<li>……</li>
</ul>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul>
<li>继承自CompletionStage接口，实现了40多种方法，用于函数式编程的流式调用</li>
<li><code>CompletableFuture::complete()</code> 告知完成状态</li>
<li><code>CompletableFuture::get()</code> 获取执行结果，未完成则阻塞。可用于阻止主线程直接退出</li>
<li><code>CompletableFuture::supplyAync(supplier, [executor])</code> 异步调用，可指定线程池，默认在ForkJoinPool.common线程池中作为Daemon线程执行</li>
<li><code>CompletableFuture::runAync(runnable, [executor])</code> 同上，但不需要返回值</li>
<li><code>CompletableFuture::thenApply(function)</code> 转换结果</li>
<li><code>CompletableFuture::thenAccept(consumer)</code> 消费结果</li>
<li><code>CompletableFuture::thenRun(Runnable)</code> 任务完成后的回调</li>
<li><code>CompletableFuture::thenCompose(function)</code> 组合多个CompletableFuture</li>
<li><code>CompletableFuture::thenCombine(completionStage)</code> 组合多个CompletableFuture，并将执行结果传递给一个BiFunction</li>
<li><code>CompletableFuture::orTimeout(time, TimeUnit)</code> </li>
<li><code>CompletableFuture::exceptionally(function)</code> 异常处理</li>
</ul>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><ul>
<li>读写锁的改进版本，提供了一种乐观的读策略，增加了系统的并行度</li>
<li>内部实现基于CLH，一种自旋锁，维护一个等待线程队列，每个节点保存一个标记位用于判断当前线程是否已经释放锁。保证没有饥饿，以及FIFO的服务顺序。</li>
<li>小陷阱：实现上使用Unsafe.park()挂起线程，因此在遇到线程中断时会重新进入循环，导致疯狂CPU占用</li>
</ul>
<h2 id="原子类增强"><a href="#原子类增强" class="headerlink" title="原子类增强"></a>原子类增强</h2><ul>
<li>LongAdder<ul>
<li>将核心value数据分离成一个数组cells，减小锁粒度，降低多线程竞争。最终的计数结果为这个数组的求和累加</li>
</ul>
</li>
<li>LongAccumulator<ul>
<li>在LongAdder基础上，可以实现任意函数操作</li>
</ul>
</li>
</ul>
<h2 id="ConcurrentHashMap-增强"><a href="#ConcurrentHashMap-增强" class="headerlink" title="ConcurrentHashMap 增强"></a>ConcurrentHashMap 增强</h2><ul>
<li>foreach</li>
<li>reduce</li>
<li>computeIfAbsent 条件插入</li>
<li>search</li>
<li>mappingCount 以long型返回map条目数，并发情况下不准确</li>
<li>newKeySet 返回一个线程安全的Set (JDK中Set的实现依赖于Map)</li>
</ul>
<h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><blockquote>
<p>反应式编程用于处理异步流中的数据。核心组件包括发布者、订阅者。<br>发布者将数据发布到流中，订阅者则负责处理这些数据。<br>涉及API：JUC.Flow.Subscriber, JUC.Flow.Subscription, JUC.SubmissionPublisher;</p>
</blockquote>
<h1 id="第-7-章-Akka构建高并发程序"><a href="#第-7-章-Akka构建高并发程序" class="headerlink" title="第 7 章 - Akka构建高并发程序"></a>第 7 章 - Akka构建高并发程序</h1><blockquote>
<p>Akka提供了一种名为Actor的并发模型，其粒度比线程小，因此可以在系统中启用大量的Actor<br>Akka提供了一套容错机制，允许在Actor出现异常时进行一些恢复或者重复操作<br>Akka不仅可以在单机上构架高并发程序，也可以在网络中构建分布式程序，并提供位置透明的Actor定位服务</p>
<p>粒子群算法：一种进化算法，用于求解优化问题，通常可以得到一个局部最优解。<br>背景：鸟类觅食表现出群体特性，鸟群往往会聚集在一堆食物旁觅食。如果其中一只鸟发现另外一堆更丰盛的食物，就很可能会离群飞向更丰盛的食物，而这有可能带动整个鸟群一起飞向新的地点。这个迁移过程中会存在于一些小鸟叛逆，不跟着种群走，可能会发现更丰盛的食物堆。这样反复迭代，最终将找到一个相当丰盛的食物堆。</p>
</blockquote>
<h1 id="第-8-章-并行调试"><a href="#第-8-章-并行调试" class="headerlink" title="第 8 章 - 并行调试"></a>第 8 章 - 并行调试</h1><blockquote>
<p>null</p>
</blockquote>
<h1 id="第-9-章-Jetty代码分析"><a href="#第-9-章-Jetty代码分析" class="headerlink" title="第 9 章 - Jetty代码分析"></a>第 9 章 - Jetty代码分析</h1><blockquote>
<p>Jetty是一个基于Java实现的免费HTTP服务器和Servlet容器，成为与Tomcat齐名的、使用最广泛的Java Web容器之一。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/">#并发</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java-并发</div>
      <div>https://chanpero.github.io/2022/11/20/Java-并发/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>chanper</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/03/MySQL-%E7%AC%94%E8%AE%B0/" title="MySQL-笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL-笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板">
                        <span class="hidden-mobile">算法模板</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'chanpero/commit-utterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
