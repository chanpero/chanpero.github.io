

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Myfavicon.ico">
  <link rel="icon" href="/img/Myfavicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="chanper">
  <meta name="keywords" content="">
  
    <meta name="description" content="《深入理解Java虚拟机》 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-虚拟机">
<meta property="og:url" content="https://chanpero.github.io/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name">
<meta property="og:description" content="《深入理解Java虚拟机》 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chanpero.github.io/img/java.png">
<meta property="article:published_time" content="2022-10-25T08:00:00.000Z">
<meta property="article:modified_time" content="2022-12-31T06:44:47.015Z">
<meta property="article:author" content="chanper">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://chanpero.github.io/img/java.png">
  
  
  
  <title>Java-虚拟机 </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"chanpero.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"e6fbf52343bffac933f91eae00e480dc","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"1InH4XckKf2mHSUQuLHRajZH-gzGzoHsz","app_key":"jDwLBVwoqcNPXW57ymIDicVB","server_url":"https://1inh4xck.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?e6fbf52343bffac933f91eae00e480dc";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>chanper</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" false
     style="background: url('/img/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java-虚拟机"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-25 16:00" pubdate>
          2022年10月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          37k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          306 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java-虚拟机</h1>
            
            
              <div class="markdown-body">
                
                <p>《深入理解Java虚拟机》 学习笔记</p>
<span id="more"></span>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book">https://github.com/fenixsoft/jvm_book</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/TangBean/understanding-the-jvm">https://github.com/TangBean/understanding-the-jvm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/starjuly/UnderstandingTheJVM">https://github.com/starjuly/UnderstandingTheJVM</a></li>
</ul>
<h1 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 - Java内存区域与内存溢出异常"></a>第二章 - Java内存区域与内存溢出异常</h1><h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.svg" srcset="/img/loading.gif" lazyload class="" title="图2-1 Java虚拟机运行时数据区">

<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器</li>
<li>字节码解释器通过改变该计数器的值来选取吓一跳需要执行的字节码指令</li>
<li>线程私有，各线程之间计数器互不影响，独立存储</li>
<li>不会产生 <code>OutOfMemoryError</code></li>
</ul>
<h3 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2 虚拟机栈"></a>2.2.2 虚拟机栈</h3><ul>
<li>每执行一个方法，虚拟机同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
<li>一个方法的执行到结束，对应着一个栈帧在虚拟机中从入栈到出栈的过程</li>
<li>局部变量表<ul>
<li>存放编译期可知的基本数据类型、对象引用、returnAddress</li>
<li>所需空间在编译期间完成分配</li>
<li>以局部变量槽Slot来表示</li>
</ul>
</li>
<li>线程私有，生命周期与线程相同</li>
<li><code>StackOverflowError</code> (栈深度溢出) &#x2F; <code>OutOfMemoryError</code> (内存请求失败)</li>
</ul>
<h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h3><ul>
<li>类似虚拟机栈，不过是为虚拟机使用到的Native方法服务(如C, Cpp)</li>
<li><code>StackOverflowError</code> &#x2F; <code>OutOfMemoryError</code></li>
</ul>
<h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><ul>
<li>虚拟机管理的最大内存区，负责存放对象实例</li>
<li>由垃圾收集器GC管理</li>
<li>线程共享 (可以划分线程私有的分配缓冲区TLAB)</li>
<li><code>OutOfMemoryError</code></li>
</ul>
<h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><ul>
<li>存储已被虚拟机加载的类型信息、常量、静态变量、代码缓存等数据</li>
<li>类信息：<ul>
<li>即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>存放编译期生成的各种字面量(<code>static final</code>)与符号引用</li>
</ul>
</li>
<li>线程共享</li>
<li><code>OutOfMemoryError</code></li>
</ul>
<h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><ul>
<li>不属于JVM运行时数据区</li>
<li>如使用Native函数库直接分配堆外内存(JDK1.4-NIO)</li>
<li><code>OutOfMemoryError</code></li>
</ul>
<h2 id="2-3-HotSpot虚拟机对象"><a href="#2-3-HotSpot虚拟机对象" class="headerlink" title="2.3 HotSpot虚拟机对象"></a>2.3 HotSpot虚拟机对象</h2><h3 id="2-3-1-对象创建"><a href="#2-3-1-对象创建" class="headerlink" title="2.3.1 对象创建"></a>2.3.1 对象创建</h3><ul>
<li>步骤：<ul>
<li>遇到new指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已被加载、加载、解析和初始化，如果没有必须先执行相应类的加载过程</li>
<li>加载检查通过后，为新生对象分配内存</li>
<li>内存分配完成后，JVM将该内存空间初始化为0</li>
<li>JVM对对象进行必要设置，例如元类型信息、HashCode、GC分代年龄等(存储在对象头中)</li>
<li>JVM对象已产生，接着开始执行对象的构造方法 &lt;init&gt;()</li>
<li>这样一个真正可用的对象被完全构造出来</li>
</ul>
</li>
<li>分配内存方法：<ul>
<li>碰撞指针: 使用过的内存放一边，空闲的放另一边，中间用指针分隔。分配内存就是移动指针。内存分配规整</li>
<li>空闲列表：维护可用内存块的记录表，分配内存时修改记录。内存分配不规整</li>
</ul>
</li>
<li>解决并发：<ul>
<li><code>CAS</code> 同步：Compare And Swap 保证更新的原子性 </li>
<li><code>TLAB</code> 本地线程分配缓冲：线程私有的分配缓冲区</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h3><ul>
<li>对象头<ul>
<li><code>Mark Word</code>: 存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态、偏向信息等</li>
<li><code>kClass Pointer</code>: 类型指针，对象指向它的类型元数据的指针</li>
</ul>
</li>
<li>实例数据：对象真正存储的有效信息<ul>
<li>默认分配顺序：longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops(Ordinary Object Pointers)</li>
<li>相同宽度的字段会被分配在一起，除了oops，其他的长度由长到短</li>
<li>满足上述条件下，父类定义变量在子类变量之前</li>
<li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li>
<li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li>
</ul>
</li>
<li>对齐填充：8Byte整数倍</li>
</ul>
<h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3 对象的访问定位"></a>2.3.3 对象的访问定位</h3><ul>
<li><p>Java通过栈上的reference来操作堆上的具体对象，实现方式主要以下两种</p>
</li>
<li><p>句柄访问</p>
<ul>
<li>Java堆中划分一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含对象实例数据和类型数据的具体地址</li>
<li>好处：reference存储的是稳定句柄，移动对象时不需要改变reference<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" srcset="/img/loading.gif" lazyload class="" title="对象的访问定位_直接指针访问.png"></li>
</ul>
</li>
<li><p>直接指针</p>
<ul>
<li>reference直接存储对象地址，但需要考虑如何存放类型数据的相关信息</li>
<li>好处：速度快，减少一次指针定位的时间开销<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" srcset="/img/loading.gif" lazyload class="" title="对象的访问定位_直接指针访问.png"></li>
</ul>
</li>
</ul>
<h2 id="2-4-实战内存区异常"><a href="#2-4-实战内存区异常" class="headerlink" title="2.4 实战内存区异常"></a>2.4 实战内存区异常</h2><ul>
<li>VMArgs: <ul>
<li><code>-Xms20m</code> 最小堆大小</li>
<li><code>-Xmx20m</code> 最大堆大小</li>
<li><code>-Xss128k</code> 栈内存大小</li>
<li><code>-XX:MaxDirectMemorySize=10M</code> 直接内存大小</li>
<li><code>-XX:+/-UseTLAB</code> 是否使用TLAB</li>
<li><code>--XX:FieldsAllocationStyle</code> 控制变量分配策略</li>
<li><code>--XX:CompactFields</code> 控制是否允许较窄变量插入父类变量的间隙</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code> 内存溢出异常时Dump出当前内存堆转储快照</li>
</ul>
</li>
</ul>
<h3 id="2-4-1"><a href="#2-4-1" class="headerlink" title="2.4.1"></a>2.4.1</h3><pre><code class="hljs">Java堆溢出：不断new新对象
</code></pre>
<h3 id="2-4-2"><a href="#2-4-2" class="headerlink" title="2.4.2"></a>2.4.2</h3><pre><code class="hljs">虚拟机栈溢出：无限方法递归
</code></pre>
<h3 id="2-4-3"><a href="#2-4-3" class="headerlink" title="2.4.3"></a>2.4.3</h3><pre><code class="hljs">运行时常量池溢出：String::intern 不断向常量池添加字符串
方法区溢出：CGLib代理生成大量的类
</code></pre>
<h3 id="2-4-4"><a href="#2-4-4" class="headerlink" title="2.4.4"></a>2.4.4</h3><pre><code class="hljs">直接内存溢出：Unsafe类分配内存
</code></pre>
<h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 - 垃圾收集器与内存分配策略"></a>第三章 - 垃圾收集器与内存分配策略</h1><h2 id="3-2-对象存活判断"><a href="#3-2-对象存活判断" class="headerlink" title="3.2 对象存活判断"></a>3.2 对象存活判断</h2><h3 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h3><ul>
<li>在对象中添加一个引用计数器</li>
<li>每当有一个地方引用它，计数器值+1</li>
<li>当引用失效时，计数器值-1</li>
<li>任何时刻计数器为0的对象就是不可能再被使用的</li>
</ul>
<p>缺陷：</p>
<ul>
<li>难以解决对象间相互循环引用的问题，因此现在基本很少使用</li>
</ul>
<h3 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h3><ul>
<li>从根节点<code>GC Roots</code>出发, 根据引用关系向下搜索，搜索过程称为引用链</li>
<li>如果某个对象到<code>GC Roots</code>间没有任何引用链相连，则此对象不可达，即可回收</li>
</ul>
<p><strong>GC Roots</strong>对象：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
<li>JVM内部的引用</li>
<li>所有被同步锁<code>synchronized</code>持有的对象</li>
<li>反映JVM内部情况的<code>JMXBean</code>、<code>JVMTI</code>等等</li>
</ul>
<h3 id="3-3-3-引用分类"><a href="#3-3-3-引用分类" class="headerlink" title="3.3.3 引用分类"></a>3.3.3 引用分类</h3><ul>
<li>强引用<code>Strongly Reference</code>：任何情况下，强引用关系存在，就不会回收此对象，如引用赋值</li>
<li>软引用<code>Soft Reference</code>：描述有用但非必须的对象。系统在发生内存溢出异常前，会二次回收这些对象</li>
<li>弱引用<code>Weak Reference</code>：描述非必须对象，弱于软引用。对象只能生存到下一次垃圾收集发生为止</li>
<li>虚引用<code>PhantomReference</code>：也叫幻影引用。为一个对象设置虚引用关联的唯一目的是为了在这个对象被回收时收到一个系统通知</li>
</ul>
<h3 id="3-2-4-是否finalize"><a href="#3-2-4-是否finalize" class="headerlink" title="3.2.4 是否finalize()"></a>3.2.4 是否finalize()</h3><ul>
<li>回收对象需要经历两次标记过程</li>
<li>首先进行可达性分析，判断是否与<code>GC Roots</code>存在相连接的引用链</li>
<li>接着筛选是否需要执行<code>finalize()</code>，如果对象没有覆盖<code>finalize()</code>或者已被JVM调用过，则不需回收</li>
<li>任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次</li>
</ul>
<h3 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h3><ul>
<li>方法区垃圾收集的”性价比”通常较低</li>
<li>主要回收废弃的常量和不再使用的类型，条件包括：<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的类加载器已被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</li>
</ul>
</li>
</ul>
<h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h2><h3 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h3><ul>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ul>
<p>因此，JVM GC的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(熬过垃圾收集过程的次数)分配到不同的区域之中存储。</p>
<ul>
<li>新生代：每次垃圾收集都会有大批对象死去</li>
<li>老年代：新生代中每次回收后存活的少量对象，将会逐步晋升到老年代</li>
<li>跨代引用假说：新生代对象可能被老年代所引用。跨代引用相对于同代引用仅占极少数</li>
</ul>
<p>垃圾收集分类: </p>
<ul>
<li>部分收集 <code>Partial GC</code><ul>
<li>新生代收集 <code>Minor GC</code></li>
<li>老年代收集 <code>Major GC</code></li>
<li>混合收集 <code>Mixed GC</code></li>
</ul>
</li>
<li>整堆收集 <code>Full GC</code></li>
</ul>
<h3 id="3-3-2-标记——清除算法-Mark-Sweep"><a href="#3-3-2-标记——清除算法-Mark-Sweep" class="headerlink" title="3.3.2 标记——清除算法 Mark-Sweep"></a>3.3.2 标记——清除算法 Mark-Sweep</h3><ul>
<li>过程：<ul>
<li>标记：首先标记出需要回收的对象</li>
<li>清除：标记完成后，统一回收被标记的对象</li>
</ul>
</li>
<li>缺点：<ul>
<li>两个过程的执行效率都随对象数量增长而降低</li>
<li>内存空间的碎片化问题<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload class="" title="alt 标记清除算法"></li>
</ul>
</li>
</ul>
<h3 id="3-3-3-标记-整理算法-Mark-Copy"><a href="#3-3-3-标记-整理算法-Mark-Copy" class="headerlink" title="3.3.3 标记-整理算法 Mark-Copy"></a>3.3.3 标记-整理算法 Mark-Copy</h3><ul>
<li><p>半区复制 Semispace Copying</p>
<ul>
<li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li>
<li>当一块内存用完，就将还存活的对象复制到另一块上面，然后把已使用的内存块一次清理掉</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>将可用内存缩小为原来的一半<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload class="" title="alt 标记复制算法"></li>
</ul>
</li>
<li><p>改进 —— Appel式回收</p>
<ul>
<li>新生代划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配只是用<code>Eden</code>和其中一块<code>Survivor</code></li>
<li>GC时，将<code>Eden</code>和<code>Survivor</code>中存活对象一次性复制到另一块<code>Survivor</code>，然后清理<code>Eden</code>和原先的<code>Survivor</code></li>
<li>HotSpot中<code>Eden</code>与<code>Survivor</code>默认大小比例是8:1</li>
<li>逃生门设计：当<code>Survivor</code>不足以容纳一次GC的存活对象时，需要依赖其它内存区域(如老年代)进行分配担保</li>
</ul>
</li>
</ul>
<h3 id="3-3-4-标记-整理算法-Mark-Compact"><a href="#3-3-4-标记-整理算法-Mark-Compact" class="headerlink" title="3.3.4 标记-整理算法 Mark-Compact"></a>3.3.4 标记-整理算法 Mark-Compact</h3><ul>
<li>主要针对老年区，是一种移动式算法</li>
<li>过程<ul>
<li>标记：首先标记出需要回收的对象</li>
<li>整理：让所有存活对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</li>
</ul>
</li>
<li>缺点：<ul>
<li><code>Stop The World</code>：移动对象必须暂停用户线程<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload class="" title="alt 标记整理算法"></li>
</ul>
</li>
</ul>
<h2 id="3-4-HotSpot的算法细节"><a href="#3-4-HotSpot的算法细节" class="headerlink" title="3.4 HotSpot的算法细节"></a>3.4 HotSpot的算法细节</h2><h3 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h3><ul>
<li>通过 <code>OopMap</code> 数据结构来记录对象引用</li>
</ul>
<h3 id="3-4-2-安全点-Safepoint"><a href="#3-4-2-安全点-Safepoint" class="headerlink" title="3.4.2 安全点 Safepoint"></a>3.4.2 安全点 Safepoint</h3><ul>
<li>记录OopMap的地方</li>
<li>选取标准：<ul>
<li>不能太少，让GC等待时间过长</li>
<li>不能太多，增大运行时的内存负荷</li>
<li>以”是否具有让程序长时间执行的特征”为标准，如方法调用、循环跳转、异常跳转等</li>
</ul>
</li>
<li>中断方案：<ul>
<li>抢先式中断：GC时，系统先把所有用户线程中断，如果中断位置不在安全点上，就恢复线程，直到到达安全点。如今几乎没有JVM使用。</li>
<li>主动式中断：GC设置标记位，各个线程轮询标记，发现标记为真则主动在最近的安全点中断挂起。HotSpot使用内存保护陷阱实现。</li>
</ul>
</li>
</ul>
<h3 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h3><ul>
<li>指能够确保在某一段代码片段之中，引用关系不会发生变化</li>
<li>因此，在这个区域中任何地方开始垃圾收集都是安全的</li>
</ul>
<h3 id="3-4-4-记忆集和卡表"><a href="#3-4-4-记忆集和卡表" class="headerlink" title="3.4.4 记忆集和卡表"></a>3.4.4 记忆集和卡表</h3><ul>
<li>记忆集<ul>
<li>一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</li>
<li>记录精度：<ul>
<li>字长精度：记录精确到一个机器字长 32&#x2F;64，该字还有跨代指针</li>
<li>对象精度：精确到一个对象，该对象里有字段含有跨代指针</li>
<li>卡精度：精确到一块内存区域，该区域内有对象含有跨代指针</li>
</ul>
</li>
</ul>
</li>
<li>卡表<ul>
<li>记忆集的一种实现方式</li>
<li>对应卡精度</li>
</ul>
</li>
</ul>
<h3 id="3-4-5-写屏障-Write-Barrier"><a href="#3-4-5-写屏障-Write-Barrier" class="headerlink" title="3.4.5 写屏障 Write Barrier"></a>3.4.5 写屏障 Write Barrier</h3><ul>
<li>HotSpot通过写屏障技术维护卡表状态</li>
<li>是对引用类型赋值操作的AOP切面，并产生一个环绕通知</li>
<li>赋值前的是写前屏障</li>
<li>赋值后的是写后屏障</li>
</ul>
<h3 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h3><ul>
<li>三色标记<ul>
<li>白色：表示对象尚未被GC访问过</li>
<li>黑色：表示对象以及被GC访问过，且该对象的所有引用都已经扫描过</li>
<li>灰色：表示对象已经被GC访问过，但该对象上至少存在一个引用还没有被扫描过</li>
</ul>
</li>
<li>并发扫描的”对象消失”问题<ul>
<li>满足两个条件：<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li>
<li>赋值器删除了全部从灰色对象到白色对象的直接或间接引用</li>
</ul>
</li>
<li>解决方案：<ul>
<li>增量更新：破坏条件1。当黑色对象插入新的指向白色对象的引用关系时，记录下新的引用关系，等并发扫描结束，将这些记录的黑色对象为根，重新扫描一次。</li>
<li>原始快照SATB：破坏条件2。当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用关系记录下来，等并发扫描结束，再将这些记录过的引用关系中的灰色对象为根重新扫描一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-经典垃圾收集器"><a href="#3-5-经典垃圾收集器" class="headerlink" title="3.5 经典垃圾收集器"></a>3.5 经典垃圾收集器</h2><img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt 经典垃圾收集器">

<h3 id="3-5-1-Serial-收集器"><a href="#3-5-1-Serial-收集器" class="headerlink" title="3.5.1 Serial 收集器"></a>3.5.1 Serial 收集器</h3><ul>
<li>新生代GC</li>
<li>单线程，标记-复制算法</li>
<li>GC时必须暂停其它所有工作线程，直到它收集结束</li>
<li>虽然鸡肋，但迄今为止，依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt Serial收集器">
<center>Serial/SerialOld 收集器运行示意图</center></li>
</ul>
<h3 id="3-5-2-ParNew-收集器"><a href="#3-5-2-ParNew-收集器" class="headerlink" title="3.5.2 ParNew 收集器"></a>3.5.2 ParNew 收集器</h3><ul>
<li>新生代GC</li>
<li><code>ParNew</code>实质上是<code>Serial</code>的多线程并发版本，使用标记-复制算法</li>
<li>除<code>Serial</code>外，只有<code>ParNew</code>可以和<code>CMS</code>配合使用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt ParNew收集器">
<center>ParNew/SerialOld 收集器运行示意图</center></li>
</ul>
<h3 id="3-5-3-Parallel-Scavenge-收集器"><a href="#3-5-3-Parallel-Scavenge-收集器" class="headerlink" title="3.5.3 Parallel Scavenge 收集器"></a>3.5.3 Parallel Scavenge 收集器</h3><ul>
<li>新生代GC</li>
<li>与<code>ParNew</code>类似，并行收集，使用标记-复制算法</li>
<li>目标是达到一个可控制的吞吐量, 因此也称作吞吐量优先收集器<br>$$ 吞吐量 &#x3D; \frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间} $$</li>
</ul>
<h3 id="3-5-4-Serial-Old-收集器"><a href="#3-5-4-Serial-Old-收集器" class="headerlink" title="3.5.4 Serial Old 收集器"></a>3.5.4 Serial Old 收集器</h3><ul>
<li><code>Serial</code>的老年代版本</li>
<li>单线程，标记-整理算法</li>
<li><code>CMS</code>发生<code>Concurrent Mode Failure</code>失败时的后备预案
<center>Serial/SerialOld 收集器运行示意图</center></li>
</ul>
<h3 id="3-5-5-Parallel-Old-收集器"><a href="#3-5-5-Parallel-Old-收集器" class="headerlink" title="3.5.5 Parallel Old 收集器"></a>3.5.5 Parallel Old 收集器</h3><ul>
<li><code>Parallel Scavenge</code>的老年代版本</li>
<li>多线程并发，标记-整理</li>
<li>注重吞吐量或者处理器资源较为稀缺的场合，优先考虑<code>Parallel Scavenge</code> + <code>Parallel Old</code>
<center>Parallel Scavenge/Parallel Old 收集器运行示意图</center></li>
</ul>
<h3 id="3-5-6-CMS-Concurrent-Mark-Sweep-收集器"><a href="#3-5-6-CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="3.5.6 CMS (Concurrent Mark Sweep) 收集器"></a>3.5.6 CMS (Concurrent Mark Sweep) 收集器</h3><ul>
<li>老年代GC</li>
<li>基于标记-清除算法</li>
<li>四个步骤：<ul>
<li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li>
<li>并发标记：遍历对象图。与用户线程并发。</li>
<li>重新标记：修正并发标记阶段产生的标记变动(因用户线程的并发执行)。暂停用户线程。</li>
<li>并发清除：清理标记死亡的对象。与用户线程并发。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt CMS 收集器"></li>
</ul>
</li>
<li>特点：并发收集，低停顿。因此也称”并发低停顿收集器”。</li>
<li>缺点：<ul>
<li>对处理器资源非常敏感</li>
<li>无法处理”浮动垃圾”,可能出现<code>Concurrent Mode Failure</code>进而导致需要一次<code>Full GC</code>(临时启用<code>Serial Old</code>)</li>
<li>容易产生大量内存碎片空间</li>
</ul>
</li>
</ul>
<h3 id="3-5-7-Garbage-First-G1-收集器"><a href="#3-5-7-Garbage-First-G1-收集器" class="headerlink" title="3.5.7 Garbage First (G1) 收集器"></a>3.5.7 Garbage First (G1) 收集器</h3><ul>
<li>开创面向局部收集的设计思路和基于Region内存布局</li>
<li>Region：<ul>
<li>连续的Java堆划分为多个大小相等的独立Region，每个Region根据需要扮演Eden&#x2F;Survivor&#x2F;老年代</li>
<li>Humongous区域专门存储大对象</li>
<li>G1跟踪各个Region里面的垃圾堆积的”价值”大小。价值即回收所获得的空间大小以及回收所需时间的经验值，后台维护一个优先级列表。</li>
</ul>
</li>
<li>目的：延迟可控的情况下，获得尽可能高的吞吐量。</li>
<li>四个步骤：<ul>
<li>初始标记：标记<code>GC Roots</code>能直接关联的对象，并修改TAMS指针以便正确分配对象。暂停用户线程。</li>
<li>并发标记：遍历对象图。与用户线程并发。(用SATB原始快照处理引用变化)</li>
<li>最终标记：处理并发阶段结束后遗留的少量SATB记录。暂停用户线程。</li>
<li>筛选回收：更新Region的统计数据，根据优先级选择Region回收集，移动存活对象并清理旧Region的全部空间。暂停用户线程。<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt G1 收集器"></li>
</ul>
</li>
</ul>
<h2 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h2><ul>
<li>垃圾收集器的衡量指标：<ul>
<li>内存占用 <code>Footprint</code></li>
<li>吞吐量 <code>Throughput</code></li>
<li>延迟 <code>Latency</code></li>
</ul>
</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%90%84%E6%AC%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5.png" srcset="/img/loading.gif" lazyload class="" title="alt 各款收集器的并发情况">
<center>各款收集器的并发情况</center>

<h3 id="3-6-1-Shenandoah-收集器"><a href="#3-6-1-Shenandoah-收集器" class="headerlink" title="3.6.1 Shenandoah 收集器"></a>3.6.1 Shenandoah 收集器</h3><ul>
<li><p>类似G1，基于Region，按照优先级回收</p>
</li>
<li><p>特点</p>
<ul>
<li>支持并发的整理算法</li>
<li>默认不使用分代收集</li>
<li>改用<code>Connection Matrix</code>全局数据结构来记录跨Region的引用关系</li>
</ul>
</li>
<li><p>九个步骤：</p>
<ul>
<li>初始标记：标记<code>GC Roots</code>能直接关联的对象。暂停用户线程。</li>
<li>并发标记：遍历对象图。与用户线程并发。(时间取决于堆中存活对象的数量和对象图的复杂程度)</li>
<li>最终标记：处理剩余的SATB扫描，并统计回收价值最高的Region构成回收集。短暂停顿</li>
<li>并发清理：清理没有存活对象的Region</li>
<li>并发回收：核心特点。借助<code>读屏障</code>、<code>Brooks Pointers</code>把回收集里的存活对象复制到未被使用的Region</li>
<li>初始引用更新：把堆中所有指向旧对象的引用修正到复制后的新地址(引用更新)。短暂停顿。</li>
<li>并发引用更新：真正开始引用更新。与用户线程并发。时间取决于涉及的引用数量。</li>
<li>最终引用更新：修正存在于GC Roots中的引用。短暂停顿。</li>
<li>并发清理：回收剩余的回收集中的Region，供以后对象分配使用。
<center>Shenandoah 收集器工作流程</center></li>
</ul>
</li>
<li><p>Brooks Pointer</p>
<ul>
<li>以前的方案：在被移动对象原有的内存上设置保护陷阱，一旦访问旧对象内存空间产生自陷中断进入预设好的异常处理器中，把访问转发到复制后的对象上</li>
<li><code>Brooks Pointer</code>在原有对象布局结构的最前面统一增加一个新的引用字段<ul>
<li>正常情况下，该引用指向对象自己</li>
<li>移动对象时只需修改该指针即可</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要额外的间接访问开销</li>
<li>多线程竞争问题，Shenandoah通过CAS操作保证并发访问正确性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-2-ZGC-收集器"><a href="#3-6-2-ZGC-收集器" class="headerlink" title="3.6.2 ZGC 收集器"></a>3.6.2 ZGC 收集器</h3><ul>
<li>基于Region内存布局，分大、中、小三类容量</li>
<li>不设分代</li>
<li>使用读屏障、染色指针、内存多重映射等技术</li>
<li>可并发，基于标记-整理算法</li>
<li>以低延迟为首要目标</li>
</ul>
<p>染色指针：</p>
<ul>
<li><p>直接把少量额外的信息存储在指针上的技术(指针的高位没有用来寻址，需要底层支持)</p>
</li>
<li><p>x86-64架构下需要多重映射的支持：将多个不同的虚拟内存地址映射到同一个物理内存地址上(多对一)</p>
</li>
<li><p>优势：</p>
<ul>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉</li>
<li>大幅减少垃圾收集过程中内存屏障的使用数量</li>
<li>可以作为一种可扩展的存储结构用来记录更多数据</li>
</ul>
</li>
<li><p>四个过程</p>
<ul>
<li>并发标记：遍历对象图做可达性分析，特殊点在于标记是在指针上而不是在对象上。需短暂停顿。</li>
<li>并发预备重分配：根据特定查询条件确定回收集</li>
<li>并发重分配：核心。把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系(用于指针自愈)。</li>
<li>并发重映射：修正整个堆中指向重分配集中旧对象的所有引用<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/ZGC%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt ZGC 收集器"></li>
</ul>
</li>
</ul>
<h1 id="第四章-虚拟机性能监控、故障处理工具"><a href="#第四章-虚拟机性能监控、故障处理工具" class="headerlink" title="第四章 - 虚拟机性能监控、故障处理工具"></a>第四章 - 虚拟机性能监控、故障处理工具</h1><h2 id="4-2-基础故障处理工具"><a href="#4-2-基础故障处理工具" class="headerlink" title="4.2 基础故障处理工具"></a>4.2 基础故障处理工具</h2><ul>
<li>根据软件可用性和授权的不同，分以下三类：<ul>
<li>商业授权工具：如JMC(Java Mission Control), JFR(Java Flight Recorder) 等</li>
<li>正式支持工具：LTS</li>
<li>试验性工具：Unsupported and Experimental</li>
</ul>
</li>
<li>这些工具JDK9之前在jdk\lib\tools目录下，经过模块化改造后现在在jdk\jmods目录下</li>
<li>工具本身用Java语言实现</li>
</ul>
<h3 id="4-2-1-amp-nbsp-jps-虚拟机进程状况工具"><a href="#4-2-1-amp-nbsp-jps-虚拟机进程状况工具" class="headerlink" title="4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具"></a>4.2.1 &amp;nbsp; jps - 虚拟机进程状况工具</h3><ul>
<li>JVM Process Status Tool</li>
<li>列出正在运行的虚拟机进程，并显示虚拟机执行主类，名称，以及这些进程的本地虚拟机唯一ID  (<code>LVMID - Local Virtual Machine Identifier</code>)</li>
<li>命令格式：<code>jps [options] [hostid]</code></li>
<li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E6%A0%B7%E4%BE%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt jps样例"></li>
<li>选项参数<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jps%E5%8F%82%E6%95%B0.png" srcset="/img/loading.gif" lazyload class="" title="alt jps参数"></li>
</ul>
<h3 id="4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具"><a href="#4-2-2-amp-nbsp-jstat-虚拟机统计信息监视工具" class="headerlink" title="4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具"></a>4.2.2 &amp;nbsp; jstat - 虚拟机统计信息监视工具</h3><ul>
<li>JVM Statistics Monitoring Tool</li>
<li>监视虚拟机各种运行状态信息</li>
<li>命令格式：<code>jstat [ option vmid [interval [s|ms] [count]] ]</code><ul>
<li>若是本地虚拟机，则VMID与LVMID一致</li>
<li>若是远程虚拟机，则<code>VMID = [protocol:][//]lvmid[@hostname[:port]/servername]</code></li>
<li>interval: 查询间隔</li>
<li>count: 查询次数</li>
<li>option: 希望查询的虚拟机信息，分三类<ul>
<li>类加载</li>
<li>垃圾收集</li>
<li>运行期编译状况<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E9%80%89%E9%A1%B9.png" srcset="/img/loading.gif" lazyload class="" title="alt jstat选项"></li>
</ul>
</li>
</ul>
</li>
<li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstat%E6%A0%B7%E4%BE%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt jstat样例"></li>
</ul>
<h3 id="4-2-3-amp-nbsp-jinfo-Java配置信息工具"><a href="#4-2-3-amp-nbsp-jinfo-Java配置信息工具" class="headerlink" title="4.2.3 &amp;nbsp; jinfo - Java配置信息工具"></a>4.2.3 &amp;nbsp; jinfo - Java配置信息工具</h3><ul>
<li>Configuration Info for Java</li>
<li>实时查看和调整虚拟机各项参数</li>
<li>命令格式：<code>jinfo [option] pid</code></li>
<li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jinfo%E6%A0%B7%E4%BE%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt jinfo样例"></li>
</ul>
<h3 id="4-2-4-amp-nbsp-jmap-Java内存映像工具"><a href="#4-2-4-amp-nbsp-jmap-Java内存映像工具" class="headerlink" title="4.2.4 &amp;nbsp; jmap - Java内存映像工具"></a>4.2.4 &amp;nbsp; jmap - Java内存映像工具</h3><ul>
<li>Memory Map for Java</li>
<li>生成堆转储快照 (heapdump &#x2F; dump),查询finalize执行队列、Java堆和方法区的详细信息等</li>
<li>命令格式：<code>jmap [option] vmid</code></li>
<li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E6%A0%B7%E4%BE%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt jmap样例"></li>
<li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jmap%E9%80%89%E9%A1%B9.png" srcset="/img/loading.gif" lazyload class="" title="alt jmap选项"></li>
</ul>
<h3 id="4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具"><a href="#4-2-5-amp-nbsp-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具"></a>4.2.5 &amp;nbsp; jhat - 虚拟机堆转储快照分析工具</h3><ul>
<li>JVM Heap Analysis Tool</li>
<li>与jmap搭配使用，分析jmap生成的堆转储快照</li>
<li>比较鸡肋，有更好的Analyzer可以替代</li>
<li>分析内存泄露问题需要<code>OQL (Object Query Language)</code></li>
</ul>
<h3 id="4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具"><a href="#4-2-6-amp-nbsp-jstack-Java堆栈跟踪工具" class="headerlink" title="4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具"></a>4.2.6 &amp;nbsp; jstack - Java堆栈跟踪工具</h3><ul>
<li>Stack Trace for Java</li>
<li>生成虚拟机当前时刻的线程快照 (threaddump &#x2F; javacore)</li>
<li>线程快照：当前虚拟机内每条线程正在执行的方法堆栈集合。可以分析线程停顿原因</li>
<li>JDK5开始，<code>java.lang.Thread</code>类新增<code>getAllStackTraces()</code>方法也可以获取所有线程堆栈</li>
<li>命令格式：<code>jstack [option] vmid</code></li>
<li>样例：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E6%A0%B7%E4%BE%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt jstack样例"></li>
<li>选项参数：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/jstack%E9%80%89%E9%A1%B9.png" srcset="/img/loading.gif" lazyload class="" title="alt jstack选项"></li>
</ul>
<h3 id="4-2-7-基础工具总结"><a href="#4-2-7-基础工具总结" class="headerlink" title="4.2.7 基础工具总结"></a>4.2.7 基础工具总结</h3><ul>
<li><p>基础工具：用于支持基本的程序创建和运行</p>
<ul>
<li>如<code>jar, java, javac, javadoc, javap, jdb...</code></li>
</ul>
</li>
<li><p>性能监控和故障处理：监控Java虚拟机运行信息，排查问题</p>
<ul>
<li>如<code>jps, jstat, jinfo, jmap, jhat...</code></li>
</ul>
</li>
<li><p>安全：用于程序签名，设置安全测试等</p>
<ul>
<li>如<code>keytool, jarsigner, policytool</code></li>
</ul>
</li>
<li><p>国际化：用于创建本地语言文件</p>
<ul>
<li>如<code>native2ascii</code></li>
</ul>
</li>
<li><p>远程方法调用: 用于跨Web或网络的服务交互</p>
<ul>
<li>如<code>rmic, rmiregistry, rmid, serialver</code></li>
</ul>
</li>
<li><p>部署工具：用于程序打包、发布和部署</p>
<ul>
<li>如<code>javapackager, pack200, unpack200</code></li>
</ul>
</li>
<li><p>REPL (Read-Eval-Print Loop)和脚本工具：<code>jshell, jjs, jrunscript</code></p>
</li>
<li><p>Java IDL 与 RMI-IIOP: 与JDK11的CORBA一起废弃</p>
</li>
<li><p>WebService工具：与JDK11的CORBA一起废弃</p>
</li>
<li><p>Java Web Start: javaws, jdk11移除</p>
</li>
</ul>
<h2 id="4-3-可视化故障处理工具"><a href="#4-3-可视化故障处理工具" class="headerlink" title="4.3 可视化故障处理工具"></a>4.3 可视化故障处理工具</h2><p><code>JConsole, JHSDB, VisualVM, JMC</code></p>
<h3 id="4-3-1-JHSDB-基于服务性代理的调试工具"><a href="#4-3-1-JHSDB-基于服务性代理的调试工具" class="headerlink" title="4.3.1 JHSDB: 基于服务性代理的调试工具"></a>4.3.1 JHSDB: 基于服务性代理的调试工具</h3><ul>
<li>服务性代理<ul>
<li>一组用于映射Java虚拟机运行信息的，主要基于Java语言实现的API集合</li>
<li>可以在一个独立的Java虚拟机进程中分析其它HotSpot虚拟机的内存数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节</li>
</ul>
</li>
<li>步骤：<ul>
<li><code>jps -l</code> 查找对应进程的pid</li>
<li><code>jhsdb hsdb --pid 3224</code> 进入JHSDB图形化界面</li>
<li><code>revptrs 0x......</code> 内存块对应的引用指针位置</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-JConsole-Java监视与管理控制台"><a href="#4-3-2-JConsole-Java监视与管理控制台" class="headerlink" title="4.3.2 JConsole: Java监视与管理控制台"></a>4.3.2 JConsole: Java监视与管理控制台</h3><ul>
<li>基于<code>JMX(Java Management Extensions)</code>的可视化监视、管理工具</li>
<li>通过JMX的MBean对系统进行信息收集和参数动态调整</li>
<li><code>内存</code>页签 - 相当于jstat命令, 监视被收集器直接管理的Java堆和被间接管理的方法区</li>
<li><code>线程</code>页签 - 相当于jstack命令，分析线程状况、死锁等</li>
<li>其它还有<code>类、VM摘要、MBean</code>等页签</li>
</ul>
<h3 id="4-3-3-VisualVM-多合一故障处理工具"><a href="#4-3-3-VisualVM-多合一故障处理工具" class="headerlink" title="4.3.3 VisualVM: 多合一故障处理工具"></a>4.3.3 VisualVM: 多合一故障处理工具</h3><ul>
<li>支持插件扩展</li>
<li>生成、浏览堆转储快照</li>
<li>分析程序性能</li>
<li>BTrace动态日志追踪</li>
</ul>
<h3 id="4-3-4-Java-Mission-Control-可持续在线的监控工具"><a href="#4-3-4-Java-Mission-Control-可持续在线的监控工具" class="headerlink" title="4.3.4 Java Mission Control: 可持续在线的监控工具"></a>4.3.4 Java Mission Control: 可持续在线的监控工具</h3><ul>
<li>JMC与虚拟机之间采取JMX协议进行通信</li>
<li>JMC一方面作为JMX的控制台，显示来自JVM MBean提供的数据，另一方面作为JFR的分析工具，展示来自JFR的数据</li>
<li><code>JFR(Java Flight Recorder)</code>是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜索框架，用于持续收集数据</li>
<li>JFR监控对应用完全透明，不需要对程序源码做任何修改或基于特定的代理运行</li>
</ul>
<h2 id="4-4-HotSpot虚拟机插件及工具"><a href="#4-4-HotSpot虚拟机插件及工具" class="headerlink" title="4.4 HotSpot虚拟机插件及工具"></a>4.4 HotSpot虚拟机插件及工具</h2><ul>
<li><code>Ideal Graph Visualizer</code>: 可视化展示C2即时编译器转换字节码</li>
<li><code>Client Compiler Visualizer</code>: 查看C1即时编译器生成高级中间表示，转换成低级中间表示和做物理寄存器分配的过程</li>
<li><code>MakeDeps</code>: 帮助处理HotSpot的编译依赖的工具</li>
<li><code>Project Creator</code>: 帮助生成Visual Studio的.project文件工具</li>
<li><code>LogCompiler</code>: 整理输出日志</li>
<li><code>HSDIS</code>: 即时编译器的反汇编插件</li>
</ul>
<h3 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h3><ul>
<li>让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原成汇编代码输出，并产生有价值的注释</li>
<li>日志输出量巨大，需配合<code>JITWatch</code>可视化工具使用</li>
</ul>
<h1 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 - 调优案例分析与实战"></a>第五章 - 调优案例分析与实战</h1><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><h3 id="5-2-1-大内存硬件上的程序部署策略"><a href="#5-2-1-大内存硬件上的程序部署策略" class="headerlink" title="5.2.1 大内存硬件上的程序部署策略"></a>5.2.1 大内存硬件上的程序部署策略</h3><ul>
<li><p>单体应用在较大内存的硬件上主要的部署方式分两种</p>
<ul>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源</li>
</ul>
</li>
<li><p>对于用户交互性强，对停顿时间敏感，内存又较大的系统，必须控制Full GC频率，关键是老年代的稳定，主要取决于应用中大部分对象是否满足”朝生夕灭”的原则</p>
</li>
<li><p>使用单个JVM管理大内存可能面临的问题：</p>
<ul>
<li>回收大块堆内存而导致的长时间停顿</li>
<li>大内存必须有64位虚拟机支持，但64位虚拟机性能普遍略低于32位(指针压缩、处理器缓存行容量等)</li>
<li>必须保证应用程序的足够稳定</li>
<li>相同程序在64位下需要比32位消耗更多的内存(指针膨胀、数据类型对齐补白等)</li>
</ul>
</li>
<li><p>逻辑集群方式可能面临的问题：</p>
<ul>
<li>节点竞争全局资源，例如磁盘竞争</li>
<li>很难高效利用某些资源池</li>
<li>32位系统的节点受到内存限制</li>
<li>大量使用本地缓存的应用在逻辑集群中会造成较大的内存浪费</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-集群间同步导致的内存溢出"><a href="#5-2-2-集群间同步导致的内存溢出" class="headerlink" title="5.2.2 集群间同步导致的内存溢出"></a>5.2.2 集群间同步导致的内存溢出</h3><ul>
<li>集群共享的数据要使用非集中式的集群缓存来同步的话，可以运行读操作频繁，但不应当有过于频繁的写操作</li>
</ul>
<h3 id="5-2-3-堆外内存导致的溢出错误"><a href="#5-2-3-堆外内存导致的溢出错误" class="headerlink" title="5.2.3 堆外内存导致的溢出错误"></a>5.2.3 堆外内存导致的溢出错误</h3><ul>
<li>在处理小内存或者32位的应用问题时，除了Java堆和方法区之外，还有以下区域会占用较多内存<ul>
<li>直接内存 (-XX:MaxDirectMemorySize)</li>
<li>线程堆栈 (-Xss)</li>
<li>Socket缓存区</li>
<li>JNI代码</li>
<li>虚拟机和垃圾收集器</li>
</ul>
</li>
</ul>
<h3 id="5-2-4-外部命令导致系统缓慢"><a href="#5-2-4-外部命令导致系统缓慢" class="headerlink" title="5.2.4 外部命令导致系统缓慢"></a>5.2.4 外部命令导致系统缓慢</h3><ul>
<li>Java的<code>Runtime.getRuntime().exec()</code>方法可以执行Shell脚本，但会先复制一个当前虚拟机环境变量的进程，再利用新的进程执行外部命令，最后再退出这个进程。频繁执行会造成系统消耗过大</li>
</ul>
<h3 id="5-2-5-服务器虚拟机进程崩溃"><a href="#5-2-5-服务器虚拟机进程崩溃" class="headerlink" title="5.2.5 服务器虚拟机进程崩溃"></a>5.2.5 服务器虚拟机进程崩溃</h3><ul>
<li>异步调用，服务速度不对等，最终超过虚拟机的承受能力</li>
</ul>
<h3 id="5-2-6-不恰当数据结构导致内存占用过大"><a href="#5-2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="5.2.6 不恰当数据结构导致内存占用过大"></a>5.2.6 不恰当数据结构导致内存占用过大</h3><h3 id="5-2-7-由Windows虚拟内存导致的长时间停顿"><a href="#5-2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="5.2.7 由Windows虚拟内存导致的长时间停顿"></a>5.2.7 由Windows虚拟内存导致的长时间停顿</h3><h3 id="5-2-8-由安全点导致长时间停顿"><a href="#5-2-8-由安全点导致长时间停顿" class="headerlink" title="5.2.8 由安全点导致长时间停顿"></a>5.2.8 由安全点导致长时间停顿</h3><ul>
<li>三个时间概念：<ul>
<li>user: 进程执行用户态代码所耗费的处理器时间</li>
<li>sys: 进程执行核心态代码所耗费的处理器时间</li>
<li>real: 执行动作从开始到结束耗费的时钟时间</li>
<li>处理器时间指线程<strong>占用处理器一个核心</strong>的耗时计数</li>
<li>时钟时间就是指现实世界中的时间计数</li>
</ul>
</li>
<li>安全点的设置<ul>
<li>一般循环这样的长时间操作是会设置安全点的</li>
<li>但对于int或范围更小的数据类型作为索引值的循环默认时不放置安全点的，称可数循环(Counted Loop)</li>
<li>使用long或范围更大的数据类型作为索引值的循环会放置安全点，称不可数循环(Uncounted Loop)</li>
<li>如果可数循环本身非常耗时，需用<code>-XX:+UseCountedLoopSafepoints</code>强制开启可数循环放置安全点</li>
</ul>
</li>
</ul>
<h2 id="5-3-实战：Eclipse运行速度调优"><a href="#5-3-实战：Eclipse运行速度调优" class="headerlink" title="5.3 实战：Eclipse运行速度调优"></a>5.3 实战：Eclipse运行速度调优</h2><ul>
<li>三大块非用户程序时间<ul>
<li>类加载时间</li>
<li>编译时间<ul>
<li>JVM的即时编译器<code>Just In Time Compiler</code>编译热点代码<code>Hot Spot Code</code>的耗时</li>
</ul>
</li>
<li>垃圾收集时间<ul>
<li>最重要，最耗时，稳定持续的消耗</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 - 类文件结构"></a>第六章 - 类文件结构</h1><h2 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2 无关性的基石"></a>6.2 无关性的基石</h2><ul>
<li>所有平台统一支持的程序存储格式——字节码<code>Byte Code</code>是构成平台无关性的基石<ul>
<li>Class文件包含了Java虚拟机指令集、符号集以及若干其它辅助信息</li>
</ul>
</li>
<li>语言无关性正在越来越被开发者所重视<ul>
<li>任何其它语言的实现者都可以将Java虚拟机作为它们语言的运行基础，以Class文件作为它们产品的交付媒介<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.png" srcset="/img/loading.gif" lazyload class="" title="alt JVM语言无关性"></li>
</ul>
</li>
</ul>
<h2 id="6-3-Class-类文件的结构"><a href="#6-3-Class-类文件的结构" class="headerlink" title="6.3 Class 类文件的结构"></a>6.3 Class 类文件的结构</h2><ul>
<li>Class文件是一组以8个字节为基础单位的二进制流</li>
<li>采用一种伪结构来存储数据，包括两种数据类型：<ul>
<li><code>无符号数</code>：基本数据类型，以u1&#x2F;u2&#x2F;u4&#x2F;u8分别代表1&#x2F;2&#x2F;4&#x2F;8个字节。用来描述数字、索引引用、数量值、UTF-8编码的字符串值</li>
<li><code>表</code>：多个无符号数或其它表 作为数据项构成的复合数据结构，以_info结尾用来描述有层次关系的复合数据结构</li>
</ul>
</li>
</ul>
<h3 id="6-3-1-魔数与Class文件版本"><a href="#6-3-1-魔数与Class文件版本" class="headerlink" title="6.3.1 魔数与Class文件版本"></a>6.3.1 魔数与Class文件版本</h3><ul>
<li>每个Class文件的头4个字节称魔数<code>Magic Number</code><ul>
<li>固定为<code>0xCAFEBABE</code> (咖啡宝贝)</li>
<li>作用是确定这个文件是否为一个能被虚拟机接受的Class</li>
</ul>
</li>
</ul>
<ul>
<li>第5、6两个字节是次版本号 <code>Minor Version</code><ul>
<li>若Class使用了实验性功能，则固定为65535，否则全0</li>
</ul>
</li>
</ul>
<ul>
<li>第7、8两个字节是主版本号 <code>Major Version</code><ul>
<li>版本号从45开始，例如JDK17的主版本就是45+17-1&#x3D;61</li>
<li>高版本JDK仅向下兼容</li>
<li>JVM必须拒绝执行超过其版本号的Class文件，即使Class格式未发生变化</li>
</ul>
</li>
</ul>



<h3 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2 常量池"></a>6.3.2 常量池</h3><ul>
<li>位于次、主版本号之后</li>
<li>相当于Class文件的资源仓库，是Class结构中与其它项目关联最多的数据，占比也最大</li>
<li>首先入口处需放置一个u2类型的常量池容量计数器 (容量从1开始，即<code>常量数=counter-1</code>)</li>
<li>主要存放两大类常量，每一项都是一个表，共17种类型：<ul>
<li>字面量：如文本字符串、final等</li>
<li>符号引用：<ul>
<li>被模块导出或者开放的包</li>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型</li>
<li>动态调用点和动态常量</li>
</ul>
</li>
</ul>
</li>
<li>可用<code>javap -verbose</code>输出字节码内容</li>
</ul>
<h3 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3 访问标志"></a>6.3.3 访问标志</h3><ul>
<li>常量池之后的两个字节</li>
<li>用于识别一些类或者接口层次的访问信息</li>
<li>一共16个标志位可以使用，Java定义了其中9个，未定义的一律为0<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" srcset="/img/loading.gif" lazyload class="" title="alt 访问标志"></li>
</ul>
<h3 id="6-3-4-类索引、父索引与接口索引集合"><a href="#6-3-4-类索引、父索引与接口索引集合" class="headerlink" title="6.3.4 类索引、父索引与接口索引集合"></a>6.3.4 类索引、父索引与接口索引集合</h3><ul>
<li><p>类索引：u2，用于确定类的全限定名</p>
</li>
<li><p>父索引：u2，用于确定这个类的父类的全限定名</p>
<ul>
<li>类索引、父索引各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过其中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型常量中的全限定名字符串。搜索关系如下图<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt 类索引定位过程"></li>
</ul>
</li>
<li><p>接口索引集合：u2类型数据集合，描述该类实现了哪些接口</p>
<ul>
<li>接口索引的入口是u2类型的计数器，表示索引表的容量</li>
</ul>
<p>这三项数据确定类的继承关系，按顺序排列在访问标志之后</p>
</li>
</ul>
<h3 id="6-3-5-字段表-field-info-集合"><a href="#6-3-5-字段表-field-info-集合" class="headerlink" title="6.3.5 字段表 field_info 集合"></a>6.3.5 字段表 field_info 集合</h3><ul>
<li>用于描述接口或类中声明的变量，包括类级变量和实例级变量</li>
<li>结构如下<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload class="" title="alt 字段表结构">
<ul>
<li><code>access_flags</code> 访问标志位，如是否public&#x2F;private&#x2F;protected&#x2F;static&#x2F;final&#x2F;volatile&#x2F;transient等</li>
<li><code>name_index</code> 字段的简单名称</li>
<li><code>descriptor_index</code> 方法描述符</li>
<li><code>attribute_info</code> 附加的额外信息</li>
</ul>
</li>
</ul>
<ul>
<li>类的全限定名：org&#x2F;chanper&#x2F;TestClass</li>
<li>简单名称：没有类型和参数修饰的方法或字段名称</li>
<li>描述符：描述字段的数据类型，方法参数列表和返回值。    <ul>
<li>标识字符含义：</li>
<li>描述方法时，按照先参数列表，后返回值的顺序描述。参数列表放置于()中。如方法<code>java.lang.String toString()</code>的描述符为：<code>()Ljava/lang/String</code></li>
</ul>
</li>
</ul>
<h3 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6 方法表集合"></a>6.3.6 方法表集合</h3><ul>
<li>结构类似字段表，依次包括<code>access_flags</code>，<code>name_index</code>，<code>descriptor_index</code>，<code>attribute_info</code>。仅标志位略不同</li>
<li>方法里的代码存放在方法属性表集合中的名为<code>Code</code>的属性中</li>
<li>Class文件中的方法特征签名范围更大，包括返回值和受查异常表</li>
</ul>
<h3 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7 属性表集合"></a>6.3.7 属性表集合</h3><ul>
<li>Class文件、字段表、方法表都可以携带自己的属性表集合，且顺序不严格，可以写入自定义属性</li>
<li>每个属性都要从常量池中引用一个Constant_Utf8_info类型的常量来表示，包括<code>u2 attribute_name_index</code>, <code>u4 attribute_length</code>, <code>u1 info</code>三个字段。</li>
<li>属性值结构自定义，通过<code>attribute_length</code>指明长度</li>
</ul>
<h4 id="1-Code-属性"><a href="#1-Code-属性" class="headerlink" title="1. Code 属性"></a>1. Code 属性</h4><ul>
<li>方法体里面的代码经编译后存储在Code内。是Class文件最重要的属性</li>
<li><code>attribute_name_index</code>, <code>attribute_length</code></li>
<li><code>max_stack</code>: 操作数栈最大深度</li>
<li><code>max_locals</code>: 局部变量表所需存储空间(单位<code>Slot</code>)。<code>Slot</code>根据局部变量的作用域可复用，所以此大小是同时生存的最大局部变量空间</li>
<li><code>code</code>: (Code.code)字节码指令，约200种。大小u1，因此最多256种指令。</li>
<li><code>exception_table</code>: 异常表</li>
</ul>
<h4 id="2-Exceptions-属性"><a href="#2-Exceptions-属性" class="headerlink" title="2. Exceptions 属性"></a>2. Exceptions 属性</h4><ul>
<li>列举方法中可能抛出的受查异常(throws关键字)</li>
<li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>number_of_exceptions</code></li>
<li><code>exception_index_table</code>: 受查异常类型，指向常量池中的<code>CONSTANT_Class_info</code></li>
</ul>
<h4 id="3-LineNumberTable-属性"><a href="#3-LineNumberTable-属性" class="headerlink" title="3. LineNumberTable 属性"></a>3. LineNumberTable 属性</h4><ul>
<li>描述Java源码行号与字节码偏移量的对应关系</li>
<li><code>attribute_name_index</code>, <code>attribute_length</code>,<code>line_number_table_length</code></li>
<li><code>line_number_table</code></li>
</ul>
<h4 id="4-LocalVariableTable-与-LocalVariableTypeTable"><a href="#4-LocalVariableTable-与-LocalVariableTypeTable" class="headerlink" title="4. LocalVariableTable 与 LocalVariableTypeTable"></a>4. LocalVariableTable 与 LocalVariableTypeTable</h4><ul>
<li><code>LocalVariableTable</code>描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</li>
<li><code>LocalVariableTypeTable</code>使用字段的特征签名来完成泛型的描述</li>
</ul>
<h4 id="5-SourceFile-与-SourceDebugExtension"><a href="#5-SourceFile-与-SourceDebugExtension" class="headerlink" title="5. SourceFile 与 SourceDebugExtension"></a>5. SourceFile 与 SourceDebugExtension</h4><ul>
<li><code>SourceFile</code>记录生成Class文件的源码文件名称</li>
<li><code>SourceDebugExtension</code>存储额外的代码调试信息</li>
</ul>
<h4 id="6-ConstantValue-属性"><a href="#6-ConstantValue-属性" class="headerlink" title="6. ConstantValue 属性"></a>6. ConstantValue 属性</h4><ul>
<li><code>ConstantValue</code>通知虚拟机自动为静态变量赋值</li>
<li>实例变量在实例构造器<code>&lt;init&gt;()</code>方法中完成赋值</li>
<li>类变量如果是<code>static final</code>的<code>基本类型或String</code>，就用<code>ConstantValue</code>初始化，否则在类构造器<code>&lt;clinit&gt;()</code>方法中初始化</li>
</ul>
<h4 id="7-InnerClasses-属性"><a href="#7-InnerClasses-属性" class="headerlink" title="7. InnerClasses 属性"></a>7. InnerClasses 属性</h4><ul>
<li>记录内部类和宿主类之间的关联</li>
<li><code>inner_classes</code>, <code>inner_class_info_index</code>, <code>outer_class_info_index</code>, <code>inner_class_flags</code></li>
</ul>
<h4 id="8-Deprecated-与-Synthetic"><a href="#8-Deprecated-与-Synthetic" class="headerlink" title="8. Deprecated 与 Synthetic"></a>8. Deprecated 与 Synthetic</h4><ul>
<li>都是标志类型的布尔属性，没有属性值</li>
<li><code>Deprecated</code>标识某个类、方法、字段不再推荐使用</li>
<li><code>Synthetic</code>标识此字段、方法由编译器自动产生，非源码直接产生</li>
</ul>
<h4 id="9-StackMapTable-属性"><a href="#9-StackMapTable-属性" class="headerlink" title="9. StackMapTable 属性"></a>9. StackMapTable 属性</h4><ul>
<li>在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，代替以前消耗性能的基于数据流分析的类型推导验证器</li>
<li><code>stack_map_frame_entries</code></li>
</ul>
<h4 id="10-Signature-属性"><a href="#10-Signature-属性" class="headerlink" title="10. Signature 属性"></a>10. Signature 属性</h4><ul>
<li>记录泛型签名信息</li>
<li>Java的泛型实现是伪泛型，实现简单，容易Backport，内存开销较小</li>
<li>但运行期反射无法获取泛型类型</li>
</ul>
<h4 id="11-BootstrapMethods-属性"><a href="#11-BootstrapMethods-属性" class="headerlink" title="11. BootstrapMethods 属性"></a>11. BootstrapMethods 属性</h4><ul>
<li>用于保存<code>invokeDynamic</code>指令引用的引导方法限定符</li>
<li><code>bootstrap_methods</code></li>
</ul>
<h4 id="12-MethodParameters-属性"><a href="#12-MethodParameters-属性" class="headerlink" title="12. MethodParameters 属性"></a>12. MethodParameters 属性</h4><ul>
<li>记录方法的各个形参名称和信息</li>
<li><code>parameters</code></li>
</ul>
<h4 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13. 模块化相关属性"></a>13. 模块化相关属性</h4><ul>
<li><code>Module</code>存储模块名称、版本、标志信息、模块requires、exports、opens、uses、provides等</li>
<li><code>ModulePackages</code>描述该模块中所有的包</li>
<li><code>ModuleMainClass</code>确定该模块的主类</li>
</ul>
<h4 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14. 运行时注解相关属性"></a>14. 运行时注解相关属性</h4><ul>
<li><code>RuntimeVisibleAnnotations</code>, <code>RuntimeInvisibleAnnotations</code></li>
<li><code>RuntimeVisibleParameterAnnotations</code>, <code>RuntimeInvisibleParameterAnnotations</code></li>
<li><code>RuntimeVisibleTypeAnnotations</code>, <code>RuntimeInvisibleTypeAnnotations</code></li>
</ul>
<h2 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h2><ul>
<li>JVM的指令由一个字节长度的操作码<code>Opcode</code>,和零至多个操作数<code>Operand</code>构成</li>
<li>面向操作数栈</li>
</ul>
<h3 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1 字节码与数据类型"></a>6.4.1 字节码与数据类型</h3><ul>
<li>大多数指令都包含其操作对应的数据类型信息</li>
<li>对于<code>boolean，byte，short，char</code>类型的操作，实际上都是使用相应的<code>int</code>类型作为运算类型来进行的<ul>
<li>编译期或运行期会将<code>byte和short</code>类型的数据带符号扩展为相应的<code>int</code>类型数据</li>
<li>编译期或运行期会将<code>boolean和char</code>类型数据零位扩展为相应的<code>int</code>类型数据</li>
</ul>
</li>
</ul>
<h3 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2 加载和存储指令"></a>6.4.2 加载和存储指令</h3><ul>
<li>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</li>
<li>如<code>iload，lload，fload，istore，fstore，bipush，sipush...</code></li>
</ul>
<h3 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3 运算指令"></a>6.4.3 运算指令</h3><ul>
<li>对两个操作数栈上的值进行某种特定运算，并将结果重新存入到操作栈顶</li>
<li>分为对整型数据、浮点型数据运算的指令</li>
<li>如<code>iadd，isub，imul，idiv...</code></li>
<li>JVM的向零舍入模式：截断数字</li>
<li>向最接近数舍入模式：优先选择最低有效位为0的</li>
</ul>
<h3 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4 类型转换指令"></a>6.4.4 类型转换指令</h3><ul>
<li>将两种不同的数值类型相互转换</li>
<li>JVM直接支持以下类型的宽化类型转换：<ul>
<li><code>int -&gt; long, float, double</code></li>
<li><code>long -&gt; float, double</code></li>
<li><code>float -&gt; double</code></li>
</ul>
</li>
<li>窄化类型转换，必须使用显示转换指令。可能发生上限溢出，下限溢出，精度丢失</li>
</ul>
<h3 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5 对象创建与访问指令"></a>6.4.5 对象创建与访问指令</h3><ul>
<li>创建类：<code>new</code></li>
<li>创建数组：<code>newarray，anewarray，multianewarray</code></li>
<li>JVM对类实例和数组的创建与操作使用了不同的字节码指令</li>
</ul>
<h3 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6 操作数栈管理指令"></a>6.4.6 操作数栈管理指令</h3><ul>
<li>出栈：<code>pop</code></li>
<li>复制栈顶元素：<code>dup</code></li>
<li>栈顶两个元素互换：<code>swap</code></li>
</ul>
<h3 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7 控制转移指令"></a>6.4.7 控制转移指令</h3><ul>
<li>让JVM有条件或无条件得从指定位置得一下条指令继续执行程序(修改PC值)</li>
<li>分条件分支、复合条件分支、无条件分支等</li>
<li>各种类型的比较最终都会转换为int类型的比较操作</li>
</ul>
<h3 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8 方法调用和返回指令"></a>6.4.8 方法调用和返回指令</h3><ul>
<li><code>invokevirtual</code>：调用对象的方法实例</li>
<li><code>invokeinterface</code>：调用接口方法</li>
<li><code>invokespecial</code>：调用一些需要特殊处理的实例方法</li>
<li><code>invokestatic</code>：调用类静态方法</li>
<li><code>invokedynamic</code>：用于在运行时动态解析出调用点限定符所引用的方法</li>
</ul>
<h3 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9 异常处理指令"></a>6.4.9 异常处理指令</h3><ul>
<li>显式抛出异常：<code>athrow</code></li>
<li>处理异常(catch)采用异常表完成，而不是字节码指令</li>
</ul>
<h3 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10 同步指令"></a>6.4.10 同步指令</h3><ul>
<li>JVM支持方法级的同步和方法内部一段指令序列的同步，使用管程Monitor来实现</li>
<li>ACC_SYNCHRONIZED访问标志标记一个方法是否声明为同步方法</li>
<li>monitorenter和monitorexit两条指令支持synchronized关键字的语义</li>
</ul>
<h2 id="6-5-共有设计，私有实现"><a href="#6-5-共有设计，私有实现" class="headerlink" title="6.5 共有设计，私有实现"></a>6.5 共有设计，私有实现</h2><ul>
<li>JVM实现方式：<ul>
<li>将输入的JVM代码在加载或执行时翻译成另一种虚拟机的指令集</li>
<li>将输入的JVM代码在加载或执行时翻译成宿主机处理程序的本地指令集(即时编译)</li>
</ul>
</li>
</ul>
<h2 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6 Class文件结构的发展"></a>6.6 Class文件结构的发展</h2><ul>
<li>Class文件格式具备的平台中立、紧凑、稳定和可扩展的特点是Java技术体系实现平台无关、语言无关两项特性的重要支柱</li>
</ul>
<h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 - 虚拟机类加载机制"></a>第七章 - 虚拟机类加载机制</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ul>
<li>类加载机制：JVM把描述类的数据从Class文件加载到内存，并对数据继续校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</li>
<li>Java中，类型的加载、连接和初始化过程都是在程序运行期完成的</li>
</ul>
<h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><ul>
<li>类加载到卸载的七个阶段，其中验证、准备、解析三个部分统称连接<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
</li>
<li>这些阶段通常都是互相交叉混合进行的，一个阶段的执行过程中调用、激活另一个阶段</li>
<li>JVM有且只有以下六种情况必须对类进行初始化(主动引用)<ul>
<li>遇到new, getstatic, putstatic, invokestatic这四条字节码指令时。例如new关键字实例化对象，读取或设置一个类的静态字段，调用类型的静态方法时</li>
<li>java.lang.reflect对类型进行反射调用的时候</li>
<li>初始化类时发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>JVM启动时，包含main()方法的类需要先初始化</li>
<li>动态语言支持，方法句柄对应的类尚未进行初始化时</li>
<li>接口中有default关键字修饰的接口方法，在其实现类初始化时需要先初始化该接口</li>
</ul>
</li>
<li>其它引用类型的方式称为被动引用，都不会触发初始化。如：<ul>
<li>子类引用父类定义的静态字段，只会初始化父类，而不会初始化子类</li>
</ul>
</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" lazyload class="" title="alt 类的生命周期">

<h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h2><h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><ul>
<li>完成三件事：<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li>获取类的二进制字节流不限于Class文件，还可以是压缩包如jar，网络如applet，动态生成，数据库等等</li>
<li>数据类本身不通过类加载器创建，它是由JVM直接在内存中动态构造出来的</li>
</ul>
<h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><ul>
<li>目的是确保Class文件的字节流包含的信息符合全部约束要求，保证代码运行不会JVM自身的安全</li>
<li>分四个阶段：<ul>
<li>文件格式验证：保证输入的字节流能正确解析并存储于方法区之内</li>
<li>元数据验证：对字节码描述信息进行语义分析</li>
<li>字节码验证：通过数据流分析和控制流分析，确定程序语义合法，符合逻辑。(停机问题：不完全保证合法)</li>
<li>符号引用验证：对类自身以外的各类信息进行匹配性校验</li>
</ul>
</li>
</ul>
<h3 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h3><ul>
<li>正式为类中定义的变量(静态变量)分配内存并设置类变量初始值的阶段</li>
<li>通常情况下初始值是数据类型的零值，除非类字段存在ConstantValue属性</li>
</ul>
<h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><ul>
<li>将常量池内的符号引用替换为直接引用的过程</li>
<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标</li>
<li>直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li>
<li>分为：<ul>
<li>类或接口的解析</li>
<li>字段解析</li>
<li>方法解析</li>
<li>接口方法解析</li>
</ul>
</li>
</ul>
<h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><ul>
<li>类加载的最后一个阶段，根据程序编码初始化类变量和其它资源(执行类构造器<code>&lt;clinit&gt;()</code>)</li>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<code>类变量的赋值动作</code>和<code>静态语句块</code>合并产生的，顺序由源文件中定义顺序决定</li>
<li>JVM中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型一定是<code>java.lang.Object</code></li>
<li>接口(实现类)的<code>&lt;clinit&gt;()</code>不需要先执行(父)接口的<code>&lt;clinit&gt;()</code></li>
<li>同一个类加载器下，一个类型只会被初始化一次</li>
</ul>
<h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><ul>
<li>实现<code>&quot;通过类全限定名来获取描述该类的二进制字节流&quot;</code>这个动作的代码称为<code>类加载器Class Loader</code></li>
<li>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在JVM中的唯一性</li>
</ul>
<h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><ul>
<li>从JVM角度，只有两种不同的类加载器：<ul>
<li>启动类加载器Boostrap ClassLoader，C++实现，JVM自身的一部分</li>
<li>其它类加载器，Java实现，独立于JVM，且全部继承自抽象类<code>java.lang.ClassLoader</code></li>
</ul>
</li>
<li>开发者角度，分三种类加载器<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
</ul>
</li>
<li>各种类加载器之间的层次关系称类加载器的<strong>双亲委派模型</strong>。<ul>
<li>要求除了顶层的启动类加载器外，其它的类加载器必须有自己的父类加载器(一般通过组合关系实现复用)</li>
<li>类加载器工作时收到类加载的请求，首先交给父类加载器去完成，父类无法完成时才自己去加载<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt 类加载器的双亲委派模型"></li>
</ul>
</li>
</ul>
<h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><ul>
<li>三次破坏</li>
<li>OSGi实现模块化部署的关键是它自定义的类加载器机制的实现，每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。类加载器不再是双亲委派模型，而是更加复杂的网状结构</li>
</ul>
<h2 id="7-5-Java模块化系统"><a href="#7-5-Java模块化系统" class="headerlink" title="7.5 Java模块化系统"></a>7.5 Java模块化系统</h2><ul>
<li>模块化的关键目标：可配置的封装隔离机制</li>
<li>JDK 9之后的类加载委派关系：<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%A7%94%E6%B4%BE%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload class="" title="alt JDK9之后的类加载委派关系"></li>
</ul>
<h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 - 虚拟机字节码执行引擎"></a>第八章 - 虚拟机字节码执行引擎</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ul>
<li>执行引擎是虚拟机核心的组成部分之一</li>
<li>物理机的执行引擎直接建立在处理器、缓存、指令集和OS层面上，而JVM执行引擎有软件自行实现，不受物理条件制约，能够执行不被硬件直接支持的指令集格式</li>
<li>分解释执行、编译执行两种方式</li>
<li>执行引擎的输入是字节码二进制流，处理过程是字节码解析执行的等效过程，输出是执行结果</li>
</ul>
<h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><ul>
<li>JVM以方法作为最基本的执行单元</li>
<li>栈帧是支持JVM进行方法调用和方法执行的数据结构，也是JVM运行时数据区中<strong>虚拟机栈</strong>的元素</li>
<li>每一个栈帧包括<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>方法返回地址</code>和一些额外的<code>附加信息</code></li>
<li>对于执行引擎而言，活动线程中栈顶的方法是运行的，称<strong>当前栈帧</strong>，关联方法称<strong>当前方法</strong>。执行引擎的所有字节码指令只针对当前栈帧操作</li>
</ul>
<h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><ul>
<li>一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量</li>
<li>容量以变量槽<code>Slot</code>为最小单位<ul>
<li>除了<code>long double</code>需要2个Slot外，其余数据类型都需要1个Slot</li>
<li>Slot根据变量作用范围可复用</li>
</ul>
</li>
<li>JVM通过索引定位的方法使用局部变量表，范围从0开始至局部变量表最大的变量槽数量</li>
<li>JVM实现通过引用应完成两件事：<ul>
<li>根据引用直接或间接找到对象在Java堆种数据存放的起始地址或索引</li>
<li>根据引用直接或间接找到对象所属数据类型在方法区中存储的类型信息</li>
</ul>
</li>
<li>类字段有两次赋初始值的过程，一次是准备阶段赋系统初始值，另一次是初始化阶段赋程序定义初始值。但局部变量没有初始化就不能使用</li>
</ul>
<h3 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h3><ul>
<li>Operand Stack 后入先出栈</li>
<li>32位数据栈容量为1，64位栈容量为2</li>
<li>优化处理：两个不同的栈帧会出现一部分重叠，节约空间，且可以共享一部分数据</li>
</ul>
<h3 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h3><ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，以便支持调用过程中的动态连接</li>
</ul>
<h3 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h3><ul>
<li>两种退出方法执行的方式：<ul>
<li>正常调用完成，正常向主调函数提供返回值</li>
<li>异常调用完成，不会提供任何返回值</li>
</ul>
</li>
</ul>
<h3 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h3><ul>
<li>JVM规范没有描述的信息，如调试、性能收集相关信息</li>
<li>一般把动态连接、方法返回地址以及其它附加信息全部归为栈帧信息</li>
</ul>
<h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><ul>
<li>方法调用阶段唯一的任务是确定被调用方法的版本</li>
<li>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址</li>
</ul>
<h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><ul>
<li>如果一个方法符合<strong>编译器可知，运行期不可变</strong>，那么JVM在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这类方法的调用称为<code>解析</code></li>
<li>符合条件的方法包括静态方法、私有方法、实例构造器、父类方法，以及final修饰的方法。这五类方法统称<code>非虚方法</code>。其它方法称为<code>虚方法</code>。</li>
<li>前四类通过<code>invokestatic, invokespecial</code>指令调用，final方法通过<code>invokevirtual</code>调用(历史原因)</li>
<li>因此，解析调用是一个静态过程，编译器完全确定</li>
</ul>
<h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><p>解析与分派并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticDispatch</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Human guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Human!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Man guy)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Man!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Woman woman)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Woman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br><br>        <span class="hljs-type">StaticDispatch</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticDispatch</span>();<br>        sd.sayHello(man);   <span class="hljs-comment">// 输出：Hello, Human!</span><br>        sd.sayHello(woman); <span class="hljs-comment">// 输出：Hello, Human!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Human称为变量的静态类型(外观类型)，编译期可知</li>
<li>Man&#x2F;Woman称为变量的实际类型(运行时类型)，运行期确定</li>
</ul>
<ul>
<li>JVM(编译器)在<code>重载</code>时通过参数的静态类型作为判断依据，而非实际类型</li>
<li>所有依赖静态类型决定方法执行版本的分派动作，都称为静态分派</li>
<li>发生在编译阶段</li>
<li>典型应用：方法重载</li>
</ul>
<p>一个更加极端恶心的例子，查看调用哪个sayHello，并注释对应方法再次执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Overload</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Object arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello int&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">long</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Character arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Character&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span> arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-type">char</span>... arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello char...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Serializable arg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello Serializable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        sayHello(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>发现重载的顺序是：char -&gt; int -&gt; long -&gt; Character -&gt; Serializable -&gt; Object -&gt; char…</li>
<li>重载的优先级：<ul>
<li>优先进行宽化转型</li>
<li>接着是自动装箱。char可以转型成int，但Character不可能转型成Integer</li>
<li>接着是实现的接口 -&gt; 父类(根据继承关系从下往上搜索)</li>
<li>最后是边长参数</li>
</ul>
</li>
</ul>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDispatch</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Man say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Woman say hello&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Man say hello</span><br>        woman.sayHello();   <span class="hljs-comment">// Woman say hello</span><br><br>        man = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br>        man.sayHello();     <span class="hljs-comment">// Woman say hello</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>确定调用方法的关键在于<code>invokevirtual</code>指令的步骤<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，查找过程结束。不通过则返回<code>java.lang.IllegalAccessError</code></li>
<li>否则，按照继承关系自下而上依次对C的各个父类进行第二步的搜索和验证过程</li>
<li>如果始终没有找到合适的方法，抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
</li>
<li><code>invokevirtual</code>的第一步就在运行期确定了接收者的实际类型，这就是Java方法重写的本质</li>
<li>这种在<strong>运行期</strong>根据实际类型确定方法执行版本的分派过程称为动态分配</li>
<li>典型应用：方法重写</li>
</ul>
<p>另外，只存在虚方法，不存在虚字段，即字段永远不参与多态。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldHasNoPolymorphic</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">2</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMeTheMoney</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Father</span> <span class="hljs-variable">guy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br><br>        <span class="hljs-comment">// 输出：</span><br>        <span class="hljs-comment">// I am Son, i have $0</span><br>        <span class="hljs-comment">// I am Son, i have $4</span><br>        <span class="hljs-comment">// This guy has $2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Son的构造器首先隐式调用Father构造器。但Father构造器中的showMeTheMoney()是虚方法调用，实际执行的是Son::showMeTheMoney(),且访问的是Son::money(尚未初始化&#x3D;0)</li>
<li>然后执行自身的构造器</li>
</ul>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><ul>
<li>方法的接收者与方法的参数统称为方法的宗量</li>
<li>单分派：根据一个宗量对目标方法进行选择</li>
<li>多分派：根据多于一个宗量对目标方法进行选择</li>
<li>Java语言是一门静态多分派，动态单分派的语言</li>
</ul>
<h4 id="JVM动态分派的实现"><a href="#JVM动态分派的实现" class="headerlink" title="JVM动态分派的实现"></a>JVM动态分派的实现</h4><ul>
<li>基于执行性能的考虑，JVM通常为类型在方法区建立虚方法表vtable，用虚方法表索引代替元数据以提高性能</li>
<li>虚方法表存放着各个方法的实际入口地址。<ul>
<li>如果某个方法在子类中没有重写，那子类的虚方法地址入口和父类一致。</li>
<li>如果子类重写了该方法，则地址入口被替换成子类实现版本的入口地址<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload class="" title="alt 方法表结构"></li>
</ul>
</li>
</ul>
<h2 id="8-4-动态类型语言支持"><a href="#8-4-动态类型语言支持" class="headerlink" title="8.4 动态类型语言支持"></a>8.4 动态类型语言支持</h2><p><strong>JVM 自诞生以来的二十年间，唯一新增的指令 —— <code>invokedynamic</code></strong></p>
<h3 id="8-4-1-动态类型语言"><a href="#8-4-1-动态类型语言" class="headerlink" title="8.4.1 动态类型语言"></a>8.4.1 动态类型语言</h3><ul>
<li>关键特征：<ul>
<li>类型检查的主体过程是在运行期，而非编译期</li>
<li>变量无类型，而变量值才有类型</li>
<li>相比于静态类型语言的编译器可以提供全面严谨的类型检查，动态类型语言更加灵活，清晰简洁</li>
</ul>
</li>
</ul>
<ul>
<li>运行时异常：只要代码不执行到这一行就不会出现问题</li>
<li>连接时异常：即使代码放到不会被执行到的路径分支上，类加载时也会抛出异常</li>
</ul>
<h3 id="8-4-2-Java与动态类型"><a href="#8-4-2-Java与动态类型" class="headerlink" title="8.4.2 Java与动态类型"></a>8.4.2 Java与动态类型</h3><ul>
<li>JDK 7以前的4条方法调用指令的实现方式，导致JVM上的动态类型语言实现复杂，同时带来额外的性能和内存开销</li>
</ul>
<h3 id="8-4-3-java-lang-invoke包"><a href="#8-4-3-java-lang-invoke包" class="headerlink" title="8.4.3 java.lang.invoke包"></a>8.4.3 java.lang.invoke包</h3><ul>
<li>主要目的是在之前单纯依赖符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制。称为<code>方法句柄 Method Handle</code></li>
<li>反射也能实现方法句柄的功能，但存在一些区别：<ul>
<li>Reflection在模拟Java代码层次的方法调用，而MethodHandle模拟字节码层次</li>
<li>Reflection中的Method对象(Java端的全面映像)远比MethodHandle中的对象包含的信息更多。也即Reflection重量级，MethodHandle轻量级。</li>
<li>MethodHandle由于在字节码层次，可以实施各类调用点优化措施</li>
</ul>
</li>
</ul>
<h3 id="8-4-4-invokedynamic-指令"><a href="#8-4-4-invokedynamic-指令" class="headerlink" title="8.4.4 invokedynamic 指令"></a>8.4.4 invokedynamic 指令</h3><ul>
<li>和MethodHandle机制作用一样，解决原有4条invoke指令分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，提供更高的自由度</li>
<li>每一处含有invokedynamic指令的位置称作动态调用点</li>
</ul>
<h2 id="8-5-基于栈的字节码解释执行引擎"><a href="#8-5-基于栈的字节码解释执行引擎" class="headerlink" title="8.5 基于栈的字节码解释执行引擎"></a>8.5 基于栈的字节码解释执行引擎</h2><h3 id="8-5-1-解释执行"><a href="#8-5-1-解释执行" class="headerlink" title="8.5.1 解释执行"></a>8.5.1 解释执行</h3><ul>
<li>基于物理机、JVM、或其他非Java的高级语言虚拟机的代码执行过程，大体上遵循现代经典编译原理的思路：在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树 AST(Abstract Syntax Tree)</li>
<li>词法、语法分析以及优化器、目标代码生成可以独立于执行引擎，形成完整意义的编译器，如C&#x2F;C++</li>
<li>也把其中一部分实现为一个半独立的编译器，如Java</li>
<li>又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子，如JavaScript执行引擎</li>
</ul>
<h3 id="8-5-2-基于栈的指令集和基于寄存器的指令集"><a href="#8-5-2-基于栈的指令集和基于寄存器的指令集" class="headerlink" title="8.5.2 基于栈的指令集和基于寄存器的指令集"></a>8.5.2 基于栈的指令集和基于寄存器的指令集</h3><ul>
<li>基于栈：<ul>
<li>指令通常不带参数(零地址指令)，使用操作数栈中的数据作为指令的运算输入，运算结果也存储在操作栈中</li>
<li>优点：可移植，代码相对紧凑，编译器实现更加简单</li>
<li>缺点：理论执行速度相对稍慢，完成相同功能所需指令数量更多</li>
</ul>
</li>
<li>基于寄存器：<ul>
<li>指令直接对寄存器进行操作，包含地址和操作数</li>
</ul>
</li>
</ul>
<h1 id="第九章-类加载及执行子系统的案例和实战"><a href="#第九章-类加载及执行子系统的案例和实战" class="headerlink" title="第九章 - 类加载及执行子系统的案例和实战"></a>第九章 - 类加载及执行子系统的案例和实战</h1><h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><h3 id="9-2-1-Tomcat：正统的类加载器架构"><a href="#9-2-1-Tomcat：正统的类加载器架构" class="headerlink" title="9.2.1 Tomcat：正统的类加载器架构"></a>9.2.1 Tomcat：正统的类加载器架构</h3><ul>
<li>一个功能健全的Web服务器需要解决以下问题：<ul>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以相互共享</li>
<li>服务器应尽可能保证自身的安全不受部署的程序的影响</li>
<li>支持HotSwap热替换功能</li>
</ul>
</li>
<li>Tomcat的类加载器<ul>
<li><code>Common</code>类加载器：加载<code>/commons/*</code>，可被Tomcat和所有Web程序共同使用</li>
<li><code>Catalina</code>类加载器(Server类加载器)：加载<code>/server/*</code>，可被Tomcat使用，对Web程序不可见</li>
<li><code>Shared</code>类加载器: 加载<code>/shared/*</code>，被所有Web程序共同使用，对Tomcat本身不可见</li>
<li><code>Webapp</code>类加载器：加载<code>/WebApp/WEB-INF/*</code>，仅被该Web程序使用</li>
</ul>
</li>
<li>每一个Web应用程序对应一个WebApp类加载器，可以存在多个实例</li>
<li>每一个JSP文件对应一个JasperLoader类加载器 (HotSpot，JSP文件修改后重新创建新的JSP类加载)<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload class="" title="alt Tomcat类加载器架构"></li>
</ul>
<h3 id="9-2-2-OSGi-灵活的类加载器架构"><a href="#9-2-2-OSGi-灵活的类加载器架构" class="headerlink" title="9.2.2 OSGi: 灵活的类加载器架构"></a>9.2.2 OSGi: 灵活的类加载器架构</h3><ul>
<li>OSGi (Open Service Gateway Initiative) 是OSGi联盟制定的基于Java语言的动态模块化规范</li>
<li>OSGi的每个模块Bundle的类加载器之间只有规则，没有固定的委派关系</li>
<li>从双亲委派模型的树形结构进一步发展成更加复杂的、运行时才能确定的网状结构</li>
</ul>
<h3 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h3><ul>
<li>字节码生成技术：javac、字节码类库、JSP编译器、AOP框架、动态代理(如Spring对Bean的增强)、反射等等</li>
<li>相对于实际用Java代码编写了代理类的<strong>静态代理</strong>，<strong>动态代理</strong>的优势不止是省去编码工作量，更是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为。当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</li>
</ul>
<h3 id="9-2-4-Backport工具：Java的时光机器"><a href="#9-2-4-Backport工具：Java的时光机器" class="headerlink" title="9.2.4 Backport工具：Java的时光机器"></a>9.2.4 Backport工具：Java的时光机器</h3><ul>
<li><code>Java Backporting Tools</code> Java逆向移植工具,把高版本JDK代码部署到低版本JDK环境中。实现工具如 Retrotranslator, Retrolambda</li>
<li>JDK每次升级的改进大致分以下五类：<ul>
<li>Java类库API的增强。如JDK 5引入的java.util.concurrent并发包</li>
<li>前端编译器层面的改进，称作语法糖。如自动装箱拆箱、变长参数、泛型等</li>
<li>需要在字节码中进行支持的改动。如动态语言支持需要新增invokedynamic指令</li>
<li>需要在JDK整体结构层面进行支持的改进。如Java模块化系统</li>
<li>集中在虚拟机内部的改进。如JDK 5重新定义的Java内存模型；G1、ZGC、Shenandoah收集器等</li>
</ul>
</li>
</ul>
<h2 id="9-3-实战-动手实现远程执行功能"><a href="#9-3-实战-动手实现远程执行功能" class="headerlink" title="9.3 实战 - 动手实现远程执行功能"></a>9.3 实战 - 动手实现远程执行功能</h2><p>使用前面学到的关于类加载及虚拟机执行子系统的知识去完成在服务端执行临时代码的功能。</p>
<h1 id="第十章-前边编译与优化"><a href="#第十章-前边编译与优化" class="headerlink" title="第十章 - 前边编译与优化"></a>第十章 - 前边编译与优化</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul>
<li>编译期可分为：<ul>
<li>前端编译器： *.java -&gt; *.class</li>
<li>JVM的即时编译器 JIT： 运行期字节码 -&gt; 本地机器码</li>
<li>静态提前编译器 AOT：  程序 -&gt; 二进制代码</li>
</ul>
</li>
<li>JVM对性能的全部优化集中在运行期的JIT中，让非javac产生的Class文件(如 JRuby、Groovy)也能享受编译器的优化措施</li>
<li>Java中的即时编译器在运行期的优化措施，支撑了程序执行效率的不断提升；前端编译器在编译期的优化过程，则是支撑了程序员的编码效率和语言使用者幸福感的提升。</li>
</ul>
<h2 id="10-2-Javac编译器"><a href="#10-2-Javac编译器" class="headerlink" title="10.2 Javac编译器"></a>10.2 Javac编译器</h2><pre><code class="hljs">Javac本身是由Java语言编写的程序
</code></pre>
<h3 id="10-2-1-Javac的源码与调试"><a href="#10-2-1-Javac的源码与调试" class="headerlink" title="10.2.1 Javac的源码与调试"></a>10.2.1 Javac的源码与调试</h3><p>编译过程大致分为1个准备过程+3个处理过程</p>
<ul>
<li>准备过程：初始化插入式注解处理器</li>
<li>解析与填充符号表过程，包括：<ul>
<li>词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树</li>
<li>填充符号表：产生符号地址和符号信息</li>
</ul>
</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程，包括：<ul>
<li>标注检查：对语法的静态信息进行检查</li>
<li>数据流及控制流分析：对程序动态运行过程进行检查</li>
<li>解语法糖：将简化代码编写的语法糖还原为原有的形式</li>
<li>字节码生成：将前面各个步骤所生成的信息转化为字节码</li>
</ul>
</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt javac编译过程">



<h3 id="10-2-2-解析与填充符号表"><a href="#10-2-2-解析与填充符号表" class="headerlink" title="10.2.2 解析与填充符号表"></a>10.2.2 解析与填充符号表</h3><p><strong>1. 词法、语法分析</strong></p>
<ul>
<li>词法分析：将源码中的字符流转变为标记Token的过程。程序编写的最小元素是单个字符，编译时的最小元素是标记。</li>
<li>语法分析：根据标记序列构造抽象语法树的过程。AST是一种用来描述程序代码语法结构的树形表示形式，其中每个节点都代表着程序代码中的一个语法结构，如包、类型、修饰符、运算符、接口等</li>
</ul>
<p><strong>2. 填充符号表</strong></p>
<ul>
<li>符号表是由一组符号地址和符号信息构成的数据结构 (类似键值对的存储形式)</li>
<li>符号表登记的信息在后续语义分析、目标代码生成阶段都要使用</li>
</ul>
<h3 id="10-2-3-注解处理器"><a href="#10-2-3-注解处理器" class="headerlink" title="10.2.3 注解处理器"></a>10.2.3 注解处理器</h3><ul>
<li>插入式注解器可以看作一组编译器的插件，插件工作时可以读取、修改、添加抽象语法树中的任意元素</li>
<li>处理注解期间，如果注解器对语法树进行过修改，编译器将重新解析、填充符号表。每次循环称为一个轮次Round</li>
<li>典型应用：Lombok工具</li>
</ul>
<h3 id="10-2-4-语义分析与字节码生成"><a href="#10-2-4-语义分析与字节码生成" class="headerlink" title="10.2.4 语义分析与字节码生成"></a>10.2.4 语义分析与字节码生成</h3><p><strong>1. 语义分析</strong></p>
<ul>
<li>AST能够表示一个结构正确的源程序，但无法保证语义符合逻辑，因此需要语义分析对结构上正确的源程序进行上下文相关性质的检查。</li>
<li>分以下两类：<ul>
<li>标注检查：检查包括变量使用前是否已被声明、变量与赋值之间的数据类型能否匹配等，另外还有<code>常量折叠</code>等少量代码优化</li>
<li>数据及控制流：检查诸如程序局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理了等问题。(某些语义只能在编译期，而不能在运行期检查)</li>
</ul>
</li>
</ul>
<p><strong>2. 语法糖 Syntactic Sugar</strong></p>
<ul>
<li>程序语言中添加的某种语法，这种语法对编译结果和功能并没有实际影响，但却能更方便程序员使用该语言。</li>
<li>解语法糖：编译阶段还原回基础语法结构</li>
<li>优点：减少代码量，增加程序可读性，减少代码出错的机会</li>
</ul>
<p><strong>3. 字节码生成</strong></p>
<ul>
<li>Javac编译过程的最后一个阶段，把前面各个步骤生成的信息(语法树、符号表)转化为字节码指令写入到磁盘中，还进行了少量代码添加和转换工作</li>
<li>完成对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交由<code>ClassWriter::writeClass()</code>方法输出字节码，生成最终的Class文件。至此编译过程宣告结束。</li>
</ul>
<h2 id="10-3-Java语法糖的味道"><a href="#10-3-Java语法糖的味道" class="headerlink" title="10.3 Java语法糖的味道"></a>10.3 Java语法糖的味道</h2><p>除了以下介绍的几种语法糖，还有内部类、枚举类、断言、数值字面量、对枚举和字符串的switch支持、try with、Lambda(非单纯的语法糖)等等</p>
<h3 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h3><ul>
<li>泛型的本质是参数化类型或者参数化多态</li>
<li>Java的泛型实现方式是”类型擦除式泛型” Type Erasure Generics，C#则是”具现化式泛型” Reified Generics</li>
<li>类型擦除的缺陷：<ul>
<li>无法支持原始数据类型</li>
<li>运行期无法取到泛型类型信息</li>
<li>丧失了面向对象思想应有的优雅，带来了一些模棱两可的状况</li>
</ul>
</li>
<li>未来 - Valhalla项目：<ul>
<li>新的泛型实现方案</li>
<li>值类型 Value Type：与引用类型一样具有构造函数、方法、字段等，区别在于赋值时通常是整体复制，而不是传递引用；可以分配在调用栈上，随方法退出而自动释放</li>
</ul>
</li>
</ul>
<h3 id="10-3-2-自动装箱、拆箱、遍历循环"><a href="#10-3-2-自动装箱、拆箱、遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱、遍历循环"></a>10.3.2 自动装箱、拆箱、遍历循环</h3><ul>
<li>自动装箱：Integer.valueOf()</li>
<li>自动拆箱：Integer.intValue()</li>
<li>遍历循环：Iterable::iterator()</li>
<li>变长参数：args[]</li>
</ul>
<h3 id="10-3-3-条件编译"><a href="#10-3-3-条件编译" class="headerlink" title="10.3.3 条件编译"></a>10.3.3 条件编译</h3><ul>
<li>Java的条件编译会根据布尔常量值的真假，消除分支中不成立的代码块</li>
<li>利用了if语句，因此只能实现语句基本块级别的条件编译</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>        System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        System.out.println(<span class="hljs-string">&quot;block 2&quot;</span>);<br>&#125;<br>----------------------------------<br><span class="hljs-comment">// 反编译后：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;block 1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="10-4-实战：插入式注解处理器"><a href="#10-4-实战：插入式注解处理器" class="headerlink" title="10.4 实战：插入式注解处理器"></a>10.4 实战：插入式注解处理器</h2><ul>
<li>注解处理器需要继承<code>javax.annotation.processing.AbstractProcessor,</code>且实现<code>process()</code></li>
<li><code>@SupportedAnnotationTypes</code>代表注解处理器对哪些注解感兴趣</li>
<li><code>@SupportedSourceVersion</code>指出可以处理哪些版本的Java代码</li>
<li>每一个注解处理器在运行时都是单例的</li>
</ul>
<h1 id="第十一章-后端编译与优化"><a href="#第十一章-后端编译与优化" class="headerlink" title="第十一章 - 后端编译与优化"></a>第十一章 - 后端编译与优化</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><ul>
<li>编译器无论在何时、在何种状态下把Class文件转换成本地基础设施(硬件指令集、操作系统)相关的二进制机器码，都可以视为整个编译过程的后端</li>
<li>后端编译器性能的好坏、代码优化质量的高低是衡量一款商用虚拟机优秀与否的关键指标之一，也是商业JVM的核心，最能体现技术水平与价值</li>
</ul>
<h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>Java最初都是通过解释器进行解释执行的，当JVM发现某个方法或代码块运行频繁，就会把它们判定为热点代码，编译成本地机器码，并通过各种手段进行优化，提高热点代码执行效率。完成这一任务的后端编译器称即时编译器 JIT</p>
<h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><ul>
<li>主流商用JVM都同时包含解释器和编译器<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92.png" srcset="/img/loading.gif" lazyload class="" title="alt 解释器与编译器的交互"></li>
<li>解释器<ul>
<li>启动迅速，节约内存</li>
<li>可以作为编译器激进优化的后备逃生门</li>
</ul>
</li>
<li>编译器<ul>
<li>执行效率高</li>
<li>HotSpot中包括客户端编译器C1，服务端编译器C2，以及Graal编译器</li>
<li>工作模式：-Xint仅解释模式，-Xcomp优先编译，以及默认的混合模式<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" lazyload class="" title="alt JVM执行模式"></li>
<li>分层编译：根据编译器编译、优化的规模与耗时，划分不同的编译层次，包括：<ul>
<li>第0层：程序纯解释执行，并且解释器不开启性能监控模式</li>
<li>第1层：使用C1编译字节码，进行简单可靠的稳定优化，不开启性能监控</li>
<li>第2层：C1编译，仅开启方法及回边次数统计等有限的性能监控</li>
<li>第3层：C1编译，开启全部性能监控，收集更多统计信息</li>
<li>第4层：C2编译，启用更多耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</li>
</ul>
</li>
<li>实施分层编译后，解释器、C1、C2同时工作，热点代码可能被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量</li>
</ul>
</li>
</ul>
<h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><ul>
<li>编译的对象——热点代码分两类：<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
</li>
<li>编译的目标对象都是整个方法体，而非单独的循环体。对于循环体，编译时自动进行”栈上替换”</li>
<li>热点探测的两种方式：<ul>
<li>基于采样：<ul>
<li>周期性检查各个线程的调用栈顶，如果某些方法经常出现在栈顶，即是热点方法。</li>
<li>实现简单高效，容易获取对象调用关系</li>
<li>不精确，容易受线程阻塞或其它外界因素的影响</li>
</ul>
</li>
<li>基于计数器：<ul>
<li>为每个方法、代码块设置计数器，统计方法的执行次数，超过阈值即热点方法</li>
<li>精确严谨</li>
<li>实现复杂，需要为每个方法建立并维护计数器，且不能直接获取方法调用关系</li>
</ul>
</li>
</ul>
</li>
<li>HotSpot采用第二种计数器方式，为每个方法设置<code>方法调用计数器</code>和<code>回边计数器</code><ul>
<li><p>方法调用计数器：统计方法一段时间内执行的相对频率。</p>
<ul>
<li>超过时间限度会进行热度衰减，计数器减半</li>
<li>这段时间称半衰周期<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt 方法调用计数器触发即时编译器"></li>
</ul>
</li>
<li><p>回边计数器：统计方法中循环体代码执行的次数</p>
<ul>
<li>统计的是绝对次数，没有热度衰减</li>
<li>回边计数器溢出时，会同步设置方法调用计数器为溢出状态<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8.png" srcset="/img/loading.gif" lazyload class="" title="alt 回边计数器触发即时编译器"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><ul>
<li><p>默认条件下，无论时方法调用产生的标准编译请求，还是栈上替换编译请求，JVM在编译器未完成编译前，都仍将解释执行代码，编译动作在后台编译线程中进行</p>
</li>
<li><p>客户端编译器：简单快速的三段式编译器，主要是局部优化</p>
<ul>
<li>阶段1：一个平台独立的前端将字节码构造成一个高级中间代码表示HIR</li>
<li>阶段2：一个平台相关的后端从HIR中产生低级中间代码表示LIR</li>
<li>阶段3：在平台相关的后端使用线性扫描算法在LIR上分配寄存器，做窥孔优化，产生机器代码<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E8%AF%91%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload class="" title="alt 客户端编译架构"></li>
</ul>
</li>
<li><p>服务端编译器：</p>
<ul>
<li>专门面向服务端的典型应用场景，针对性调整服务端的性能配置，能够容忍高优化复杂度</li>
<li>执行大部分经典的优化动作</li>
<li>根据解释器、C1提供的性能监控信息，进行一些不稳定的激进优化</li>
</ul>
</li>
</ul>
<h3 id="11-2-4-实战：查看及分析即时编译结果"><a href="#11-2-4-实战：查看及分析即时编译结果" class="headerlink" title="11.2.4 实战：查看及分析即时编译结果"></a>11.2.4 实战：查看及分析即时编译结果</h3><p>需要fastdebug&#x2F;slowdebug优化级别的HotSpot虚拟机……</p>
<h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><h3 id="11-3-1-提前编译的优劣得失"><a href="#11-3-1-提前编译的优劣得失" class="headerlink" title="11.3.1 提前编译的优劣得失"></a>11.3.1 提前编译的优劣得失</h3><ul>
<li>两条分支：<ul>
<li>与传统C、C++编译器类似，在程序运行之前把源码编译成机器码的静态翻译<ul>
<li>直击即时编译的最大弱点——占用程序运行时间和运算资源</li>
</ul>
</li>
<li>把原本即时编译器在运行时要做的编译工作提前做好保存，下次运行直接把它加载进来使用<ul>
<li>本质是做编译器缓存加速，改善Java程序启动时间，以及需要一段时间预热才能到达最高性能的问题，称为动态提前编译或即时编译缓存</li>
</ul>
</li>
</ul>
</li>
<li>然而，即时编译器相对于提前编译器有三条天然的优势：<ul>
<li>性能分析制导优化：实现一些只能在动态运行时才能显现的执行偏好</li>
<li>激进预测性优化：依赖性能监控信息可以做出不可靠的激进优化，由低级编译器和解释器负责保底</li>
<li>链接时优化：Java动态链接的本质使得代码优化没有边界隔阂</li>
</ul>
</li>
</ul>
<h3 id="11-3-2-实战：Jaotc的提前编译"><a href="#11-3-2-实战：Jaotc的提前编译" class="headerlink" title="11.3.2 实战：Jaotc的提前编译"></a>11.3.2 实战：Jaotc的提前编译</h3><p>Jaotc属于提前编译的第二条分支——编译器缓存加速，支持对Class文件和模块进行提前编译，以减少程序启动时间和到达全速性能的预热时间。但是必须针对特定物理机和目标虚拟机的运行参数。<br>JDK 17中移除了Jaotc</p>
<h2 id="11-4-编译优化技术"><a href="#11-4-编译优化技术" class="headerlink" title="11.4 编译优化技术"></a>11.4 编译优化技术</h2><h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p>分类：</p>
<ul>
<li>编译器策略</li>
<li>基于性能监控的优化技术</li>
<li>基于证据的优化技术</li>
<li>数据流敏感重写</li>
<li>语言相关的的优化技术</li>
<li>内存及代码位置变换</li>
<li>循环交换</li>
<li>全局代码调整</li>
<li>控制流图变换</li>
</ul>
<h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联:"></a>11.4.2 方法内联:</h3><ul>
<li>编译器最重要的优化手段，称为优化之母</li>
<li>目的：<ul>
<li>去除方法调用的成本</li>
<li><strong>为其它优化建立良好的基础</strong></li>
</ul>
</li>
<li>措施：把目标方法的代码原封不动复制到发起调用的方法之中</li>
<li>解决Java实例方法默认是虚方法的解决方案：<ul>
<li>类型继承关系分析CHA，确定方法类型</li>
<li>非虚方法 - 直接内联</li>
<li>虚方法 - 向CHA查询是否只有一个版本<ul>
<li>是 - 守护内联 (Java动态链接-&gt;激进优化，需预备好逃生门 -&gt; 解释执行&#x2F;重新编译)</li>
<li>否 - 内联缓存 (仍是方法调用，但快于查虚方法表。后续命中-&gt;单态内联缓存，未命中-&gt;超多态内联缓存)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><ul>
<li>前沿优化技术。不是直接优化代码，而是为其它优化措施提供依据</li>
<li>基本原理：<ul>
<li>分析对象动态作用域，当一个对象在方法里面被定义后，它可能传递到外部方法中使用，称为方法逃逸；</li>
<li>还有可能被外部线程访问，称线程逃逸</li>
<li>对象由低到高的逃逸程度：从不逃逸-&gt;方法逃逸-&gt;线程逃逸</li>
</ul>
</li>
<li>措施：<ul>
<li>栈上分配：<ul>
<li>如果一定对象不会发生线程逃逸，那么可以让这个对象在栈上分配，所占空间随栈帧出栈而销毁，减小GC压力</li>
<li>支持方法逃逸，不支持线程逃逸</li>
</ul>
</li>
<li>标量替换：<ul>
<li>标量：无法再分解成更小数据的表示，如原始数值类型、reference类型等</li>
<li>聚合量：数据可以继续分解</li>
<li>把一个Java对象拆散，根据程序访问情况，将其用到的成员变量恢复为原始类型来访问，这个过程称标量替换</li>
<li>不允许对象逃逸出方法之外</li>
</ul>
</li>
<li>同步消除：<ul>
<li>对不发生线程逃逸的对象，读写不会有竞争，可以安全消除线程同步措施</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><ul>
<li>经典的、普遍应用于各种编译器的优化技术</li>
<li>措施：<ul>
<li>如果一个表达式E之前被计算过，且中间E的所有变量没有变化，可以直接用之前计算过的结果替代E</li>
<li>限于程序基本块内的，称局部公共子表达式消除</li>
<li>涵盖多个基本块的，称全局公共子表达式消除</li>
</ul>
</li>
</ul>
<h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><ul>
<li>即时编译器中一项语言相关的经典优化技术</li>
<li>措施：确定数组长度，访问时直接对下标进行越界判断</li>
</ul>
<h2 id="11-5-实战：深入理解Graal编译器"><a href="#11-5-实战：深入理解Graal编译器" class="headerlink" title="11.5 实战：深入理解Graal编译器"></a>11.5 实战：深入理解Graal编译器</h2><ul>
<li>Graal使用Java编写</li>
<li>利用JVM CI实现与HotSpot分离。JVM CI的功能：<ul>
<li>响应HotSpot的编译请求，并将请求分发给Java实现的即时编译器</li>
<li>允许编译器访问HotSpot中与即时编译相关的数据结构，并提供一组这些数据结构在Java语言层面的抽象表示</li>
<li>提供HotSpot代码缓存的Java端抽象表示，允许编译器部署编译完成的二进制机器码</li>
</ul>
</li>
</ul>
<h1 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章 - Java内存模型与线程"></a>第12章 - Java内存模型与线程</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><ul>
<li>Amadahl定律：通过系统中并行化和串行化的比重来描述多处理器系统能获得的运算加速能力。代理摩尔定律成为计算机性能发展源动力的根本原因。</li>
<li>并发应用场景：<ul>
<li>计算机的运算速度与它的存储和通信子系统的速度差距过大，需要充分利用计算机处理器的能力</li>
<li>一个服务端需要同时对多个客户端提供服务</li>
</ul>
</li>
</ul>
<h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><ul>
<li>高速缓存: 内存与处理器之间的缓冲，复制同步策略</li>
<li>产生新的问题：共享内存多核系统的缓存一致性问题</li>
<li>乱序执行：尽量充分利用处理器内部的运算单元，且保证结果一致</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload class="" title="alt 计算机内存交互关系">
<center>计算机内存交互关系</center>



<h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><ul>
<li>模型必须足够严谨，让Java的并发内存访问操作不会产生歧义</li>
<li>模型必须足够宽松，使得虚拟机的实现能充分利用硬件的各种特性，如寄存器、高速缓存、特殊指令等，来获取更快的执行速度</li>
</ul>
<h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><ul>
<li>Java内存模型规定所有变量都存储在主内存中</li>
<li>每条线程有自己的工作内存，保存该线程使用的变量的主内存副本</li>
<li>线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的数据。</li>
<li>不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload class="" title="alt Java内存交互模型">
<center>Java内存交互模型</center>


<h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><ul>
<li>JVM必须保证以下操作是原子的、不可再分的：<ul>
<li>lock, unlock, read, load, use, assign, store, write</li>
</ul>
</li>
<li>上述8种基本操作必须满足一定规则<ul>
<li>略</li>
</ul>
</li>
</ul>
<h3 id="12-3-3-volatile型变量的特殊规则"><a href="#12-3-3-volatile型变量的特殊规则" class="headerlink" title="12.3.3 volatile型变量的特殊规则"></a>12.3.3 volatile型变量的特殊规则</h3><p>当一个变量被定义成volatile之后，将具备两项特性：</p>
<ol>
<li><p>保证此变量对所有线程的可见性(变量值修改后对其它线程立即可知)</p>
<ul>
<li>但并不完全保证线程安全</li>
<li>不符合以下两条规则的场景，仍需通过加锁保证原子性：<ul>
<li>运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量值</li>
<li>变量不需要与其它的状态变量共同参与不变约束</li>
</ul>
</li>
</ul>
</li>
<li><p>禁止指令重排序优化</p>
<ul>
<li>普通变量只能保证执行结果正确，不能保证变量赋值操作的顺序和程序代码中的执行顺序一致。即 <code>线程内表现为串行的语义 Within-Thread As-If-Serial Semantics</code></li>
</ul>
</li>
</ol>
<p>Java中对volatile变量特殊规定的定义：</p>
<ul>
<li>每次使用变量前必须先从主内存刷新最新值，保证能看见其它线程对变量所做的修改</li>
<li>每次修改变量必须立刻同步回主内存中，保证其它线程看到自己对变量的修改</li>
<li>volatile修饰变量不会被指令重排序优化，保证代码执行顺序与程序顺序相同</li>
</ul>
<h3 id="12-3-4-long、double型变量的特殊规则"><a href="#12-3-4-long、double型变量的特殊规则" class="headerlink" title="12.3.4 long、double型变量的特殊规则"></a>12.3.4 long、double型变量的特殊规则</h3><ul>
<li>对于没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。即<code>long和double的非原子性协定</code></li>
<li>但主流64位JVM并不会出现非原子性访问行为</li>
</ul>
<h3 id="12-3-5-原子性、可见性、有序性"><a href="#12-3-5-原子性、可见性、有序性" class="headerlink" title="12.3.5 原子性、可见性、有序性"></a>12.3.5 原子性、可见性、有序性</h3><ol>
<li><p>原子性 Atomicity</p>
<ul>
<li>由Java内存模型直接保证的原子性变量操作：read, load, assign, use, store, write</li>
<li>需要更大范围的原子性保证则可以用lock和unlock操作，反映到字节码层次就是monitorenter和monitorexit指令，而在Java代码中就是同步块synchronized关键字</li>
</ul>
</li>
<li><p>可见性 Visibility</p>
<ul>
<li>指当一个线程修改了共享变量的值后，其它线程能够立即得知这个参数</li>
<li>volatile变量可以保证多线程操作时变量的可见性，普通变量不行</li>
<li>除volatile外，synchronized、final关键字也可以实现可见性</li>
</ul>
</li>
<li><p>有序性 Ordering</p>
<ul>
<li>Java程序中，如果在本线程内观察，所有操作都是有序的；<code>线程内表现为串行的语义</code></li>
<li>如果在一个线程中观察另一个线程，所有的操作都是无序的。<code>指令重排序</code>和<code>工作内存与主内存同步延迟</code></li>
<li>volatile和synchronized保证线程之间操作的有序性</li>
</ul>
</li>
</ol>
<p>synchronized可以实现这三种特性，但也伴随着更大的性能影响</p>
<h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><ul>
<li>先行发生是Java内存模型中定义的两项操作之间的偏序关系</li>
<li>作用：判断数据是否存在竞争，数据是否安全</li>
<li>Java有且仅有以下这些天然的，无需任何同步器协助就存在的先行发生关系：<ul>
<li>程序次序规则</li>
<li>管程锁定规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
<li>线程中断规则</li>
<li>对象终结规则</li>
<li>传递性</li>
</ul>
</li>
<li>如果两个操作的关系不满足上述规则，也无法从这些规则推导出来，则它们没有顺序性保障，虚拟机可以对它们随意进行重排序</li>
<li>时间先后顺序与先行发生原则基本没有因果关系，衡量并发安全问题以先行发生原则为准</li>
</ul>
<h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><h3 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h3><ul>
<li>线程是比进程更轻量化的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度</li>
<li>目前，线程是Java进行处理器资源调度的最基本单位</li>
<li>Java提供了不同硬件和OS平台下对线程操作的统一处理。<code>java.lang.Thread</code>类的实例就代表一个线程，它的关键方法都被声明为Native，即依赖于具体平台的实现</li>
<li>实现线程主要由三种方式 (不局限于Java)：内核线程、用户线程、混合线程</li>
</ul>
<h4 id="1-使用内核线程-1-1"><a href="#1-使用内核线程-1-1" class="headerlink" title="1. 使用内核线程 1:1"></a>1. 使用内核线程 1:1</h4><ul>
<li>内核线程KLT是直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上</li>
<li>每个内核线程可以视为内核的一个分身，这样OS就能同时处理多件任务，称之为多线程内核</li>
<li>程序一般使用内核线程的一种高级接口——轻量级进程LWP，即线程。即每个轻量级进程都成为一个独立的调度单元，与内核线程是一对一的关系</li>
<li>局限性：<ul>
<li>由于是基于内核线程实现的，因此各种线程操作，如创建、析构、同步，都需要进行系统调用。系统调用需要在用户态和内核态之间切换，代价较高</li>
<li>每个LWP需要消耗一定的内核资源，因此一个系统支持LWP的数量有限</li>
</ul>
</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload class="" title="alt 内核线程实现">


<h4 id="2-使用用户线程-1-N"><a href="#2-使用用户线程-1-N" class="headerlink" title="2. 使用用户线程 1:N"></a>2. 使用用户线程 1:N</h4><ul>
<li>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及实现</li>
<li>用户线程的建立、同步、销毁、调度完全在用户态中完成，不需要内核帮助。因此速度快开销低，且支持大规模的线程数量</li>
<li>进程和用户线程之间是一对多的关系</li>
<li>缺点：没有内核支援，所有操作都需要用户程序自己去处理，实现复杂</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload class="" title="alt 用户线程实现">


<h4 id="3-使用用户线程-轻量级进程混合实现-N-M"><a href="#3-使用用户线程-轻量级进程混合实现-N-M" class="headerlink" title="3. 使用用户线程+轻量级进程混合实现 N:M"></a>3. 使用用户线程+轻量级进程混合实现 N:M</h4><ul>
<li>既存在用户线程，也存在轻量级进程</li>
<li>用户线程建立在用户空间，开销低，支持大规模的用户线程并发</li>
<li>OS支持的LWP作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度及处理器映射，并且用户线程的系统调用要通过LWP完成，大大降低进程被阻塞的风险</li>
<li>用户线程和LWP是多对多的关系</li>
</ul>
<h4 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4. Java线程的实现"></a>4. Java线程的实现</h4><ul>
<li>早期JDK 1.2以前的Classic虚拟机使用的是名为”绿色线程”的用户线程实现</li>
<li>目前，主流JVM普遍都是基于OS原生线程模型实现的，即1:1的内核线程模型</li>
</ul>
<h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><ul>
<li>线程调度：系统为线程分配处理器使用权的过程</li>
<li>调度方式：<ul>
<li>协同式<ul>
<li>线程的执行时间由线程本身控制，线程工作执行完后，需要主动通知系统切换线程</li>
<li>实现简单，但线程执行时间不可控</li>
</ul>
</li>
<li>抢占式 (Java的实现方法)<ul>
<li>由系统为每个线程分配执行时间</li>
<li>执行时间由系统控制，不会由一个线程导致进程或系统阻塞</li>
<li>可以通过线程优先级、优先级推进器等功能调节系统分配的执行时间，但不稳定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><ul>
<li>线程的6种状态：<ul>
<li>新建 New</li>
<li>运行 Runnable</li>
<li>无限期等待 Waiting</li>
<li>限期等待 Timed Waiting</li>
<li>阻塞 Blocked</li>
<li>结束 Terminated</li>
</ul>
</li>
<li>阻塞状态时等待另一个线程释放某个排它锁，而等待是等一段时间，或等某个唤醒的动作</li>
</ul>
<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload class="" title="alt 线程状态转换关系">


<h2 id="12-5-Java与协程"><a href="#12-5-Java与协程" class="headerlink" title="12.5 Java与协程"></a>12.5 Java与协程</h2><h3 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h3><ul>
<li>现代B&#x2F;S系统中一次对外部业务的请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也增加了服务的数量，缩短了留给每个服务的响应时间。例如<strong>微服务架构</strong></li>
<li>Java的内核线程模式存在切换、调度成本高昂，系统能容纳的线程数量有限等缺陷</li>
</ul>
<h3 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h3><ul>
<li>用户态和核心态的切换开销主要来源于响应中断、保护和恢复执行现场的成本。涉及一系列数据在各种寄存器、缓存中的来回拷贝</li>
<li>DOS操作系统曾出现过<code>栈纠缠Stack Twine</code>这种由用户模拟多线程的工作模式</li>
<li>最初的用户线程被设计为协同式调度，也称<code>协程</code>。分为有栈协程和无栈协程</li>
<li>协程的主要优势是轻量，同时存活数量以十万计</li>
<li>协程的局限性在于需要应用层实现的内容特别多，如调用栈、调度器</li>
</ul>
<h3 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h3><ul>
<li><code>纤程 Fiber</code>：典型的有栈协程，使用用户线程，并完整实现调用栈的保护、恢复工作</li>
<li>新并发模式下，使用纤程并发的代码分为执行过程和调度器</li>
<li>其实也可以不依赖虚拟机实现协程，如Kotlin的协程、Quasar协程库</li>
</ul>
<h1 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章- 线程安全与锁优化"></a>第13章- 线程安全与锁优化</h1><h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><p>“线程安全”的定义 (来自Brian Goetz -《Java Concurrency In Practice》)：<br>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，就称这个对象是线程安全的</p>
<h3 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h3><p>按线程安全由强至弱，将各种操作共享的数据分为以下五类：</p>
<ul>
<li><p><strong>1. 不可变</strong></p>
<ul>
<li>Immutable的对象一定是线程安全的，不需要任何保障措施</li>
<li>对于基本类型只要在定义时使用final修饰，就是不可变的</li>
<li>对于类对象，需要对象自行保证其行为不会对其状态产生任何影响</li>
<li>典型的不可变类型包括String, Long、 Double等数值包装类型, BigInteger、BigDecimal等大数据类型</li>
</ul>
</li>
<li><p><strong>2. 绝对线程安全</strong></p>
<ul>
<li>满足上述线程安全的定义，不管运行环境如何，都不需要任何额外的同步措施</li>
</ul>
</li>
<li><p><strong>3. 相对线程安全</strong></p>
<ul>
<li>即通常意义上的线程安全，需要保证对该对象的单次操作是线程安全的。但对于一些特定顺序的连续调用，需要额外的同步</li>
<li>Java中大部分声称线程安全的类都是相对线程安全</li>
</ul>
</li>
<li><p><strong>4. 线程兼容</strong></p>
<ul>
<li>指对象本身不是线程安全，但可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全使用</li>
</ul>
</li>
<li><p><strong>5. 线程对立</strong></p>
<ul>
<li>指不管调用端是否采取同步，都无法在多线程环境中并发使用代码</li>
<li>由于Java天生支持多线程，线程对立的代码很少出现，且通常是有害的，应尽量避免</li>
<li>如Thread::suspend(), Thread::resume()等</li>
</ul>
</li>
</ul>
<h3 id="13-2-2-线程安全的实现方式"><a href="#13-2-2-线程安全的实现方式" class="headerlink" title="13.2.2 线程安全的实现方式"></a>13.2.2 线程安全的实现方式</h3><p><strong>1. 互斥同步</strong></p>
<ul>
<li>最常见也最主要的并发正确性保障手段</li>
<li>同步指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</li>
<li>互斥是实现互斥的一种手段，例如临界区、互斥量、信号量</li>
<li>即互斥是因，同步是果；互斥是方法，同步是目的</li>
</ul>
<ul>
<li>synchronized是最基本的，重量级的块结构同步互斥手段<ul>
<li>编译后在同步块前后生成<code>monitorenter</code>和<code>monitorexit</code>字节码指令</li>
<li>通过对一个reference类型的参数指定锁定和解锁的对象</li>
<li>推论：<ul>
<li>synchronized同步块对同一条线程来说是可重入的。即同一线程不会死锁</li>
<li>synchronized同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。即无法强制退出</li>
</ul>
</li>
</ul>
</li>
<li>Lock接口，以非块结构实现互斥同步。典型实现如ReentrantLock, ReentrantReadWriteLock<ul>
<li>高级功能：等待可中断、公平锁、锁绑定多个条件</li>
<li>相同情况下，synchronized更加合适的原因：<ul>
<li>sychronized是语法层面的同步，足够清晰，也足够简单</li>
<li>Lock要确保在finally块中释放锁，否则可能永远不释放</li>
<li>JVM更容易针对synchronized进行优化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 非阻塞同步</strong></p>
<ul>
<li>互斥同步的主要问题在于进行线程阻塞和唤醒所带来的性能开销</li>
<li>非阻塞同步是一种基于冲突检测的乐观并发策略，即不管有没有风险，先进行操作，发生冲突再进行补偿措施</li>
<li>比较并交换 <code>CAS指令</code>：<ul>
<li>原子操作，不会被其它线程中断</li>
<li>三个操作数，内存位置V，旧的预期值A，准备设置的新值B</li>
<li>当且仅当V符合A时，处理器才会用B更新V的值，否则就不更新。无论是否更新，都返回旧值</li>
<li>逻辑漏洞 - ABA问题：原值A，被其他线程修改为B，后来又被修改回A，CAS无法判断是否未被修改过。可以通过控制变量值的版本来保证CAS正确性</li>
</ul>
</li>
</ul>
<p><strong>3. 无同步方案</strong></p>
<ul>
<li>如果程序不涉及共享数据，自然也就不需要任何同步措施保证正确性</li>
<li>可重入代码：<ul>
<li>又称纯代码，可以在任何时刻中断，去执行其它代码，不会影响执行结果</li>
<li>相对线程安全来说，可重入性是更为基础的特性，可以保证代码线程安全</li>
<li>即所有可重入代码都是线程安全的，但并非所有线程安全的代码都是可重入的</li>
</ul>
</li>
<li>线程本地存储：<ul>
<li>程序中的共享数据的代码能否保证再同一线程内执行，如果能也不需要进行同步</li>
<li>典型用例如消费队列的架构模式、经典Web交互模型中的”一个请求对应一个服务器线程”</li>
</ul>
</li>
</ul>
<h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p>目的：为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率</p>
<h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><ul>
<li>若一个物理机有一个以上的处理器&#x2F;核心，能让多线程并行执行，就可以让后面请求锁地线程稍等，但不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。</li>
<li>自旋锁：为了让线程等待，只需让线程执行一个忙循环，即自旋</li>
<li>JDK 6加入自适应自旋，自选的时间不再固定。根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。自旋获得锁的成功次数越多，自旋容许时间就越长</li>
</ul>
<h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><ul>
<li>指JVM即时编译器运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除</li>
<li>主要依据来源于逃逸分析的数据支持，如果一段代码的所有数据都不会逃逸出去被其他线程访问，就可以当作栈上数据，无需同步加锁</li>
</ul>
<h3 id="13-3-3-锁相关"><a href="#13-3-3-锁相关" class="headerlink" title="13.3.3 锁相关"></a>13.3.3 锁相关</h3><ul>
<li>一般编写代码要求同步块范围尽可能小</li>
<li>但如果JVM检测到一串零碎的操作都对同一个对象加锁，就会把加锁同步的范围扩展（粗化）到整个操作序列的外部</li>
</ul>
<h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><ul>
<li>目的是在没有多线程竞争的前提下，减少传统的重量级锁使用OS互斥量产生的性能消耗</li>
<li>对象头Mark Word的32位比特空间里，有2位用于存储锁标志位，标记未被锁定、轻量级锁、重量级锁、GC标记、可偏向等状态</li>
<li>使用CAS加锁解锁</li>
<li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁</li>
<li>轻量级锁能提升程序同步性能的依据是：”<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>“这一经验法则</li>
<li>如果确实存在锁的竞争，轻量级锁反而比传统的重量级锁更慢<img src="/2022/10/25/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%87%E5%BF%97%E4%BD%8D.png" srcset="/img/loading.gif" lazyload class="" title="alt 对象头标志位"></li>
</ul>
<h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><ul>
<li>目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能</li>
<li>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其它线程获取，则持有偏向锁的线程将永远不需要再进行同步</li>
<li>一旦另一个线程尝试获取这个锁，偏向模式立刻宣告结束</li>
<li>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象处于偏向锁状态，又收到需要计算一致性哈希码请求时，偏向状态立刻撤销，并且锁会膨胀为重量级锁(可以通过<code>ObjectMonitor</code>拿到哈希码)</li>
<li>偏向锁可以提高带有同步但无竞争的程序性能，但同样带有效益权衡。如果程序中大多数锁都总是被多个不同的线程访问，那偏向模式就是多余的</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/JVM/">#JVM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java-虚拟机</div>
      <div>https://chanpero.github.io/2022/10/25/Java-虚拟机/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>chanper</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/17/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="算法模板">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法模板</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/16/LeetCode-%E4%BD%8D%E8%BF%90%E7%AE%97/" title="LeetCode-位运算">
                        <span class="hidden-mobile">LeetCode-位运算</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'chanpero/commit-utterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
